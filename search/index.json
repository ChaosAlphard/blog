[{"content":"ArchLinux初始配置以及常用软件安装 更换 Arch Linux 镜像源 修改 /etc/pacman.d/mirrorlist 文件, 添加国内镜像\n# China Server = https://mirrors.xjtu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.wsyu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.shanghaitech.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.qvq.net.cn/archlinux/$repo/os/$arch Server = https://mirrors.qlu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.jxust.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.jlu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch Server = https://mirror.nyist.edu.cn/archlinux/$repo/os/$arch 创建用户目录 用户目录指位于 $HOME 下的一系列常用目录, 例如 Documents, Downloads, Music, 以及 Desktop. 用户目录会在文件管理器中显示为不同的图标, 且被多种应用程序所参照. 可以使用 xdg-user-dirs包 自动生成这些目录. 详细信息参考freedesktop.org\n# 安装 xdg-user-dirs pacman -S xdg-user-dirs # 创建经本地化的用户目录 xdg-user-dirs-update # 如果不想创建中文目录(桌面/下载/音乐)可以用以下指令创建英文目录(Desktop/Downloads/Music) # 如果想创建其他语言的本地化用户目录, 修改LC_ALL参数即可. 如：LC_ALL=en_GB LC_ALL=C xdg-user-dirs-update --force xdg-user-dirs-update指令运行后还会在~/.config/目录下自动创建user-dirs.dirs和user-dirs.locale文件, 如果想修改用户目录对应的目录的名称, 则修改user-dirs.dirs文件中的内容即可\nXDG_DESKTOP_DIR=\u0026#34;$HOME/Desktop\u0026#34; XDG_DOWNLOAD_DIR=\u0026#34;$HOME/Downloads\u0026#34; XDG_TEMPLATES_DIR=\u0026#34;$HOME/Templates\u0026#34; XDG_PUBLICSHARE_DIR=\u0026#34;$HOME/Public\u0026#34; XDG_DOCUMENTS_DIR=\u0026#34;$HOME/Documents\u0026#34; XDG_MUSIC_DIR=\u0026#34;$HOME/Music\u0026#34; XDG_PICTURES_DIR=\u0026#34;$HOME/Pictures\u0026#34; XDG_VIDEOS_DIR=\u0026#34;$HOME/Videos\u0026#34; 添加 Arch Linux CN 软件仓库 Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含中文用户常用软件、工具、字体/美化包等。\n完整的包信息列表（包名称/架构/维护者/状态）请点击这里查看。\n官方仓库地址：https://repo.archlinuxcn.org, 这里我使用清华大学的镜像站, 更多镜像站地址可以在ArchLinuxCN的Github项目中查看\n在 /etc/pacman.conf 文件末尾添加以下两行：\n[archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 在本地信任 farseerfc 的 GPG key：\nsudo pacman-key --lsign-key \u0026#34;farseerfc@archlinux.org\u0026#34; 之后通过以下命令安装 archlinuxcn-keyring 包导入 GPG key。\nsudo pacman -Sy archlinuxcn-keyring 安装Aur助手 推荐paru和pacseek, pacseek方便查找软件. 在终端中输入以下指令\n# 安装paru sudo pacman -S --needed base-devel git git clone https://aur.archlinux.org/paru-bin.git cd paru-bin makepkg -si # 安装pacseek paru -S pacseek # 修改pacseek配置, InstallCommand修改为\u0026#34;paru -S\u0026#34;, UninstallCommand修改为\u0026#34;paru -Rsn\u0026#34;, SysUpgradeCommand修改为\u0026#34;paru\u0026#34; nano ~/.config/pacseek/config.json  \n安装输入法 安装fcitx5-im和fcitx5-rime, 如果需要双拼输入则再安装rime-ice-double-pinyin-flypy-git\n之后编辑 /etc/environment 并添加以下几行, 然后重新登录\nGTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx SDL_IM_MODULE=fcitx INPUT_METHOD=fcitx GLFW_IM_MODULE=ibus 配置Rime Rime配置文件目录在~/.local/share/fcitx5/rime, 新建default.custom.yaml文件以对默认设置进行修改\npatch:# 输入方案列表schema_list:# 小鹤双拼- schema:double_pinyin_flypy# 以下是rime的预设方案# 朙月拼音# - schema: luna_pinyin# - schema: luna_pinyin_simp# - schema: luna_pinyin_fluency# 注音符號輸入# - schema: bopomofo# - schema: bopomofo_tw# 倉頡輸入法# - schema: cangjie5# 五筆畫輸入法# - schema: stroke# 地球拼音# - schema: terra_pinyinmenu:# 候选页大小page_size:7如果要修改输入方案的默认配置, 则在~/.local/share/fcitx5/rime下创建\u0026lt;方案名称\u0026gt;.custom.yaml文件, 方案配置文件保存在/usr/share/rime-data目录, 找到\u0026lt;方案名称\u0026gt;.schema.yaml将里面要修改的选项复制到\u0026lt;方案名称\u0026gt;.custom.yaml文件中并进行修改\npatch:speller:algebra:- erase/^xx$/- derive/^([jqxy])u$/$1v/# 添加模糊音- derive/([aei])n$/$1ng/ # an =\u0026gt; ang, en =\u0026gt; eng, in =\u0026gt; ing- derive/([aei])ng$/$1n/ # ang =\u0026gt; an, eng =\u0026gt; en, ing =\u0026gt; in# 下面这些是输入方案预设配置, 不需要的可以删掉- derive/^([aoe])([ioun])$/$1$1$2/- xform/^([aoe])(ng)?$/$1$1$2/- xform/iu$/Ⓠ/- xform/(.)ei$/$1Ⓦ/- xform/uan$/Ⓡ/- xform/[uv]e$/Ⓣ/- xform/un$/Ⓨ/- xform/^sh/Ⓤ/- xform/^ch/Ⓘ/- xform/^zh/Ⓥ/- xform/uo$/Ⓞ/- xform/ie$/Ⓟ/- xform/(.)i?ong$/$1Ⓢ/- xform/ing$|uai$/Ⓚ/- xform/(.)ai$/$1Ⓓ/- xform/(.)en$/$1Ⓕ/- xform/(.)eng$/$1Ⓖ/- xform/[iu]ang$/Ⓛ/- xform/(.)ang$/$1Ⓗ/- xform/ian$/Ⓜ/- xform/(.)an$/$1Ⓙ/- xform/(.)ou$/$1Ⓩ/- xform/[iu]a$/Ⓧ/- xform/iao$/Ⓝ/- xform/(.)ao$/$1Ⓒ/- xform/ui$/Ⓥ/- xform/in$/Ⓑ/- xlit/ⓆⓌⓇⓉⓎⓊⒾⓄⓅⓈⒹⒻⒼⒽⒿⓀⓁⓏⓍⒸⓋⒷⓃⓂ/qwrtyuiopsdfghjklzxcvbnm/","date":"2024-04-10T14:08:24+08:00","permalink":"https://chaosalphard.github.io/p/archlinux%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/","title":"ArchLinux初始配置以及常用软件安装"},{"content":"Arch Linux 安装手册 首先在Arch Linux官网下载iso文件，之后使用Rufus等工具将iso文件刻录到U盘中\n \n输入archinstall进入安装界面\n \nMirrors 选择镜像地区\nLocales Locale language如果平时使用tty就选en_US.UTF-8, 不要选zh_CN, 否则安装好后tty里面会出现方块, 但是如果要安装桌面或者不使用tty那这里就可以选zh_CN.UTF-8, 这里我选zh_CN.UTF-8因为之后要安装桌面.\nLocale encoding选UTF-8, 避免编码问题\n \nDisk Configuration 第一个选项是自动分区, 第二个是手动分区, 第三个是加载分区配置文件. 这里我选自动分区，格式选btrfs, 这样他就会自动帮我分好带5个子卷的btrfs分区\n \n如果有需要调整的地方可以在这里修改\n \nDisk Encryption 硬盘加密, 根据自己需要设置就行\nBoot Loader 选自己喜欢的就行, 我用Grub\nSwap 按个人喜好决定要不要启用, 这里提供的是swap on zram, 如果想使用传统的swap则需要自己手动分配\nHostname 主机名称, 填你自己喜欢的就行, 比如Ilirus-PC\nRoot Password 随便填, 不要留空就行, 不然用不了root\nUser Account 按个人需要创建用户\n \nProfile 可以在这里选择想安装的桌面, 也可以选 Minimal 之后自己手动安装\n   \nAudio 不知道干嘛的, 这里选No安装好后也有声音\nKernels Linux内核, 一般默认选linux即可, 如果经常长期不用电脑可以选linux-lts, 如果要用Waydriod运行安卓App可以选linux-zen. 可以多选, 按空格选择, 按回车确认\nAdditional Packages 安装linux时要一起安装的组件, 建议安装noto-fonts-cjk中文字体、fcitx5-im输入法组件以及对应CPU的微码, Intel的CPU安装intel-ucode, AMD的CPU安装amd-ucode, 我这里用的是虚拟机所以就不安装了\n \nNetwork Configuration 第一个是复制liveISO中的配置, 第二个是用NetworkManager管理, 安装了桌面环境一般选这个, 第三个是手动配置\n \nTimezone 选自己所在的时区即可, 按/可以进行搜索\n \nAutomatic Time Sync 自动校准时间, 默认开启\nOptional Repositories 额外软件库, 要安装32位程序就启用multilib, testing不建议启用. 可以多选, 按空格选择, 按回车确认\n \nSave Configuration 保存安装配置到新系统, 可以方便以后安装\nInstall 确认无误后选择Install选项即可开始安装, 因为需要从网络下载文件所以安装期间请保持网络通畅\n安装完成后会询问你是否要进入新安装的系统进行设置, 这里选yes或者no都行\n \n选择yes则可以在这里进行一些配置, 如果之前没有在Additional Packages选择安装fcitx5, 就可以在这里进行安装.\n \n如果前面语言选择了en_US的则可以在这里启用zh_CN, 选择了zh_CN也建议在这里启用en_US作为fallback\n输入nano /etc/locale.gen, 分别把en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8前面的注释取消\n之后执行locale-gen指令重新生成Locale, 之后输入nano /etc/locale.conf修改文件内容\nLANG=zh_CN.UTF-8 LANGUAGE=zh_CN:en_US 如果安装了fcitx5-im, 则可以在这里配置输入法， 输入nano /etc/environment在文件内添加以下几行\nGTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx SDL_IM_MODULE=fcitx INPUT_METHOD=fcitx GLFW_IM_MODULE=ibus 配置完成后输入exit退出, 等待系统提示You may now reboot时输入reboot重启\n重启后进入桌面, 因为什么都没有配置所以这里背景是黑色, 并且因为自带的图标包不完整所以有些图标显示不出来, 建议先更换图标包再进行其他配置\n \n稍微调整后的结果, 主题使用Materia, 图标使用Papirus\n \n","date":"2024-04-10T08:00:00+08:00","permalink":"https://chaosalphard.github.io/p/arch-linux-%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C/","title":"Arch Linux 安装手册"},{"content":"MySQL 数据库三范式 第一范式 1NF：表中字段的数据，不可以再拆分\n这张表因为姓名字段可再拆分所以不符合第一范式\n   ID 姓名 年龄     1 销售部小张 28    而这张表符合\n   ID 部门 姓名 年龄     1 销售部 小张 28    第二范式 2NF：在满足第一范式的情况下，遵循唯一性，消除部分依赖。\n即：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值\n通俗来讲就是一个表只能描述一件事情\n   学号 姓名 年龄 课程名称 成绩 学分     001 小张 28 语文 90 3   001 小张 28 数学 90 2    学号做主键，可确定姓名，但不能确定课程与成绩。所以不符合第二范式\n需要拆分为学生表、课程表、成绩表，才符合第二范式\n第三范式 3NF：在满足第二范式的情况下，消除传递依赖。 即：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B\n   学号 姓名 班级 班主任     001 小黄 一年级（1）班 高老师    学号作为主键，可确定姓名、班级、班主任，但通过班级也可确定班主任。所以不符合第三范式\n需要拆分为学生表、班级表，才符合第三范式\n什么是事务 事务是逻辑上的一组操作，要么都执行，要么都不执行\n什么是索引 数据库索引是一种用于提高数据库查询性能的数据结构。索引由一个或多个列组成，并按照特定的排序规则进行存储。\n索引的优缺点 优点\n 大大加快数据检索的速度。 将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的) 加速表与表之间的连接  缺点\n 建立索引需要占用物理空间。 当对表进行插入、更新和删除时，索引也需要进行相应的更新。会增加写操作的代价，特别是对于频繁进行数据修改的表。 创建和维护索引都需要花费精力时间。  索引的数据结构 索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎默认的索引类型为B+树索引。\nHash表和B+树的区别 Hash索引一般用于精确的等值查找，大多数情况下使用B+索引\n 哈希索引不支持排序，因为哈希表是无序的。 哈希索引不支持范围查找。 哈希索引不支持模糊查询及多列索引的最左前缀匹配。 因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的。 B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点  为什么使用B+树而不是B树  B树适用于随机检索，而B+树适用于随机检索和顺序检索 B+树的空间利用率更高，因为B树每个节点要存储键和值，而B+树的内部节点只存储键，这样B+树的一个节点就可以存储更多的索引，从而使树的高度变低，减少了I/O次数，使得数据检索速度更快。 B+树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便 B+树的性能更加稳定，因为在B+树中，每次查询都是从根节点到叶子节点，而在B树中，要查询的值可能不在叶子节点，在内部节点就已经找到。  索引的类型有哪些  FULLTEXT: 全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL5.6.4以上版本支持全文索引，一般用于查找文本中的关键字，而不是直接比较是否相等，主要是用来解决WHERE name LIKE \u0026ldquo;%zhang%\u0026ldquo;等针对文本的模糊查询效率低的问题。- HASH:哈希索引，哈希索引多用于等值查询，时间复杂夫为o(1)，效率非常高，但不支持排序、范围查询及模糊查询等。- BTREE:B+树索引，INnoDB存储引擎默认的索引，支持排序、分组、范围查询、模糊查询等，并且性能稳定。 RTREE:空间数据索引，多用于地理数据的存储，相比于其他索引，空间数据索引的优势在于范围查找  索引的种类有哪些  主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引 组合索引：由多个列值组成的索引。 唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。 全文索引：对文本的内容进行搜索。 普通索引：基本的索引类型，可以为NULL  什么是聚簇索引，什么是非聚簇索引  聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。 非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。  索引的使用场景有哪些  对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描速度更快些。 对于超大型的表，建立和维护索引的代价也会变高，这时可以考虑分区技术。 如何表的增删改非常多，而查询需求非常少的话，那就没有必要建立索引了，因为维护索引也是需要代价的。 一般不会出现再where条件中的字段就没有必要建立索引了。 多个字段经常被查询的话可以考虑联合索引。 字段多且字段值没有重复的时候考虑唯一索引。 字段多且有重复的时候考虑普通索引。  索引的设计原则  最适合索引的列是在where后面出现的列或者连接句子中指定的列，而不是出现在SELECT关键字后面的选择列表中的列。 索引列的基数越大，索引的效果越好，换句话说就是索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差，因为列的基数最多也就是三种，大多不是男性就是女性。 尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。 尽量利用最左前缀。 不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。  什么是最左匹配原则 最左匹配原则：从最左边为起点开始连续匹配，遇到范围查询（\u0026lt;、\u0026gt;、between、like）会停止匹配。\n索引在什么情况下会失效  条件中有or，例如select * from table_name where a = 1 or b = 3 在索引上进行计算会导致索引失效，例如select * from table_name where a + 1 = 2 在索引的类型上进行数据类型的隐形转换，会导致索引失效，例如字符串一定要加引号，假设 select * from table_name where a = '1'会使用到索引，如果写成select * from table_name where a = 1则会导致索引失效。 在索引中使用函数会导致索引失效，例如select * from table_name where abs(a) = 1 在使用like查询时以%开头会导致索引失效 索引上使用！、=、\u0026lt;\u0026gt;进行判断时会导致索引失效，例如select * from table_name where a != 1 索引字段上使用 is null/is not null判断时会导致索引失效，例如select * from table_name where a is null  SQL优化  对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by涉及的列上建立索引。 避免在 where 子句中使用 !=或\u0026lt;\u0026gt;操作符，否则将引擎放弃使用索引而进行全表扫描 避免在 where 子句中对字段进行 null 值 判断，否则将导致引擎放弃使用索引而进行全表扫描 避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描 避免在 where 子句中对字段进行表达式操作，否则将导致全表扫描，如where num/2=10应该为where num=10*2 避免在where子句中对字段进行函数操作，否则将导致全表扫描 在使用索引字段作为条件时，如果该索引是\u0026quot;联合索引\u0026rdquo;，那么必须使用到该索引中的第一个字段作为条件才能保证系统使用该索引，否则该索引将不会被使用。并且应尽可能的让字段顺序与索引顺序相一致 任何地方都不要使用 select * from t ，用具体的字段列表代替\u0026rdquo;*\u0026quot;  行锁、表锁是什么  表级锁：是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。 行级锁：是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。  行锁的注意事项 InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁，所以当使用行锁但where条件中没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。\n共享锁和排他锁 表锁与行锁，都存在共享锁(ShareLock/读锁/S锁)和排他锁(ExclusiveLock/写锁/独占锁/X锁)：\n 共享锁(S锁)：事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。 排他锁(X锁)：事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。  排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。\n    S 锁 X 锁     S 锁 不冲突 冲突   X 锁 冲突 冲突    脏读、幻读、不可重复读是什么  脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。  SQL 标准定义了哪些事务隔离级别?  READ-UNCOMMITTED(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读) ： (默认级别)对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化) ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。     隔离级别 脏读 不可重复读 幻读     READ-UNCOMMITTED √ √ √   READ-COMMITTED × √ √   REPEATABLE-READ × × √   SERIALIZABLE × × ×    什么是E-R图 E-R图 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。\n为什么不推荐使用级联与外键  数据库性能问题：使用级联和外键可能会对数据库的性能产生负面影响。当执行插入、更新或删除操作时，级联操作会引发额外的查询和操作，可能导致性能下降，特别是在处理大型数据集时。 复杂性和可维护性：使用级联和外键可能增加数据库的复杂性，使其更难以理解和维护。级联操作可以在数据库中引入复杂的依赖关系，导致难以预测和处理的情况。此外，如果数据库结构需要进行更改，可能需要修改和管理多个级联关系，增加了开发和维护的困难。 数据完整性问题：虽然外键可以确保引用完整性，即确保关系中的引用值存在于关联表中，但它们并不能解决所有数据完整性问题。外键无法处理复杂的业务规则和约束，这可能需要在应用程序级别进行处理。 级联效应的潜在问题：级联操作可能导致意外的结果，特别是在删除操作时。如果不小心使用级联删除操作，可能会删除不应该被删除的数据。这可能会导致数据丢失或破坏数据的完整性。  数据库设计通常分为哪几个阶段  系统需求分析阶段； 概念结构设计阶段； 逻辑结构设计阶段； 物理结构设计阶段； 数据库实施阶段； 数据库运行与维护阶段；  Mybatis 什么是ORM ORM即对象关系映射，是一种数据持久化技术。它在对象模型和关系型数据库直接建立起对应关系，并且提供一种机制，通过JavaBean对象去操作数据库表的数据。\n什么是数据持久化 数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。例如，文件的存储、数据的读取等都是数据持久化操作。数据模型可以是任何数据结构或对象的模型、XML、二进制流等。\nMyBatis与Hibernate有哪些不同 Mybatis直接编写原生sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。\nHibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。\nmybatis分页插件的实现 如何写一个mybatis分页插件 mybatis的原理 mybatis如何代理sql语句 mybatis的xml标签\n#{}和${}的区别是什么  #{} 是预编译处理，${}是字符串替换。 Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； Mybatis在处理${}时，就是把${}替换成变量的值。 使用#{}可以有效的防止SQL注入，提高系统安全性。  Mybatis的一级、二级缓存  一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ； 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。  Dao 接口的工作原理是什么 通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是人们常说的 Mapper 接口；接口的全限名，就是映射文件中的 namespace 的值；接口的方法名，就是映射文件中 MappedStatement 的 id 值；接口方法内的参数，就是传递给 sql 的参数。 Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement ，举例： com.mybatis3.mappers. StudentDao.findStudentById ，可以唯一找到 namespace 为 com.mybatis3.mappers. StudentDao 下面 id = findStudentById 的 MappedStatement 。在 MyBatis 中，每一个 \u0026lt;select\u0026gt; 、 \u0026lt;insert\u0026gt; 、 \u0026lt;update\u0026gt; 、 \u0026lt;delete\u0026gt; 标签，都会被解析为一个 MappedStatement 对象。\nMapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。\nDao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 MappedStatement 所代表的 sql，然后将 sql 执行结果返回。\nMybatis是如何进行分页的？分页插件的原理是什么？ Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。\n分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。\nMybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？ 第一种是使用 \u0026lt;resultMap\u0026gt; 标签，逐一定义列名和对象属性名之间的映射关系。\n第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME\nMybatis动态sql有什么用？执行原理？有哪些动态sql？ MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。\nMyBatis 提供了 9 种动态 sql 标签: if, where, trim, set, choose, when, otherwise, foreach, bind\nMyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复 不同的 xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复。\nMyBatis实现一对一有几种方式?具体怎么操作的？  有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成； 嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。  MyBatis实现一对多有几种方式,怎么操作的？  有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。  Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？  Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。  MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？  SimpleExecutor： 每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。 ReuseExecutor： 执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map\u0026lt;String, Statement\u0026gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。 BatchExecutor 执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。  MyBatis 中如何指定使用哪一种 Executor 执行器？ 在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数。\nMyBatis 是否可以映射 Enum 枚举类？ 可以。通过自定义一个 TypeHandler，实现 TypeHandler 的 setParameter() 和 getResult() 接口方法。即可映射大部分类型\nRedis 缓存模式   Cache-Aside\n 读的时候，先读缓存，缓存命中的话，直接返回数据 缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应 更新的时候，先更新数据库，然后再删除缓存    Read/Write Through\n 从缓存读取数据，读到直接返回 如果读取不到的话，从数据库加载，写入缓存后，再返回响应。 先更新数据源，再更新缓存    Write behind\n 与Read/Write Through类似，但是不直接更新数据源，只更新缓存，之后通过异步批量写入数据源    ","date":"2023-05-25T20:22:46+08:00","permalink":"https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Java开发知识点简单总结-数据库"},{"content":"Spring Spring IoC IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。\n为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。\n在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。\n在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。\nSpring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。\n什么是 Spring Bean 简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。\n将一个类声明为 Bean 的注解有哪些  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。  @Component 和 @Bean 的区别是什么  @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。 @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。  @Autowired 和 @Resource 的区别是什么 @Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)\n@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。\nBean 的作用域有哪些 使用@Scope()可配置bean的作用域\n singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。 prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。 request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。 session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。 application/global-session （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。 websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。  Spring AOP AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\nSpring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理\nSpring AOP 和 AspectJ AOP 有什么区别 Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。\nAspectJ 定义的通知类型有哪些  Before（前置通知）：目标对象的方法调用之前触发 After （后置通知）：目标对象的方法调用之后触发 AfterReturning（返回通知）：目标对象的方法调用完成，在返回结果值之后触发 AfterThrowing（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。 Around： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法  多个切面的执行顺序如何控制 使用 @Order 注解，或者使用 Ordered 接口重写 getOrder() 方法\nSpring MVC MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。\nSpring MVC 的核心组件有哪些  DispatcherServlet ：核心的中央处理器，负责接收请求、分发，并给予客户端响应。 HandlerMapping ：处理器映射器，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。 HandlerAdapter ：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler； Handler ：请求处理器，处理实际请求的处理器。 ViewResolver ：视图解析器，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端  Spring、SpringMVC与Springboot的区别 Spring 是一个综合性的开发框架，提供了大量的功能和模块，用于开发各种类型的应用程序，包括Web应用、企业级应用、批处理应用等。Spring框架采用模块化的设计，包含了核心容器、数据访问、Web开发、AOP、消息队列等模块。使用Spring框架，开发人员需要手动进行配置和设置，定义各个模块的组件和关系。\nSpring Boot 是一个用于快速构建独立的、可扩展的、基于Spring的应用程序的框架。它旨在简化Spring应用程序的配置和部署过程。Spring Boot提供了自动配置的特性，通过约定大于配置的方式，大大减少了开发人员需要编写的配置代码量。它内置了一个嵌入式Servlet容器（如Tomcat、Jetty等），可以独立运行应用程序，而无需外部的Java EE容器。\nSpring MVC 是基于Spring框架的一个Web应用程序开发框架，它提供了一套用于构建Web应用程序的组件和模型。Spring MVC需要进行配置和设置，包括定义控制器、处理请求映射、配置视图解析器等。它是基于Servlet技术的，需要依赖于Java EE容器（如Tomcat）来运行。\n综上所述，Spring是一个综合性的开发框架，提供了各种模块和功能，需要手动配置和设置。\nSpring MVC是一个传统的基于Spring的Web应用程序开发框架，需要进行详细的配置和设置。\nSpring Boot是Spring的子项目，旨在简化配置和部署过程，提供了自动配置和开箱即用的特性，使得开发人员能够更加快速地搭建和开发应用程序。可以说，Spring Boot是在Spring框架的基础上提供了更高层次的抽象和简化。\nSpringboot的自动配置 重点在@EnableAutoConfiguration 注解，约定大于配置，@EnableAutoConfiguration注解可以自动载入应用程序所需要的所有默认配置\nSpringBoot 中的 starter starter提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。\nSpring Boot 的核心注解是哪个 启动类上面的注解@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：\n @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。 @ComponentScan：Spring组件扫描。  Spring事务 Spring管理事务的方式有几种  编程式事务 ： 在代码中硬编码(不推荐使用) : 通过 TransactionTemplate或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。 声明式事务 ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多） PS: @Transactional默认只在RuntimeException回滚，通常需要手动指定@Transactional(rollbackFor = Exception.class)  Spring事务有哪几种传播行为 当事务方法被另一个事务方法调用时，需要指定事务应该如何传播\n1.TransactionDefinition.PROPAGATION_REQUIRED\n如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。\n使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。\n2.TransactionDefinition.PROPAGATION_REQUIRES_NEW\n创建一个新的事务，如果当前存在事务，则把当前事务挂起。\n也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。\n3.TransactionDefinition.PROPAGATION_NESTED\n如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。\n4.TransactionDefinition.PROPAGATION_MANDATORY\n如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n以下3种传播方式会导致事务失效\n5.TransactionDefinition.PROPAGATION_SUPPORTS\n如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。\n6.TransactionDefinition.PROPAGATION_NOT_SUPPORTED\n以非事务方式运行，如果当前存在事务，则把当前事务挂起。\n7.TransactionDefinition.PROPAGATION_NEVER\n以非事务方式运行，如果当前存在事务，则抛出异常。\nSpring事务的隔离级别有哪几种 TransactionDefinition.ISOLATION_DEFAULT\n使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.\nTransactionDefinition.ISOLATION_READ_UNCOMMITTED\n最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\nTransactionDefinition.ISOLATION_READ_COMMITTED\n允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\nTransactionDefinition.ISOLATION_REPEATABLE_READ\n对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\nTransactionDefinition.ISOLATION_SERIALIZABLE\n最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\nSpring事务失效的几种情况  方法不是public修饰的。Spring要求被代理的方法必须是public的 方法被final修饰。Spring事务底层使用了aop，也就是通过jdk动态代理或者cglib生成代理类，如果方法被final修饰了，在代理类里就无法重写该方法，也无法添加事务功能。被static修饰的方法也一样会失效。 在类的内部被调用。例如在add方法中调用this.update，这样不会经过Spring的代理，也就无法被Spring添加事务。解决方法是使用 TransactionTemplate或者 TransactionManager 手动添加事务 业务与事务不在同一线程中。Spring事务实现中使用了ThreadLocal，ThreadLocal只能在同一个线程中生效，例如在方法中使用了另一个线程操作数据库则事务不会生效 异常类型不匹配。@Transactional默认只在遇到RuntimeException时回滚，如果要所有都回滚则需要配置@Transactional(rollbackFor=Exception.class) 异常被方法内部处理。异常被方法内部处理而没有抛出异常，则不会进行回滚 数据源未配置事务管理器。 数据库引擎不支持事务。MySQL5.5之前的默认存储引擎是MyISAM，这个引擎不支持事务，Innodb才支持 事务传播行为设置错误。PROPAGATION_SUPPORTS，PROPAGATION_NOT_SUPPORTED，PROPAGATION_NEVER 会导致方法运行在非事务状态下，从而导致事务失效 类未被Spring管理，例如未注册为Bean(没添加相应注解 @Controller,@Service,@Component,@Bean)  ","date":"2023-05-25T20:21:46+08:00","permalink":"https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/","title":"Java开发知识点简单总结-Spring"},{"content":"Java基础 面向对象的特点 封装，继承，多态\n包装类型的缓存机制 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False\n接口和抽象类有什么共同点和区别 共同点 ：\n 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。  区别 ：\n 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。  深拷贝和浅拷贝区别？什么是引用拷贝？  引用拷贝就是两个不同的引用指向同一个对象。如 Object a = new Object(); Object b = a; 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。  字符串 String s1 = new String(\u0026ldquo;abc\u0026rdquo;);这句话创建了几个字符串对象？\n会创建 1 或 2 个字符串对象。\n如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象(new String()和\u0026quot;abc\u0026quot;)。否则创建一个字符串对象(new String())\n集合 Arraylist/Linkedlist的区别\nArrayList：\n 基于数组。 随机访问速度优于 LinkedList，可以根据下标以 O(1) 时间复杂度对元素进行随机访问。 插入与删除元素的速度劣于 LinkedList，原因是在进行插入与删除操作时，会涉及到底层数组的数据搬移操作。 需要连续的内存块存储数据。  LinkedList：\n 基于双向链表。 随机访问速度劣于 ArrayList，因为当要访问链表中的某个元素时，只能从头部往后遍历查找。 插入与删除元素的速度优于 ArrayList，只需要更改前后节点的指针指向即可。 需要更多的内存空间来存储的每个节点的前驱节点和后继节点的指针  Hashmap原理\n 链表散列组成 初始容量默认16 负载因子默认0.75 每次扩容为2倍，容量总是2的整数次幂 链表大小\u0026gt;8，数组大小\u0026gt;=64时，链表会转换为红黑树  Java多线程 线程 线程与进程\n 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反  并发与并行\n 并发：两个及两个以上的作业在同一 时间段 内执行。 并行：两个及两个以上的作业在同一 时刻 执行。  同步与异步\n 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。 异步：调用在发出之后，不用等待返回结果，该调用直接返回。  线程安全和不安全\n 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失  线程的生命周期和状态\n NEW: 初始状态，线程被创建出来但没有被调用 start() 。 RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。 BLOCKED：阻塞状态，需要等待锁释放。 WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。 TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。 TERMINATED：终止状态，表示该线程已经运行完毕。  sleep()和wait()\n sleep() 方法没有释放锁，而 wait() 方法释放了锁 。 wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。 sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。  sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁，所以定义在Thread中 wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。是要释放当前线程占有的对象锁并让其进入 WAITING 状态，所以是Object类的本地方法    乐观锁与悲观锁 悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\n高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行\n乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用 CAS 实现的。\n高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升\n使用场景\n 悲观锁通常用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。 乐观锁通常用于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）  乐观锁实现机制 版本号机制：线程A更新数据时先读取version字段，version字段与之前读取的一致则更新，不一致则说明期间有其他线程更新了数据\nCAS机制：Compare And Swap。用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。(CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。原子操作:即最小不可拆分的操作)\n当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新\n V：要更新的变量值(Var) E：预期值(Expected) N：拟写入的新值(New)  乐观锁的ABA问题 如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，并不能说明它的值没有被其他线程修改过了，因为在这段时间它的值可能被改为B，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。即 \u0026ldquo;ABA\u0026quot;问题。\n解决思路是在变量前面追加上版本号或者时间戳\n乐观锁的其他问题 循环时间长开销大\nCAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\n如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\n可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\n可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率\n只能保证一个共享变量的原子操作\nCAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作\nJava中加锁的方式 synchronized关键字与Lock接口\nsynchronized用法\n 修饰实例方法 修饰静态方法 修饰代码块  synchronized锁的升级：偏向锁 → 轻量级锁 → 重量级锁\n首次执行到synchronized代码块，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。\n一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）\n这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。\n在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。\n长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等\n显然，忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。\n公平锁与非公平锁\n 公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁  读写锁、共享锁、互斥锁 读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排他锁）\n如果加锁只是为了读取数据，那么加锁时明确地加一个读锁，其他线程如果也要加读锁，不需要等待，可以直接获取\n如果我读取值是为了更新它，那么加锁的时候就直接加写锁，我持有写锁的时候别的线程无论读还是写都需要等待\n可重入锁 可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\nJDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的\n线程池 阿里的开发手册中提到禁止使用Executors创建线程池，建议使用ThreadPoolExecutor创建\nFixedThreadPool和SingleThreadPool允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM\nCachedThreadPool和ScheduledThreadPool允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM\npublic ThreadPoolExecutor( int corePoolSize, // 核心线程数，核心线程不会被回收，除非设置allowCoreThreadTimeOut(true)  int maximumPoolSize,// 最大线程数，闲置时会被回收  long keepAliveTime, // 线程闲置时间  TimeUnit unit, // 闲置时间的单位 时分秒  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, // 任务队列，核心线程满后进入队列，队列满后创建线程  ThreadFactory threadFactory, // 线程工厂，用于创建线程执行任务  RejectedExecutionHandler handler // 拒绝策略，当线程池处于饱和时，使用某种策略来拒绝任务提交 ) 核心线程未满则使用核心线程执行，核心线程满则进入任务队列排队，任务队列也满则创建非核心线程执行任务，线程与队列双满则执行拒绝策略。\nThreadPoolExecutor的拒绝策略4种，AbortPolicy，默认策略，抛出异常；DiscardPolicy静默丢弃任务；DiscardOldestPolicy丢弃队列中最老的任务，提交当前任务；CallerRunsPolicy让提交任务的线程来执行任务\nIO密集型应设置较多的线程数(2n)(n=cpu核心数)，CPU密集型任务应设置较少的线程数(n+1)\n","date":"2023-05-25T15:21:46+08:00","permalink":"https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/","title":"Java开发知识点简单总结"},{"content":"实现原理  HashMap的实现原理 \nHashMap 是由数组与链表组成的，又叫链表散列。\nHashMap 初始容量默认为16，如果在创建 HashMap 手动指定容量，则会自动将容量调整到大于指定容量且最接近指定容量2的整数次幂大小。\n当调用 put() 方法储存 K/V键值对 时，会首先计算 K 的 hash 值，然后根据数组长度，计算得出对应的数组下标，如果 K 的 hash 值已经存在，且它们两者的 equals 返回 true，则更新键值对的值，如果返回 fasle，则说明发生 hash碰撞，jdk1.7之前会将新的键值对插入到链表头部，jdk1.8之后则是插入到链表尾部。\n当数组中的元素个数大于 容量*负载因子(默认为0.75) 时，数组会进行扩容，扩容后大小变为2倍。\n如果由于碰撞导致链表大小超过8，并且数组大小大于等于64时，则会将其转换为红黑树以提高查询效率，如果由于删除元素导致红黑树节点数量少于6时，则会转换为链表。\nHashMap的容量为什么是2的整数次幂 在 HashMap 中，存储桶（buckets）的数量等于数组的长度。通过哈希函数将键映射到对应的存储桶，然后在存储桶中查找或存储对应的值。使用 2 的幂次方作为数组的长度，可以通过位运算代替取模运算，提高计算效率。\n此外，使用 2 的幂次方作为数组长度还能够更好地分散哈希码的分布，减少哈希冲突的概率。如果数组长度不是 2 的幂次方，那么在计算哈希码与数组长度取模时，低位可能不会被充分利用，可能导致一些位的哈希码无法影响到存储桶的选择，从而增加哈希冲突的可能性。\n因此，为了提高散列算法的效率和减少哈希冲突，HashMap 选择将长度设置为 2 的幂次方。这样可以通过位运算代替取模运算，提高计算效率，并且更好地分散哈希码的分布，减少哈希冲突的概率。\nHashMap的负载因子为什么默认是0.75 负载因子是 HashMap 中用于衡量存储桶利用率的一个参数。在 HashMap 中，负载因子表示存储桶中键值对的平均数量与存储桶数组长度的比值。\n较低的负载因子意味着存储桶中的键值对数量相对较少，可以更好地分散键的hash，减少多个键映射到同一个存储桶的情况，从而减少哈希冲突的概率。\n较高的负载因子意味着更高存储桶利用率。可以用更少的存储桶储存更多的键值对，节省了更多的空间。\n使用0.75作为默认负载因子是为了在减少hash碰撞与提高存储桶利用率之间达到一种平衡。\nHash的计算方法 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 链表何时转为红黑树 putVal() 方法中链表转红黑树的判断逻辑\nfor (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 如果链表元素个数大于等于TREEIFY_THRESHOLD (8)  if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  // 执行treeifyBin() 方法  treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } treeifyBin()方法中判断是否实际转化为红黑树的逻辑\nfinal void treeifyBin(Node\u0026lt;K,V\u0026gt;[] tab, int hash) { int n, index; Node\u0026lt;K,V\u0026gt; e; // 如果当前数组长度小于64, 则优先进行数组扩容  if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { // 数组长度大于64, 才会转化为红黑树  TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } ","date":"2023-05-24T00:16:32+08:00","permalink":"https://chaosalphard.github.io/p/java%E4%B8%ADhashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","title":"Java中HashMap的实现原理"},{"content":"ArrayList的底层实现 ArrayList 底层是基于数组来实现的，而数组是使用一组连续的空间来存储数据类型相同的数据，并且数组的空间大小是固定的。\n因为数组的空间大小固定，存储的数据类型也相同，所以我们就可以通过寻址公式类随机访问数组中的任意一个下标的元素。\naddress[i] = baseAddress + i * dataTypeSize 因为 ArrayList 基于数组实现，而数组的空间大小是固定的，所以当数组的空间用完了，就需要对 ArrayList 底层的数组进行扩容。\n当使用 ArrayList 默认的构造函数创建对象时，底层的数组实际是被赋值为一个空数组，但我们第一次调用往其中添加元素时，才会触发具体扩容逻辑，第一次扩容默认的初始化容量为10，使用了延迟加载的实现方式避免空间浪费。\nArrayList的扩容逻辑    \n在调用 add() 方法时，会判断 ArrayList 中 elementData 这个数组的容量是否等于 ArrayList 的大小，也就是判断 elementData 数组是不是满的，如果等于则说明当前数组空间满了，则调用 grow() 方法进行扩容，之后再添加元素到到数组中。\n \n在看看 grow() 方法中又调用了一个带参方法 grow(int minCapacity) 参数是当前大小+1，那么我们来看下这个带参数的 grow 方法。\nprivate Object[] grow(int minCapacity) { // 记录容量大小  int oldCapacity = elementData.length; // 判断容量大于0，并且数组不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA  // DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个数组是使用ArrayList的无参构造函数时赋值给elementData的  // 也就是说这个if语句不会处理使用默认的无参构造函数创建的数组  if (oldCapacity \u0026gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 使用ArraysSupport.newLengt 计算新数组的大小  // 这里的位运算 oldCapacity\u0026gt;\u0026gt;1 等于 oldCapacity*0.5  int newCapacity = ArraysSupport.newLength( oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity \u0026gt;\u0026gt; 1 /* preferred growth */ ); // 使用Arrays.copyOf 创建一个新的数组, 大小则为newCapacity的值  return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; } } 总结一下 ArrayList 的扩容规律\n ArrayList 在底层数组容量满了的情况下才会进行扩容，并且通常情况下会扩容为1.5倍。 进行扩容最少会使 ArrayList 底层数组的容量增加1。 使用无参构造函数时，创建的 ArrayList 容量为0，首次扩容时容量变为 DEFAULT_CAPACITY，也就是10，此后再进行扩容时则正常扩容。 使用带容量参数的构造函数且容量参数为0时，首次扩容时容量变为1，此后再进行扩容时则正常扩容。  LinkedList的底层实现 LinkedList 底层是基于双向链表实现，其中使用了 head 和 tail 指针分别指向链表头部和尾部的节点，当添加元素时，只需要通过 tail 指针往尾节点后面添加元素即可。\n数组需要申请连续的内存块，而链表的实现不需要连续的内存块，链表中通过指针将链表中多个节点连接起来，链表中的每个节点除了存储自身的数据外，还需要申请额外的存储空间存储指向当前节点的前驱节点的指针和指向后继节点的指针。\n当我们向链表中添加元素时，只需要将新的数据节点添加到链表尾部即可。因为链表不需要保证内存空间的连续性，所以添加过程中不涉及具体的数据搬移操作。\nArrayList与LinkedList对比 ArrayList：\n 基于数组。 随机访问速度优于 LinkedList，可以根据下标以 O(1) 时间复杂度对元素进行随机访问。 插入与删除元素的速度劣于 LinkedList，原因是在进行插入与删除操作时，会涉及到底层数组的数据搬移操作。 需要连续的内存块存储数据。  LinkedList：\n 基于双向链表。 随机访问速度劣于 ArrayList，因为当要访问链表中的某个元素时，只能从头部往后遍历查找。 插入与删除元素的速度优于 ArrayList，只需要更改前后节点的指针指向即可。 需要更多的内存空间来存储的每个节点的前驱节点和后继节点的指针  ","date":"2023-05-22T13:58:14+08:00","permalink":"https://chaosalphard.github.io/p/java%E4%B8%ADarraylist%E4%B8%8Elinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"Java中ArrayList与LinkedList的区别"},{"content":"单例模式  单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n 实现 懒汉式  需要时加载 线程不安全  public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式  启动时加载  public class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 双检锁 即 Double-Checked Locking\n 需要时加载 线程安全 多线程下保持较高性能  public class Singleton { private volatile static Singleton singleton; private Singleton() {} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 枚举  启动时加载 线程安全 防止反序列化重新创建对象  public enum Singleton { INSTANCE; public void method() { // ...  } } ","date":"2021-09-21T22:03:11+08:00","permalink":"https://chaosalphard.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"单例模式"},{"content":"添加合成表 在resources/data/\u0026lt;你的Mod注册的命名空间\u0026gt;/recipes 文件夹下，创建一个json 文件，名称没有要求，但最好以被添加合成表的物品的名称为前缀。\n添加无序合成表 以mod_icon 为例\nmod_icon.json\n{ // 指定该合成表为无序合成  \u0026#34;type\u0026#34;: \u0026#34;minecraft:crafting_shapeless\u0026#34;, // 指定合成需要的原料, 物品名字格式为 \u0026lt;命名空间\u0026gt;:\u0026lt;物品名称\u0026gt;  \u0026#34;ingredients\u0026#34;: [{ \u0026#34;item\u0026#34;: \u0026#34;minecraft:melon_slice\u0026#34; }, { \u0026#34;item\u0026#34;: \u0026#34;minecraft:carrot\u0026#34; }, { \u0026#34;item\u0026#34;: \u0026#34;minecraft:sweet_berries\u0026#34; }, { \u0026#34;item\u0026#34;: \u0026#34;minecraft:pumpkin_pie\u0026#34; }, { \u0026#34;item\u0026#34;: \u0026#34;minecraft:honey_bottle\u0026#34; }, { \u0026#34;item\u0026#34;: \u0026#34;minecraft:milk_bucket\u0026#34; }], // 指定合成结果  \u0026#34;result\u0026#34;: { \u0026#34;item\u0026#34;: \u0026#34;irs_widget_pack:mod_icon\u0026#34;, \u0026#34;count\u0026#34;: 4 } } 给mod_icon 添加第二个合成表\nmod_icon_from_mod_icon_block.json\n{ \u0026#34;type\u0026#34;: \u0026#34;minecraft:crafting_shapeless\u0026#34;, \u0026#34;ingredients\u0026#34;: [{ \u0026#34;item\u0026#34;: \u0026#34;irs_widget_pack:mod_icon_block\u0026#34; }], \u0026#34;result\u0026#34;: { \u0026#34;item\u0026#34;: \u0026#34;irs_widget_pack:mod_icon\u0026#34;, \u0026#34;count\u0026#34;: 8 } } 添加有序合成表 以mod_icon_block 为例\nmod_icon_block.json\n{ // 指定该合成表为有序合成  \u0026#34;type\u0026#34;: \u0026#34;minecraft:crafting_shaped\u0026#34;, // 指定合成配方, 其中\u0026#34;I\u0026#34; 可以是\u0026#39;A-Z\u0026#39;或\u0026#39;#\u0026#39;之中的任意一个值  \u0026#34;pattern\u0026#34;: [ \u0026#34;III\u0026#34;, \u0026#34;I I\u0026#34;, \u0026#34;III\u0026#34; ], // 解释合成表中的字符代表哪种物品  \u0026#34;key\u0026#34;: { \u0026#34;I\u0026#34;: { \u0026#34;item\u0026#34;: \u0026#34;irs_widget_pack:mod_icon\u0026#34; } }, \u0026#34;result\u0026#34;: { \u0026#34;item\u0026#34;: \u0026#34;irs_widget_pack:mod_icon_block\u0026#34;, \u0026#34;count\u0026#34;: 1 } }  recipes \n添加掉落物 在resources/data/\u0026lt;你的Mod注册的命名空间\u0026gt;/loot_tables/blocks 文件夹下，创建一个与被添加掉落表的物品的名称相同的json 文件。\n如果是实体，则应放在loot_tables/entities文件夹下\nmod_icon_block.json\n{ // 指定类型为方块  \u0026#34;type\u0026#34;: \u0026#34;minecraft:block\u0026#34;, // 指定掉落物随机池  \u0026#34;pools\u0026#34;: [ { // 指定随机次数  \u0026#34;rolls\u0026#34;: 1, // 指定掉落实体  \u0026#34;entries\u0026#34;: [ { // 掉落物类型  \u0026#34;type\u0026#34;: \u0026#34;minecraft:item\u0026#34;, // 掉落物名称  \u0026#34;name\u0026#34;: \u0026#34;irs_widget_pack:mod_icon\u0026#34;, // 决定掉落物掉落的函数  \u0026#34;functions\u0026#34;: [{ \u0026#34;function\u0026#34;: \u0026#34;minecraft:set_count\u0026#34;, \u0026#34;count\u0026#34;: { \u0026#34;min\u0026#34;: 8, \u0026#34;max\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;minecraft:uniform\u0026#34; } }] } ], // 额外的掉落条件  \u0026#34;conditions\u0026#34;: [ { \u0026#34;condition\u0026#34;: \u0026#34;minecraft:survives_explosion\u0026#34; } ] } ] }  loot \n","date":"2021-06-06T02:44:16+08:00","image":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C04-%E5%90%88%E6%88%90%E8%A1%A8%E4%B8%8E%E6%8E%89%E8%90%BD%E7%89%A9/title_hu4107f2aa22c9a9d7333443426ba889b2_51911_120x120_fill_box_smart1_2.png","permalink":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C04-%E5%90%88%E6%88%90%E8%A1%A8%E4%B8%8E%E6%8E%89%E8%90%BD%E7%89%A9/","title":"Minecraft Mod 开发手册04: 合成表与掉落物"},{"content":"新建方块 class ModIconBlock: Block(settings) { companion object { // 使用木板的方块预设  val settings: Settings = Settings.of(Material.WOOD) // 方块硬度  .strength(2.0F) // 方块声音  .sounds(BlockSoundGroup.WOOD); // 方块实例  val INSTANCE = ModIconBlock(); // 方块的物品形式实例  val ITEM_INSTANCE = BlockItem(instance, Item.Settings().rarity(Rarity.RARE).group(ModItemGroup.ITEM)); val identifier = Identifier(\u0026#34;irs_widget_pack\u0026#34;, \u0026#34;mod_icon_block\u0026#34;) } } 注册方块 @Suppress(\u0026#34;unused\u0026#34;) fun init() { // 创建方块标识，方块注册完成后还需要注册物品形式的物品标识  Registry.register(Registry.BLOCK, ModIconBlock.identifier, ModIconBlock.INSTANCE) Registry.register(Registry.ITEM, ModIconBlock.identifier, ModIconBlock.ITEM_INSTANCE) } 给方块添加材质 添加材质文件 在resources/assets/\u0026lt;你的Mod注册的命名空间\u0026gt;/textures/block 文件夹下，创建一个与你添加物品同名的png 文件。\n配置方块状态 在resources/assets/\u0026lt;你的Mod注册的命名空间\u0026gt;/blockstates 文件夹下，创建一个与你添加物品同名的json 文件。\n方块状态文件根据其方块状态确定该方块应使用的模型。由于现在方块还没有所谓状态，所以用空字符串表示所有\n{ \u0026#34;variants\u0026#34;: { \u0026#34;\u0026#34;: { \u0026#34;model\u0026#34;: \u0026#34;irs_widget_pack:block/mod_icon_block\u0026#34; } } } 配置方块模型 在resources/assets/\u0026lt;你的Mod注册的命名空间\u0026gt;/models/block 文件夹下，创建一个与你添加物品同名的json 文件。\n方块模型文件定义了方块的形状和材质。使用block/cube_all作为父模型，这将在方块的所有面上设置相同的材质。\n{ \u0026#34;parent\u0026#34;: \u0026#34;block/cube_all\u0026#34;, \u0026#34;textures\u0026#34;: { \u0026#34;all\u0026#34;: \u0026#34;irs_widget_pack:block/mod_icon_block\u0026#34; } } 配置方块物品模型 在resources/assets/\u0026lt;你的Mod注册的命名空间\u0026gt;/models/item 文件夹下，创建一个与你添加物品同名的json 文件。\n在大多数情况下，方块作为物品时外观还是这个方块。所以，直接继承方块模型即可\n{ \u0026#34;parent\u0026#34;: \u0026#34;irs_widget_pack:block/mod_icon_block\u0026#34; } 最后，进入游戏即可看到效果  结果 \n","date":"2021-06-05T22:42:08+08:00","image":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C03-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%B9%E5%9D%97/title_hu1a1c9e811a323c1a2d4eb73d71b2b512_115241_120x120_fill_box_smart1_2.png","permalink":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C03-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%B9%E5%9D%97/","title":"Minecraft Mod 开发手册03: 第一个方块"},{"content":"注册物品栏分组 新建一个类，用于存放自定义的物品栏分组的实例\nclass ModItemGroup { companion object { @JvmStatic val ITEM: ItemGroup = FabricItemGroupBuilder .build(Identifier(\u0026#34;irs_widget_pack\u0026#34;,\u0026#34;item\u0026#34;)) { ItemStack(ModIcon.instance) } } } FabricItemGroupBuilder.build方法接收两个参数，第一个是物品栏分组的名称，第二个是显示的图标\n将物品放入自定义物品栏中 修改之前定义好的物品\n@JvmStatic val settings: Settings = Settings() // 物品分组修改为我们自定义的分组  .group(ModItemGroup.ITEM) 添加翻译 修改之前的语言文件，按照对应的格式，为新增的物品分组添加翻译\n{ \u0026#34;itemGroup.irs_widget_pack.item\u0026#34;: \u0026#34;物品\u0026#34; } 进入游戏，即可看到效果  成果 \n","date":"2021-05-23T23:01:27+08:00","image":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C02-%E6%96%B0%E5%BB%BA%E7%89%A9%E5%93%81%E6%A0%8F%E5%88%86%E7%BB%84/title_hub22ad0e3342eb94d5fd76f0e2eecacc6_94512_120x120_fill_box_smart1_2.png","permalink":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C02-%E6%96%B0%E5%BB%BA%E7%89%A9%E5%93%81%E6%A0%8F%E5%88%86%E7%BB%84/","title":"Minecraft Mod 开发手册02: 新建物品栏分组"},{"content":"近期我部署在Gitee上的博客已经不能用了, 虽然还能上传, 但是已经不会把上传的文章更新出来了, 故迁移到Github上, 顺便Hexo文章生成速度不太理想, 趁着这次部署站点迁移一并切换到Hugo.\n搭建Hugo写作环境 Hugo下载 首先从Hugo官网下载适合自己电脑环境的Hugo版本。\n下载地址：https://github.com/gohugoio/hugo/releases\n将解压出来的Hugo.exe 添加到环境变量中。\n创建Github Pages 仓库 进入Github网站，点击New Repositories 按钮，新建一个仓库，名称我这里选blog，访问类型选择Public  创建仓库 \n创建完成后点击Settings选项，选择Pages，Branch选择master，目录选择/docs，之后点击save按钮，即可看到上方蓝色提示：Your site is ready to be published at https://chaosalphard.github.io/blog，这个地址便是Github给你分配的博客地址，如果你有自己的域名的话可以在这里绑定。  部署网页 \n初始化Hugo站点 将刚才创建的Git 仓库Clone 到本地，打开命令行，切换到刚才Clone 下来的仓库的文件夹里面，此时文件夹里面应该除了一个名为.git的隐藏文件夹之外没有其他文件了，执行hugo new site . --force 来初始化hugo站点。\n之后选择一款自己喜欢的主题，地址：https://themes.gohugo.io，下载或者Clone 到本地，将文件夹放到hugo站点的根目录下。\n编辑config.toml/config.yaml/config.json 配置文件，修改baseurl 为Github 分配的博客地址，修改theme 为你的主题文件夹名称。\n创建文章 切换到hugo站点目录，执行hugo new post/article.md 来新建一篇名为article 的文章，文件位于/content/post 目录下，打开文件进行编辑，因为我之前用Hexo的时候已经有一些文章了，所以我直接复制过来，Hexo和Hugo都支持markdown语法编写的文章，所以可以直接切换。\n部署到GitHubPages 本地调试 切换到hugo站点目录，执行hugo server -D，此时会输出以下信息\n~/Hugo/blog\u0026gt; hugo server -D Start building sites … | ZH-CN -------------------+-------- Pages | 182 Paginator pages | 20 Non-page files | 4 Static files | 0 Processed images | 13 Aliases | 61 Sitemaps | 1 Cleaned | 0 Built in 3795 ms Watching for changes in ~/Hugo/blog/{archetypes,assets,content,data,layouts,static,themes} Watching for config changes in ~/Hugo/blog/config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/blog/ (bind address 127.0.0.1) Press Ctrl+C to stop 根据提示打开网址 (我这里是http://localhost:1313/blog/) 即可看到文章，确认无误后即可部署到GithubPages上。\n生成文件并部署到GithubPages上 切换到hugo站点目录下，执行hugo -d docs，即可在/docs 目录下生成部署文件，之后将所有改动从本地提交到远程Git仓库上 (或者仅提交/docs目录下文件也可以)。\n配置GithubAction完成云端构建 创建Action配置文件 在hugo站点目录下新建.github/workflows 目录，在此目录下新建gh-pages.yaml 文件并写入以下内容。\n# Action名称name:Deploy Github Pageson:push:branches:# 在master分支被push时触发- masterjobs:deploy:runs-on:ubuntu-20.04# 设置执行环境environment:name:github-pages# 步骤steps:# 检出- name:Checkout Repouses:actions/checkout@v2with:submodules:truefetch-depth:0# 初始化Hugo- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.83.1\u0026#39;extended:true# 生成部署文件- name:Buildrun:hugo --gc --minify --cleanDestinationDir# 部署到GithubPages- name:Deployuses:peaceiris/actions-gh-pages@v3with:# ACTIONS_DEPLOY_KEY需要在仓库里进行配置deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}force_orphan:true# 设置使用gh-pages分支来存放部署文件, 一般master分支存放原始文件, gh-pages分支存放部署文件publish_branch:gh-pages# hugo生成的部署文件默认放在public目录中, 这里是指定推送public目录中的文件到gh-pages分支中publish_dir:./public# 排除文件不推送到gh-pages分支中exclude_assets:\u0026#39;.github\u0026#39;user_name:\u0026#39;github-actions[bot]\u0026#39;user_email:\u0026#39;github-actions[bot]@chaosalphard.noreply.github.com\u0026#39;commit_message:${{ github.event.head_commit.message }}其他更多设置请查看actions-hugo和actions-gh-pages插件说明\n生成部署密钥 执行ssh-keygen -t rsa -b 4096 -C \u0026quot;$(git config user.email)\u0026quot; -f gh-pages -N \u0026quot;\u0026quot; 指令生成一对公钥(gh-pages.pub)和私钥(gh-pages)\n进入Github Pages仓库，点击Settings 选项，选择Deploy keys，新建一个Deploy key，将刚才生成的公钥文件的内容复制进来，勾选Allow write access 选项，然后保存。\n点击Environments 选项，新建一个Environments 名称填github-pages (需要与gh-pages.yaml 文件中设置的environment name 一致)，之后在github-pages 下新建一个secret，名称填ACTIONS_DEPLOY_KEY (需要与gh-pages.yaml 文件中设置的deploy_key 对应)，将刚才生成的私钥文件的内容复制过来，然后保存。\n测试Action部署 回到Hugo站点目录，将/docs目录删除，因为我们现在不需要在本地生成部署文件了，之后提交到Github Pages仓库，然后去Github Pages仓库的Action 选项，查看任务是否执行成功。  Action \n如果没有成功，回到Settings 选项下的Pages 页面，将Branch 更改为gh-pages，目录选择/，保存，然后回到Action 页面，点击Re-run jobs，稍等一会即可看到结果。\n","date":"2021-05-22T19:38:27+08:00","image":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/title_hu7bcc9bfd4f48257461c0c8d2a5814da7_912581_120x120_fill_q75_box_smart1.jpg","permalink":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"使用Hugo搭建个人博客"},{"content":"向Minecraft中添加物品 定位入口 找到fabric.mod.json 文件中entrypoints.main 键所对应的类\n{ // ...  \u0026#34;entrypoints\u0026#34;: { \u0026#34;main\u0026#34;: [ \u0026#34;com.ilirus.widget.pack.WidgetPackKt::init\u0026#34; ] }, // ... } 我这里的值是com.ilirus.widget.pack.WidgetPackKt::init，说明com.ilirus.widget.pack 包下WidgetPack.kt 类中的init 方法是Mod的入口\nWidgetPack.kt\n@Suppress(\u0026#34;unused\u0026#34;) fun init() { println(\u0026#34;Hello Minecraft!\u0026#34;) } 可以看到init 方法里面什么都没有，不过这个类之后会用到，所以先记下来\n新建物品 新建一个class，继承net.minecraft.item.Item 类，Item类的构造器接收一个参数类型为Settings 类的参数，这个Settings 类是Item 的内部类。\nSettings 类可以对Item 的属性进行配置。\nclass ModIcon(settings: Settings) : Item(settings) { companion object { val settings: Settings = Settings() // 物品分组, 配置物品出现在创造模式物品栏的哪一个选项卡中  .group(ItemGroup.MISC) // 此物品作为合成材料参与合成后返回的物品,  // 比如牛奶桶参与合成后会返回铁桶  // .recipeRemainder(Items.HONEYCOMB)  // 稀有度 (物品名的颜色)  .rarity(Rarity.UNCOMMON) // 食物属性, 设置后该物品即可食用, 属性依照传入的参数  // .food(FoodComponent)  // 设置物品防火，扔到火焰和岩浆里不会被烧掉(仙人掌依然能破环该物品)  .fireproof() // 设置最大堆叠数量，默认64  .maxCount(64) // 设置物品耐久度，默认0，不为0时则该物品不可堆叠  // 调用该方法会将最大堆叠数设为1  .maxDamage(1024) // 保存实例  @JvmStatic val INSTANCE = ModIcon(settings) } // 添加工具提示  override fun appendTooltip(stack: ItemStack?, world: World?, tooltip: MutableList\u0026lt;Text\u0026gt;?, context: TooltipContext?) { // 参数格式一般为\u0026#34;物品类型.命名空间.物品名称.tooltip+序号\u0026#34;  tooltip?.add(TranslatableText(\u0026#34;item.irs_widget_pack.mod_icon.tooltip_1\u0026#34;)) tooltip?.add(TranslatableText(\u0026#34;item.irs_widget_pack.mod_icon.tooltip_2\u0026#34;)) } } 注册物品 配置完成物品后，还需要进行物品的注册。\n@Suppress(\u0026#34;unused\u0026#34;) fun init() { // 创建物品标识，第一个参数为物品的注册的命名空间，原版物品的命名空间为\u0026#34;minecraft\u0026#34;，  // 第二个参数为物品的注册名称  val identifier: Identifier = Identifier(\u0026#34;irs_widget_pack\u0026#34;, \u0026#34;mod_icon\u0026#34;) // 注册物品，第一个参数为物品类型，第二个参数为物品标识，第三个参数为物品类实例  Registry.register(Registry.ITEM, identifier, ModIcon.INSTANCE) } 之后运行runClient 启动Minecraft，在创造模式的杂项选项卡中，即可看到我们添加的物品  00 \n可以看到，虽然物品添加成功了，但是没有材质和名称，接下来我们就为其添加名称和材质。\n添加材质 在resources/assets/\u0026lt;你的Mod注册的命名空间\u0026gt;/textures/item 文件夹下，创建一个与你添加物品同名的png 文件。\n已我添加的物品为例，我在Identifier中注册的命名空间是irs_widget_pack ，物品名称是mod_icon 所以我需要在resources/assets/irs_widget_pack/textures/item 文件夹下新建mod_icon.png 文件，这个png文件就是物品的材质了。\n但是还没完，我们仅仅是新建了材质文件，接下了还要告诉Minecraft如何渲染材质。\n在resources/assets/\u0026lt;你的Mod注册的命名空间\u0026gt;/models/item 文件夹下，创建一个与你添加物品同名的json 文件。\n同样以我添加的物品为例，路径为resources/assets/irs_widget_pack/models/item，文件名为mod_icon.json。\n{ // 标明类型为物品  \u0026#34;parent\u0026#34;: \u0026#34;item/generated\u0026#34;, \u0026#34;textures\u0026#34;: { // 标明材质文件为irs_widget_pack命名空间中, item种类里, 名称为mod_icon的文件  \u0026#34;layer0\u0026#34;: \u0026#34;irs_widget_pack:item/mod_icon\u0026#34; } } 添加名称 之前提到我们添加的物品没有名称，其实并不是，物品名称在我们用Registry.register() 方法注册物品时就已经有了，其格式为\u0026quot;物品类型.命名空间.物品名称\u0026quot;，我们现在要做的就是添加翻译文件，将游戏内部使用的物品名称翻译为用户所需要的名称。\n在resources/assets/irs_widget_pack/lang 文件夹下新增对应语言的翻译文件，Minecraft会根据你在游戏中设置的语言选项，自动寻找对应的语言文件，如果使用简体中文，则新建zh_cn.json 文件。\nMinecraft在找不到对应语言的翻译文件时，会默认使用en_us.json 文件，所以你除了新建zh_cn.json 文件以外，还要新建en_us.json 文件。\n或者你可以选择不新建zh_cn.json 文件，直接创建使用en_us.json 文件。\n在你创建的文件中写入以下内容\n{ // 物品名称  \u0026#34;item.irs_widget_pack.mod_icon\u0026#34;: \u0026#34;模组icon\u0026#34;, // 物品的工具提示  \u0026#34;item.irs_widget_pack.mod_icon.tooltip_1\u0026#34;: \u0026#34;模组的图标\u0026#34;, \u0026#34;item.irs_widget_pack.mod_icon.tooltip_2\u0026#34;: \u0026#34;并没有什么用\u0026#34; } 再重新启动游戏，可以看到效果  01 \n","date":"2021-05-21T21:13:06Z","image":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C01-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%A9%E5%93%81/01_hu87864515f4c180aaf629b563b495a45a_113368_120x120_fill_box_smart1_2.png","permalink":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C01-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%A9%E5%93%81/","title":"Minecraft Mod 开发手册01: 第一个物品"},{"content":"Fabric开发环境搭建 Minecraft目前有Forge和Fabric两大Mod平台，这里我选择使用较新的Fabric平台。\n开发工具  jdk8以上 任意IDE  创建项目  下载Fabric官方的项目初始模板，Kotlin开发人员可以下载Kotlin版 修改gradle.properties 文件  修改maven_group 为你的组织名(类似于Maven中的GroupId) 修改archives_base_name 为你的模组名(类似于Maven中的ArtifactId) 修改minecraft_version 为你的模组的目标版本(你要为哪个Minecraft版本开发Mod) 修改yarn_mappings、loader_version 与fabric_version 为minecraft_version 对应的版本，版本对应关系可在这里查看   修改src目录下的目录名称，对应到你的maven_group与archives_base_name 修改src/resources/fabric.mod.json  id 为你的模组的命名空间 entrypoints.main 为你的模组的入口(main方法所在类) mixins 为mixins.json 所在位置   修改\u0026lt;modid\u0026gt;.mixins.json(modid为你的模组的命名空间, fabric.mod.json中id对应的值)  package 为mixin所在的包名 client 为mixin的类名   最后，将修改好的项目导入到你的IDE中  修改Gradle构建编译器(可选) 如果你使用的是IntelliJ IDEA, 它默认使用Gradle来构建你的项目，而这在Fabric中是不必要的，通过以下步骤来使你的IntelliJ IDEA使用自己的编译器\n 在Build Tools -\u0026gt; Gradle 设置项中，修改Build and run using 以及Run tests using 选项为IntelliJ IDEA 在Project Structure -\u0026gt; Project 设置项中，修改Project compiler output 为$PROJECT_DIR$/out  启动Minecraft 在Gradle任务中执行runClient 即可启动Minecraft客户端\nFabric官方Wiki  https://fabricmc.net/wiki/tutorial:introduction\n ","date":"2021-05-20T00:02:00Z","image":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C00-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/title_hu32133c8107f0bd8c594426c7431e7a01_287714_120x120_fill_q75_box_smart1.jpg","permalink":"https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C00-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"Minecraft Mod 开发手册00: 开发环境搭建"},{"content":"在给前端提供Api接口时，通常会约定好一个统一返回格式，这样方便前端处理返回结果\n@RestController @RequestMapping(\u0026#34;/index\u0026#34;) public class IndexController { @GetMapping public R\u0026lt;Data\u0026gt; index() { return R.ofSuccess(new Data()); } } 但每次都要用统一返回类手动封装一次再返回还是比较麻烦的，可以使用@ControllerAdvice 注解来进行统一封装，避免每次手动封装\n定义ControllerAdvice\n// 这里的annotations = ApiResult.class 代表只有在类上有@ApiResult 注解的Controller 才会被处理 // 如果不写则默认对所有Controller 进行处理 @RestControllerAdvice(annotations = ApiResult.class) public class ResponseAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { @Override public boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType) { // 判断返回类型是否已经是定义好的统一返回类型, 以及@ApiResult 注解是否启用  // 返回true 则表示进入下一步处理, 返回false 则表示不做处理, 原样返回  return !returnType.getParameterType().isAssignableFrom(R.class)\u0026amp;\u0026amp; !returnType.hasMethodAnnotation(ApiResult.Disable.class); } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { return R.ofSuccess(body); } } 定义注解\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface ApiResult { @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Disable {} } 使用\n@RestController @RequestMapping(\u0026#34;/index\u0026#34;) @ApiResult public class IndexController { @GetMapping public Data index() { return new Data(); } @GetMapping(\u0026#34;/string\u0026#34;) // 不做处理直接返回  @ApiResult.Disable public String returnStr() { return \u0026#34;success\u0026#34;; } } 顺嘴提一句, 使用组合注解也是可以的\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @ApiResult @WithExceptionHandler public @interface ApiResultWithExceptionHandler { } @RestController @RequestMapping(\u0026#34;/index\u0026#34;) @ApiResultWithExceptionHandler public class IndexController { @GetMapping public Data index() { return new Data(); } }  01 \n等会，还没完，转换其他类型的时候都是正常的，但是如果遇到String类型，就会报错 R cannot be cast to class String\n这是因为在Controller 返回String 类型时，Spring 会优先使用StringHttpMessageConverter来进行转换处理，而我们又在统一处理器里面把类型更换为了自定义的统一返回类，所以会导致转换出错\n解决的办法有三种\n第一种: 在处理器中做判断, 为String 的时候手动格式化为统一返回类对应的Json格式字符串\n@Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { // 判断Controller的返回类型是否是String 类型, 如果是, 则转换为Json格式的String再返回  if(returnType.getParameterType().isAssignableFrom(String.class)) { return R.ofSuccess(body).toJsonString(); } return R.ofSuccess(body); } 第二、三种: 更改Spring 的HttpMessageConverter 配置，使其用对应的HttpMessageConverter 来进行转换\n@Component public class WebConfiguration implements WebMvcConfigurer { @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { // 第二种: 将json 处理的转换器放到第一位, 使得json 转换器优先处理返回值  // converters.add(0, new MappingJackson2HttpMessageConverter());  // 第三种: 去掉String类型的转换器, 不使用String类型的转换器  // converters.removeIf(converter -\u0026gt; converter.getClass().isAssignableFrom(StringHttpMessageConverter.class));  } }  02 \n到此为止才算完成了\n","date":"2021-01-10T08:02:12Z","image":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8controlleradvice%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85controller%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/title_hub80bc5c70e877435ca12de7583f12aa3_61528_120x120_fill_q75_box_smart1.jpg","permalink":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8controlleradvice%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85controller%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/","title":"使用ControllerAdvice统一封装Controller返回数据"},{"content":"自定义Validator校验注解 通常来说, Hibernate Validation提供的注解已经够用了, 但有时候还是需要根据业务自定义校验规则.\n自定义注解 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE }) @Repeatable(Time.List.class) // 设置自定义注解实现类 @Constraint(validatedBy = {TimeValidate.class}) public @interface Time { boolean allowNull() default false; String regexp() default \u0026#34;^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9]$\u0026#34;; String message() default \u0026#34;时间格式错误\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE }) public @interface List { Time[] value(); } } 自定义注解实现 // 需要实现ConstraintValidator, 第一项参数是要校验的注解, 第二项是要校验的值的类型 public class TimeValidate implements ConstraintValidator\u0026lt;Time, String\u0026gt; { private boolean allowNull; private Pattern regexp; // 初始化  @Override public void initialize(Time annotation) { allowNull = annotation.allowNull(); regexp = Pattern.compile(annotation.regexp()); } // 自定义校验实现  @Override public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) { if(value == null) { return allowNull; } return regexp.matcher(value).matches(); } } 在参数实体类中使用 @Data public class TimeParam { @NotNull(message = \u0026#34;id不能为空\u0026#34;) private Integer id; @Time(allowNull = true) private String time; } ","date":"2020-11-18T20:12:21Z","permalink":"https://chaosalphard.github.io/p/validate%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/","title":"Validate自定义校验注解"},{"content":"Validator分组校验 定义接口, 接口里面不需要写任何东西, Validator会把接口视为一个一个的组\npublic interface IGet {} public interface IList {} public interface IAdd {} public interface IEdit {} public interface IDelete {} // 如果一个组继承了另一个组, // 则在校验属于这个组的参数时, // 也会一并校验被继承组的参数 public interface ISexFilter extends Default {} 修改参数实体类\n@Data public class Param { // groups 定义该字段所属的\u0026#34;组\u0026#34;  @NotNull(message = \u0026#34;id不能为空\u0026#34;, groups = {IGet.class, IEdit.class, IDelete.class}) @Null(message = \u0026#34;获取列表时不需要ID\u0026#34;, groups = IList.class) private Integer id; @NotBlank(message = \u0026#34;name不能为空\u0026#34;, groups = IAdd.class) @Null(message = \u0026#34;不能修改name\u0026#34;, groups = IEdit.class) private String name; @NotNull(message = \u0026#34;age不能为空\u0026#34;, groups = IEdit.class) private Integer age; @NotNull(message = \u0026#34;sex不能为空\u0026#34;, groups = IEdit.class) @NotBlank(message = \u0026#34;sex不能为空\u0026#34;, groups = ISexFilter.class) private Byte sex; // 没有标明groups参数时, 默认属于Default组  @NotBlank(message = \u0026#34;time不能为空\u0026#34;) private String time; } 修改Controller\n@GetMapping @ResponseBody // 如果没有传入要校验的组, Validator默认校验Default组的参数 public String validateTest(@Validated Param param){ return \u0026#34;success\u0026#34;; } @GetMapping(\u0026#34;/get\u0026#34;) @ResponseBody public Object get(@Validated(value = {IGet.class, ISexFilter.class}) Param param){ return service.get(param.getId()); } @GetMapping(\u0026#34;/list\u0026#34;) @ResponseBody // 这里虽然只指定了校验 IList组 和 ISexFilter组, // 但由于 ISexFilter组 继承了 Default组, // 所以实际上是校验属于 IList组, ISexFilter组, Default组 的参数. // 且由于 time 字段没有指明所属组, 所以 time字段 默认属于 Default组, // 故而 id(IList组), sex(ISexFilter组), time(Default组) 字段都会被校验. public List\u0026lt;Object\u0026gt; list(@Validated({IList.class, ISexFilter.class}) Param param){ return service.list(); } @PostMapping(\u0026#34;/add\u0026#34;) @ResponseBody public String add(@Validated(value = IAdd.class) @RequestBody Param param){ return \u0026#34;success\u0026#34;; } @PatchMapping(\u0026#34;/edit\u0026#34;) @ResponseBody public String edit(@Validated(IEdit.class) @RequestBody Param param){ return \u0026#34;success\u0026#34;; } @DeleteMapping(\u0026#34;/delete\u0026#34;) @ResponseBody public String delete(@Validated(IDelete.class) @RequestBody IndexParam param){ return \u0026#34;success\u0026#34;; } 定义Validator校验顺序  默认情况下, 不同组别的约束验证是无序的, 然而在某些情况下, 约束验证的顺序却很重要. 例如:\n 第二个组中的校验依赖于一个稳定状态, 而这个稳定状态是由第一个组来进行校验的. 某个组的校验比较耗时, 最优的选择是将其放在最后进行验证.   定义分组接口\npublic interface IFirstValidate {} public interface ISecondValidate {} 定义分组校验顺序 @GroupSequence({ IFirstValidate.class, ISecondValidate.class }) public interface IValidateGroup {} 使用 参数实体类\n@Data public class EditParam { @NotNull(message = \u0026#34;id不能为空\u0026#34;, groups = IFirstValidate.class) private Integer id; @NotNull(message = \u0026#34;detail不能为空\u0026#34;, groups = IFirstValidate.class) @Size(min = 1024, message = \u0026#34;detail不能小于1024\u0026#34;, groups = ISecondValidate.class) private List\u0026lt;Object\u0026gt; detail; } 在控制器中使用\n@PutMapping(\u0026#34;/edit\u0026#34;) @ResponseBody public String edit(@Validated(IValidateGroup.class) @RequestBody EditParam param){ return \u0026#34;success\u0026#34;; } ","date":"2020-11-10T12:30:22Z","permalink":"https://chaosalphard.github.io/p/validate%E5%8F%82%E6%95%B0%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/","title":"Validate参数分组校验"},{"content":" JSR-303是一项标准, JSR-349是其的升级版本, 添加了一些新特性, 这项标准规定了一些校验规范, 如@Null, @NotNull, @Pattern, 位于javax.validation.constraints包下, 只提供规范不提供实现.\nHibernate Validation是对这个规范的实践, 他提供了相应的实现, 并增加了一些其他校验注解, 如@Email, @Length, @Range等.\n 引入Validator依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate.validator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.1.6.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置Validator Validator默认会对所有数据进行校验, 然后返回结果, 如果想要在校验到数据不符合规则时直接返回结果的话, 则需要进行配置\n@Configuration public class ValidatorConfiguration { @Bean public Validator validator() { return Validation.byProvider(HibernateValidator.class) .configure() // 设置校验到任意数据不符合规则时直接返回结果, 不再对剩余数据进行校验  .failFast(true) .buildValidatorFactory() .getValidator(); } } 使用Validator对Controller参数进行校验 参数实体类\n@Data public class Param { @NotNull(message = \u0026#34;id不能为空\u0026#34;) private Integer id; @NotBlank(message = \u0026#34;name不能为空\u0026#34;) private String name; @NotNull(message = \u0026#34;age不能为空\u0026#34;) private Integer age; @NotNull(message = \u0026#34;sex不能为空\u0026#34;) private Byte sex; private String time; } Controller\n@PostMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public String hello(@Validated @RequestBody Param param, BindingResult result) { if(result.hasErrors()) { return \u0026#34;fail\u0026#34;; } return \u0026#34;success\u0026#34;; } Validator会对参数进行校验，并返回校验结果(BindingResult)\n使用统一异常处理器来处理Validator校验结果 @RestControllerAdvice @ResponseStatus(HttpStatus.OK) public class GlobalExceptionHandler { // Json格式入参时, 参数不符合规则抛出MethodArgumentNotValidException  @ExceptionHandler(MethodArgumentNotValidException.class) public R\u0026lt;List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;\u0026gt; argNotValidErr(MethodArgumentNotValidException e) { return R.ofFail(getValidError(e.getBindingResult())); } // 使用Get请求接口, 参数写在url中时, 参数不符合规则抛出BindException  @ExceptionHandler(BindException.class) public R\u0026lt;List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt;\u0026gt; binddErr(BindException e) { return R.ofFail(getValidError(e.getBindingResult())); } // 处理Validator的验证结果, 获取所有的不符合规则的参数  private List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getValidErrors(BindingResult result) { if(result == null) { return new ArrayList\u0026lt;\u0026gt;(0); } List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; lis = new ArrayList\u0026lt;\u0026gt;(1); for(FieldError error : result.getFieldErrors()) { lis.add(new HashMap\u0026lt;\u0026gt;(){{ put(\u0026#34;field\u0026#34;, error.getField()); put(\u0026#34;message\u0026#34;, error.getDefaultMessage()); put(\u0026#34;rejectValue\u0026#34;, error.getRejectedValue()); }}); } return lis; } // 如果配置了Validator的failFast属性为true, 则可以使用下面的方法处理结果  private Map\u0026lt;String, Object\u0026gt; getValidError(BindingResult result) { if(result == null||result.getFieldError() == null) { return new HashMap\u0026lt;\u0026gt;(0); } FieldError error = result.getFieldError(); return new HashMap\u0026lt;\u0026gt;(){{ put(\u0026#34;field\u0026#34;, error.getField()); put(\u0026#34;message\u0026#34;, error.getDefaultMessage()); put(\u0026#34;rejectValue\u0026#34;, error.getRejectedValue()); }}; } } ","date":"2020-11-08T22:40:20Z","permalink":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8validate%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/","title":"使用Validate实现参数统一校验以及自定义校验规则"},{"content":"　Java中空判断随处可见，通常我们都是手动判断是否为空，然后再抛出自定义异常以及记录信息，例如:\nvar data = dao.findById(id); if(data == null) { log.error(\u0026#34;数据为空, id{}\u0026#34;, id); throw new CustomException(Status.USER_NOT_EXIST); } 这样的代码写多了就觉得麻烦，可不可以简化一下呢\n使用Assert替代null判断 　我们都知道sprng中有一个Assert类，其中有一个方法notNull() 可以用来判断是否为空，并且输出自定义提示，何不根据此改造一下，做一个自定义的Assert类\n创建枚举类接口 创建默认枚举方法，需要与你自定义枚举中的属性对应\npublic interface IBaseEnum { int getCode(); String getMessage(); } 创建自定义异常 public class CustomException extends Exception { private int code; private String detail; private Object data; public CustomException(IBaseEnum enums, String detail, Object data) { super(enums.getMessage()); this.code = enums.getCode(); this.detail = detail; this.data = data; } public CustomException(int code, String message, String detail, Object data) { super(message); this.code = code; this.detail = detail; this.data = data; } @Override public String toString() { return \u0026#34;CustomException{\u0026#34; + \u0026#34;code=\u0026#34; + code + \u0026#34;, message=\u0026#39;\u0026#34; + super.getMessage() + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, detail=\u0026#39;\u0026#34; + detail + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, data=\u0026#34; + data + \u0026#34;} \u0026#34;; } public int getCode() { return code; } public String getDetail() { return detail; } public Object getData() { return data; } } 创建异常断言构造 创建默认异常的构造方法，可以根据情况修改\npublic interface ICustomExceptionAssert { default CustomException newException(IBaseEnum enums, String detail, Object data) { return new CustomException(enums, detail, data); } default CustomException newException(int code, String message, String detail, Object data) { return new CustomException(code, message, detail, data); } } 创建基础断言类 默认的异常断言，可以根据自己业务需要增加各种逻辑判断\npublic interface IBaseAssert extends IBaseEnum, ICustomExceptionAssert { default void notNull(Object object, String detail) throws CustomException { if(object == null) { LogUtils.error(detail) throw newException(this, detail, null); } } default void success(int line, String detail) throws CustomException { if(line \u0026lt; 1) { LogUtils.error(detail) throw newException(this, detail, data); } } } 使用枚举来完善断言 public enum GlobalAssert implements IBaseAssert { USER_EXIST(Status.USER_NOT_EXIST,\u0026#34;用户不存在\u0026#34;), SQL_EXECUTE(Status.SQL_ERROR, \u0026#34;无匹配记录\u0026#34;), ; private int code; private String message; Assert(int code, String message) { this.code = code; this.message = message; } @Override public int getCode() { return this.code; } @Override public String getMessage() { return this.message; } } 测试 var data = dao.findById(id); var logInfo = MessageFormatter.arrayFormat(\u0026#34;数据为空, id: {}\u0026#34;, id).getMessage(); Assert.USER_EXIST.notNull(data, logInfo); var sqlExecErr = MessageFormatter.arrayFormat(\u0026#34;新增用户失败: {}\u0026#34;, data).getMessage(); Assert.SQL_EXECUTE.success(other.insert(data), sqlExecErr)  结果 \n异常处理 使用@ControllerAdvice与@ExceptionHandler注解来进行全局异常捕获即可\n","date":"2020-10-19T23:37:23Z","image":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/title_hu5bdf26e5c60cb3c2fbb67ddadd988fa7_276589_120x120_fill_q75_box_smart1.jpg","permalink":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/","title":"使用自定义断言处理常见的异常"},{"content":"进入正题之前先简单说说值传递和引用传递的区别\n 按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。\n 下面是我用Rust来做的一个简单示范。\n Rust \n可以看到，虽然call_by_value函数和call_by_reference函数都将接收到的参数的值修改为了12450，但是由于call_by_reference函数接收的是by_ref变量的引用，所以在函数内修改by_ref的值会影响到函数外部的by_ref变量，而call_by_value函数接收的是by_val变量的值，所以在函数内修改by_val的值不会影响到函数外部的by_val变量。\n对于基本数据类型, Java是值传递还是引用传递? 看下图\n 00 \n可以看到，在函数内的修改并没有影响到函数外部的num，所以对于基本数据类型, Java是值传递\n对于基本数据的包装类, 也是值传递\n 01 \n对于引用类型, Java是值传递还是引用传递? 看下图\n 02 \n可以看到，在函数内的修改已经影响到了函数外部的lis，这似乎证明了对于引用类型, Java是引用传递\n但是, 我们都知道, 对于引用类型, 变量保存的是指向其堆内存的地址, 也就是说, 如果将引用类型赋值给另一个变量, 修改当前变量的值, 另一个变量也会被改变, 如何理解呢? 请看下图\n 03 \n可以看到, 虽然只是修改了lis而没有去修改copy, 但由于lis和copy指向的是同一内存地址, 所以对lis的修改也会体现在copy上\n ref \n回到正题，既然知道了lis变量是对于堆内存中ArrayList的引用, 那么之前的结果就不成立了, 修改changeValue方法再看  04 \n可以看到, 在函数中将一个新的ArrayList的引用赋值给了lis变量, 但是函数外的lis变量依然指向的是原来的ArrayList, 所以得出结论, 对于引用类型, Java也是值传递\n结论 无论是对于基本数据类型还是引用类型，Java都是值传递，但要注意的是，对于引用类型，变量保存的是其引用，所以通过函数接收的变量去修改其指向的引用类型，也会影响到函数外的变量，而给函数接收的变量赋予新的引用，则不会影响到函数外的变量。\n","date":"2020-04-20T23:45:38Z","image":"https://chaosalphard.github.io/p/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/ref_huc408f4a09915fb0ab9e8d5380cc46f77_11779_120x120_fill_box_smart1_2.png","permalink":"https://chaosalphard.github.io/p/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/","title":"Java是值传递还是引用传递"},{"content":"Java8新的时间处理API 原有的java.util.Date与新增的java.time有何差异？\n java.util.Date设定为可变类型 SimpleDateFormat是非线程安全的 新的API 基于ISO 标准日历系统, 遵循Gregorian 规则 java.time包下的所有类都是不可变类型 java.time包下的所有类都是线程安全的  java.time简单介绍 java.time由以下5个包组成:\n java.time: 包含值对象的基础包 java.time.chrono: 提供对不同的日历系统的访问 java.time.format: 格式化和解析时间和日期 java.time.temporal: 包括底层框架和扩展特性 java.time.zone: 包含时区支持的类  关于java.time下, 类的简介:\n Instant: 时间戳 LocalDate: 只包含日期，比如: 2020-01-01 LocalTime: 只包含时间，比如: 12:00:00 LocalDateTime: 包含日期和时间，比如: 2020-01-01T12:00:00 Duration: 时间段, 主要用于计算两个时间之间的差值 Peroid: 时间段, 主要用于计算两个日期之间的差值 ZoneOffset: 时区偏移量，比如: +8:00 ZonedDateTime: 带时区的日期时间 Clock: 时钟，可以获取或指定时区, 也可获取当前的时刻 DateTimeFormatter: 时间格式化  关于java.time下大部分类的方法前缀简介:\n of: 静态工厂方法(用类名去调用)。 parse: 静态工厂方法，关注于解析(用类名去调用)。 now: 静态工厂方法，用当前时间创建实例(用类名去调用) get: 获取某些东西的值。 is: 检查某些东西的是否是true。 with: 返回一个部分状态改变了的时间日期对象拷贝(单独一个with方法,参数为TemporalAdjusters类型) plus: 返回一个时间增加了的、时间日期对象拷贝(如果参数是负数也能够有minus方法的效果) minus: 返回一个时间减少了的、时间日期对象拷贝 to: 把当前时间日期对象转换成另外一个，可能会损失部分状态. at: 把这个对象与另一个对象组合起来，例如: date.atTime(time)。 format: 根据某一个DateTimeFormatter格式化为字符串  新的API要如何使用 获取当前的时间日期 LocalDate date = LocalDate.now(); LocalTime time = LocalTime.now(); // 使用.withNano(0) 来去除纳秒数显示 LocalDateTime datetime = LocalDateTime.now().withNano(0); System.out.println(date); // 2020-04-18 System.out.println(time); // 20:41:02.626861700 System.out.println(datetime); // 2020-04-18T20:41:02 与字符串相互转换 final LocalDateTime now = LocalDateTime.now().withNano(0); final DateTimeFormatter patternToString = DateTimeFormatter.ofPattern(\u0026#34;G yyyy年MM月dd号 E a hh时mm分ss秒\u0026#34;); final String byFormat = now.format(patternToString); System.out.println(byFormat); // 公元 2020年04月18号 周六 下午 02时11分43秒  final DateTimeFormatter patternToDate = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); final LocalDateTime byParse = LocalDateTime.parse(\u0026#34;2020-04-18 14:11:43\u0026#34;, patternToDate); System.out.println(byParse); // 2020-04-18T14:11:43 获取单独的年月日时分秒信息 LocalDate date = LocalDate.now(); int year = date.getYear(); int month = date.getMonthValue(); int day = date.getDayOfMonth(); System.out.println(year); // 2020 System.out.println(month); // 4 System.out.println(day); // 18  LocalTime time = LocalTime.now(); int hour = time.getHour(); int minute = time.getMinute(); int second = time.getSecond(); int nano = time.getNano(); System.out.println(hour); // 8(时) System.out.println(minute); // 2(分) System.out.println(second); // 5(秒) System.out.println(nano); // 453345500(纳秒)  LocalDateTime dateTime = LocalDateTime.now(); System.out.println(dateTime.getYear()); // 2020 System.out.println(dateTime.getHour()); // 8 自定义日期时间 final LocalDate date = LocalDate.of(2020, 4, 18); final LocalTime time = LocalTime.of(8, 20, 45); final LocalDateTime dateTime = LocalDateTime.of(date, time); // 使用LocalDateTime.of(2020,4,18,8,10,30)方式也可创建自定义LocalDateTime // 因为没有指定nano值, 所以不会出现出现纳秒显示 System.out.println(dateTime); // 2020-04-18T08:20:45 时间比较 final LocalDate date1 = LocalDate.now(); // 假设今天为2020-4-18 final LocalDate date2 = LocalDate.of(2020, 4, 18); // LocalTime和LocalDateTime 同理 // equals: 比较是否相等 if(date1.equals(date2)) { System.out.println(\u0026#34;相等\u0026#34;); } else { System.out.println(\u0026#34;不相等\u0026#34;); } // isAfter: 是否晚于某个日期 // isBefore: 是否早于某个日期 if(date1.isAfter(date2)) { System.out.println(date1+\u0026#34; 晚于 \u0026#34;+date2); } else if(date1.isBefore(date2)) { System.out.println(date1+\u0026#34; 早于 \u0026#34;+date2); } 检查周期性事件 final LocalDate now = LocalDate.now(); final MonthDay targetMonthDay = MonthDay.of(10, 1); final MonthDay currentMonthDay = MonthDay.from(now); if(currentMonthDay.equals(targetMonthDay)) { System.out.println(\u0026#34;国庆到了\u0026#34;); } 计算某段时间之前或之后的日期 final LocalDateTime dateTime = LocalDateTime.now().withNano(0); final LocalDateTime dateTime2 = dateTime // 计算当前时间的 一个月后  .plusMonths(1) // 又 一周后  .plusWeeks(1) // 又 2个半天(12h)后  .plus(2, ChronoUnit.HALF_DAYS) // 又 1小时前  .minusHours(1) // 又 2个月前 的时间  .minus(2, ChronoUnit.MONTHS); System.out.println(dateTime2); Clock 时钟类的用法 final Clock clock = Clock.systemUTC(); final long millis = clock.millis(); System.out.println(millis); // 1587320754163  System.out.println(millis == System.currentTimeMillis()); // true // Instant.now().toEpochMilli() 也可获取时间戳 System.out.println(millis == Instant.now().toEpochMilli()); // true  final Clock zone = Clock.systemDefaultZone(); ZoneId id = zone.getZone(); System.out.println(id); // Asia/Shanghai  System.out.println(id.getId().equals(TimeZone.getDefault().getID())); // true  final LocalDateTime now = LocalDateTime.now().withNano(0); final ZoneId zoneIdOfHonolulu = ZoneId.of(\u0026#34;Pacific/Honolulu\u0026#34;); final ZonedDateTime timeInHonolulu = ZonedDateTime.of(now, zoneIdOfHonolulu); System.out.println(timeInHonolulu); // 2020-04-20T02:25:24-10:00[Pacific/Honolulu] 其他用法 final LocalDateTime now = LocalDateTime.now().withNano(0); // 判断是否是闰年, LocalDate类才有此方法 if(LocalDate.from(now).isLeapYear()) { System.out.println(\u0026#34;今年是闰年\u0026#34;); } // 获取星期 System.out.println(now.getDayOfWeek()); // SATURDAY  final LocalTime time = LocalTime.of(12, 0, 0); final LocalDate start = LocalDate.of(2018, 8, 18); final LocalDate end = LocalDate.of(2020, 8, 18); final LocalDateTime startDate = LocalDateTime.of(start, time); final LocalDateTime endDate = LocalDateTime.of(end, time); // 计算两个日期直接的差值, 如果第一个参数的时间晚于第二个参数, 则该类的其他方法结果会返回负数 final Duration between = Duration.between(startDate, endDate); // 计算天数差值 System.out.println(between.toDays()); // 731 (第一个参数晚于第二个参数则会返回负数-731) // 计算小时数差值 System.out.println(between.toHours()); // 17544 (-17544) // 计算分钟数差值 System.out.println(between.toMinutes()); // 1052640 (-1052640)  final Period period = Period.between(LocalDate.from(startDate),LocalDate.from(endDate)); // 计算月份差值 System.out.println(period.toTotalMonths()); // 24 ","date":"2020-04-18T23:40:28Z","permalink":"https://chaosalphard.github.io/p/java8%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86api/","title":"Java8中新增的时间处理API"},{"content":"OAuth2.0资源服务器搭建 引入依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编写配置文件 SecurityConfig.java\n@Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/res/**\u0026#34;) // 需要通过验证  .authenticated() .anyRequest().permitAll() .and().csrf().disable(); } } ResourceServerConfig.java\n@Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(\u0026#34;res1\u0026#34;) // 资源id, 需要与ClientDetailsServiceConfigurer中的resourceIds一致  .tokenServices(tokenService()) // 验证令牌服务  .tokenStore(tokenStore) .stateless(true); } @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/**\u0026#34;) // 校验scope  .access(\u0026#34;#oauth2.hasScope(\u0026#39;all\u0026#39;)\u0026#34;) .and().csrf().disable() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); } @Bean public ResourceServerTokenServices tokenService() { // 远程服务器校验token。调用授权服务器校验token  RemoteTokenServices services = new RemoteTokenServices(); // 使用远程服务校验时，必须指定endpoint_url, client_id, client_secret  services.setCheckTokenEndpointUrl(\u0026#34;http://127.0.0.1:80/oauth/check_token\u0026#34;); services.setClientId(\u0026#34;c1\u0026#34;); services.setClientSecret(\u0026#34;secret\u0026#34;); return services; } } 控制器\n@RestController public class IndexController { @RequestMapping(\u0026#34;/res/r1\u0026#34;) @PreAuthorize(\u0026#34;hasRole(\u0026#39;USER\u0026#39;)\u0026#34;) public String resource01() { return \u0026#34;访问资源r1\u0026#34;; } } ","date":"2020-04-11T22:52:26Z","permalink":"https://chaosalphard.github.io/p/oauth2.0%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"OAuth2.0资源服务器搭建与配置"},{"content":"OAuth2.0授权服务器搭建 向pom.xml中添加以下依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置client端的详情信息\n@Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { // 配置客户端详情信息  @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() // inMemory: 使用内存方式  // 客户端ID  .withClient(\u0026#34;c1\u0026#34;) // 客户端密钥, 加密方式需要与SpringSecurity中的方式一致  .secret(new BCryptPasswordEncoder().encode(\u0026#34;secret\u0026#34;)) // 客户端可以访问的资源列表  .resourceIds(\u0026#34;res1\u0026#34;) // 允许的授权类型  .authorizedGrantTypes(\u0026#34;authorization_code\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;client_credentials\u0026#34;, \u0026#34;implicit\u0026#34;, \u0026#34;refresh_token\u0026#34;) // 允许的授权范围  .scopes(\u0026#34;all\u0026#34;) // 自动授权, 如果是授权码模式, 且设置为false, 则会跳转到授权页面  .autoApprove(false) // 授权成功后重定向地址, 授权成功后会在该地址后附带上授权码  .redirectUris(\u0026#34;http://127.0.0.1:80/token\u0026#34;); } } 配置令牌管理服务\n@Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Autowired private ClientDetailsService clientDetailsService; // 令牌管理服务配置  @Bean public AuthorizationServerTokenServices tokenServices() { DefaultTokenServices services = new DefaultTokenServices(); // 设置客户端信息服务  services.setClientDetailsService(clientDetailsService); // 是否产生刷新令牌  services.setSupportRefreshToken(true); // 令牌储存策略  services.setTokenStore(tokenStore); // 令牌默认有效期2小时 2*60*60  services.setAccessTokenValiditySeconds(7200); // 刷新令牌默认有效3天 3*24*60*60  services.setRefreshTokenValiditySeconds(259200); return services; } // 令牌存储策略  @Bean public TokenStore tokenStore() { // 内存方式, 生成普通令牌  return new InMemoryTokenStore(); } } 令牌访问端点配置\n@Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { @Autowired private AuthorizationCodeServices authorizationCodeServices; @Autowired // 这个Bean应该是配置在SecurityConfig文件中  private AuthenticationManager authenticationManager; // 设置授权码模式的授权码如何存取  @Bean public AuthorizationCodeServices authorizationCodeServices() { return new InMemoryAuthorizationCodeServices(); } // 令牌访问端点配置  @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager) // 密码模式需要  .authorizationCodeServices(authorizationCodeServices) // 授权码模式需要  // 令牌管理服务  .tokenServices(tokenServices()) // 允许post提交  .allowedTokenEndpointRequestMethods(HttpMethod.POST); } // 令牌访问端点安全策略  @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.tokenKeyAccess(\u0026#34;permitAll()\u0026#34;) .checkTokenAccess(\u0026#34;permitAll()\u0026#34;) // 允许表单认证申请令牌  .allowFormAuthenticationForClients(); } } SecurityConfig中的配置\n@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { // 密码编码设置  @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } // 认证管理器  @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } } 授权相关的页面编写 申请授权的页面\n\u0026lt;!-- /oauth/authorize 是默认请求授权链接 --\u0026gt; \u0026lt;form class=\u0026#34;pure-form pure-form-stacked\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;/oauth/authorize\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;client_id \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;client_id\u0026#34; placeholder=\u0026#34;client_id\u0026#34; required autofocus value=\u0026#34;c1\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;response_type \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;response_type\u0026#34; placeholder=\u0026#34;response_type\u0026#34; required value=\u0026#34;code\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;scope \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;response_type\u0026#34; placeholder=\u0026#34;response_type\u0026#34; required value=\u0026#34;all\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-controls\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;pure-button pure-button-primary\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;获取授权\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 申请token的页面\n\u0026lt;!-- /oauth/token 是默认申请令牌(access token)的链接 --\u0026gt; \u0026lt;form class=\u0026#34;pure-form pure-form-stacked\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;/oauth/token\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;client_id \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;client_id\u0026#34; placeholder=\u0026#34;client_id\u0026#34; required autofocus value=\u0026#34;c1\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;client_secret \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;client_secret\u0026#34; placeholder=\u0026#34;client_secret\u0026#34; required value=\u0026#34;secret\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;grant_type \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;grant_type\u0026#34; placeholder=\u0026#34;grant_type\u0026#34; required value=\u0026#34;authorization_code\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-control-group\u0026#34;\u0026gt; \u0026lt;label\u0026gt;code \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;code\u0026#34; placeholder=\u0026#34;code\u0026#34; required th:value=\u0026#34;${code!=null?code:\u0026#39;\u0026#39;}\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pure-controls\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;pure-button pure-button-primary\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;获取令牌\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 最后在控制器中完善一点细节，那么一个简单的授权服务器就可以使用了\n 授权 \n","date":"2020-04-09T01:00:25Z","permalink":"https://chaosalphard.github.io/p/oauth2.0%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"OAuth2.0授权服务器搭建与配置"},{"content":"什么是OAuth  OAuth(开放授权)是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源(如照片，视频，联系人列表)，而无需将用户名和密码提供给第三方应用。\n 举个例子: 用户借助QQ认证去登录网站A，如果认证通过了，就不需要用户手动在网站A注册账户了。\n那么怎么样才算认证通过？网站A成功从QQ获取用户信息则认为认证成功了。那么如何从QQ那里获取用户的身份信息呢？用户信息的拥有者是用户本人，QQ需要经过用户同意才可以为网站A生成令牌，而网站A拿到此令牌才可从QQ获取用户信息。\nOAuth的思路  OAuth在\u0026quot;第三方应用程序\u0026quot;与\u0026quot;服务提供商\u0026quot;之间，设置了一个授权层(authorization layer)。\u0026ldquo;第三方应用程序\u0026quot;不能直接登录\u0026quot;服务提供商\u0026rdquo;，只能登录授权层，以此将用户与第三方应用程序区分开来。\u0026ldquo;第三方应用程序\u0026quot;登录授权层所用的令牌(token)，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n \u0026ldquo;第三方应用程序\u0026quot;登录授权层以后，\u0026ldquo;服务提供商\u0026quot;根据令牌的权限范围和有效期，向\u0026quot;第三方应用程序\u0026quot;开放用户储存的资料。\n运行流程  Third-party application: 第三方应用程序，也可称为\u0026quot;客户端\u0026rdquo;，即例子中的\u0026quot;网站A\u0026rdquo;。它本身不储存资源，需要通过资源所有者的授权去请求资源服务器的资源。 HTTP service: HTTP服务提供商，即例子中的QQ。 Resource Owner: 资源所有者，也就是用户。 User Agent: 用户代理，一般是指浏览器。 Authorization server: 认证服务器，即服务提供商用来处理认证的服务器，用于服务提供商对资源拥有者的身份进行认证、对资源访问进行授权、认证成功后给客户端发放令牌(Access Token, 客户端访问资源服务器的凭据)。 Resource server: 资源服务器，即服务提供商存放用户资源的服务器。   认证服务器与资源服务器，它们可以是同一台服务器，也可以是不同的服务器。\n  运行流程 \n 用户打开第三方应用程序以后，第三方应用程序要求用户给予授权。 用户同意给予第三方应用程序授权。 第三方应用程序使用上一步获得的授权，向认证服务器申请令牌。 认证服务器对第三方应用程序进行认证以后，确认无误，同意发放令牌。 第三方应用程序使用令牌，向资源服务器申请获取资源。 资源服务器确认令牌无误，同意向第三方应用程序开放资源。 第三方应用程序拿到资源后，即可得知认证通过。  参考:\n 理解Oauth2.0 一图搞定OAuth2.0  ","date":"2020-04-07T03:14:56Z","permalink":"https://chaosalphard.github.io/p/oauth2.0%E7%AE%80%E4%BB%8B/","title":"OAuth2.0简介"},{"content":"使用注解进行授权控制  从SpringSecurity2.0版本开始，支持服务层方法的安全性支持，目前有@Secured，@PreAuthorize，@PostAuthorize三类注解\n 在@Configuration实例上使用@EnableGlobalMethodSecurity注解来启用基于注解的授权控制\n@Configuration @EnableWebSecurity // 启用方法授权 @EnableGlobalMethodSecurity( // 启用@Secured注解  securedEnabled = true, // 启用@PreAuthorize和@PostAuthorize注解  prePostEnabled = true ) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... } 之后向方法(类、方法或者接口)添加注解就会限制对该方法的访问\n@Secured注解 @RestController public class IndexController { // IS_AUTHENTICATED_ANONYMOUSLY: 表示可以匿名访问  @Secured(\u0026#34;IS_AUTHENTICATED_ANONYMOUSLY\u0026#34;) @RequestMapping(\u0026#34;/r\u0026#34;) public String resource() { return getUserName()+\u0026#34;访问资源\u0026#34;; } // ROLE_USER: 表示需要有USER权限才能访问  @Secured(\u0026#34;ROLE_USER\u0026#34;) @RequestMapping(\u0026#34;/r1\u0026#34;) public String resource1() { return getUserName()+\u0026#34;访问资源1\u0026#34;; } } @PreAuthorize和@PostAuthorize注解 @RestController public class IndexController { // @PreAuthorize 会在方法执行前进行权限验证  // isAnonymous() 允许匿名访问  @PreAuthorize(\u0026#34;isAnonymous()\u0026#34;) @RequestMapping(\u0026#34;/pre/a\u0026#34;) public String preAssets() { return getUserName()+\u0026#34;访问preAssets\u0026#34;; } // 拥有USER 权限才可访问  @PreAuthorize(\u0026#34;hasRole(\u0026#39;USER\u0026#39;)\u0026#34;) @RequestMapping(\u0026#34;/pre/a1\u0026#34;) public String preAssets1() { return getUserName()+\u0026#34;访问preAssets1\u0026#34;; } // @PostAuthorize 会在方法执行后进行权限验证  // 拥有USER 和ADMIN 任一权限即可访问  @PostAuthorize(\u0026#34;hasAnyRole(\u0026#39;USER\u0026#39;, \u0026#39;ADMIN\u0026#39;)\u0026#34;) @RequestMapping(\u0026#34;/post/a1\u0026#34;) public String postAssets1() { System.out.println(\u0026#34;访问postAssets1\u0026#34;); return getUserName()+\u0026#34;访问postAssets1\u0026#34;; } // 同时拥有USER 和ADMIN 权限才可访问  @PostAuthorize(\u0026#34;hasRole(\u0026#39;USER\u0026#39;) and hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) @RequestMapping(\u0026#34;/post/a2\u0026#34;) public String postAssets2() { System.out.println(\u0026#34;访问postAssets2\u0026#34;); return getUserName()+\u0026#34;访问postAssets2\u0026#34;; } } ","date":"2020-04-04T02:10:29Z","permalink":"https://chaosalphard.github.io/p/springsecurity%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83%E6%8E%A7%E5%88%B6/","title":"SpringSecurity使用注解进行授权控制"},{"content":"在Controller中获取认证信息 @Controller public class IndexController { @RequestMapping(\u0026#34;/user\u0026#34;) public String user(Model model) { String username = getUserName(); model.addAttribute(\u0026#34;username\u0026#34;,username); return \u0026#34;user\u0026#34;; } private String getUserName() { // 获取认证信息  Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 检查用户是否认证  if(authentication == null || !authentication.isAuthenticated()) { return \u0026#34;游客\u0026#34;; } Object principal = authentication.getPrincipal(); if(principal instanceof UserDetails) { return ((UserDetails) principal).getUsername(); } else { return principal.toString(); } } } 会话控制 在配置类中通过下列选项控制会话何时创建以及Spring Security 如何与之交互\n always: 如果没有session, 则创建一个 ifRequired: 如果需要, 则创建一个. (默认) never: Spring Security 不会主动创建session 但如果应用中其他地方创建了session 那么Spring Security 将会使用session stateless: Spring Security 将不会创建session, 也不会使用session  @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED); } ","date":"2020-04-03T01:00:28Z","permalink":"https://chaosalphard.github.io/p/springsecurity%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/","title":"SpringSecurity会话管理"},{"content":"自定义登录页 修改配置\n@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/\u0026#34;,\u0026#34;/index\u0026#34;,\u0026#34;/error\u0026#34;,\u0026#34;/identify\u0026#34;).permitAll() .antMatchers(\u0026#34;/user/**\u0026#34;).hasRole(\u0026#34;USER\u0026#34;) .and().formLogin() // 自定义登录页面地址  .loginPage(\u0026#34;/login\u0026#34;) // 指定处理登录请求的url, 即登录表单的action对应的地址  .loginProcessingUrl(\u0026#34;/identify/login\u0026#34;) // 成功后默认跳转到的url  .defaultSuccessUrl(\u0026#34;/user\u0026#34;) .and() // 禁用跨域请求验证  .csrf().disable(); } } 映射路径\n// RequestMapping 的路径, 即为配置类中loginPage设置的路径 @RequestMapping(\u0026#34;/login\u0026#34;) public String login() { return \u0026#34;login\u0026#34;; } 页面编写\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Login\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- action中的url即为配置类中, loginProcessingUrl项设置的url --\u0026gt; \u0026lt;!-- 登录请求一律用post发送, 不能用get --\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;/identify/login\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Please sign in\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; name=\u0026#34;username\u0026#34; placeholder=\u0026#34;Username\u0026#34; required autofocus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; placeholder=\u0026#34;Password\u0026#34; required\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 如果没有在配置类中关闭csrf验证, 则需要在表单中加入下面的表单项 --\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; th:if=\u0026#34;${_csrf != null}\u0026#34; th:name=\u0026#34;${_csrf.parameterName}\u0026#34; th:value=\u0026#34;${_csrf.token}\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Sign in\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 自定义注销 修改配置\n@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/\u0026#34;,\u0026#34;/index\u0026#34;,\u0026#34;/error\u0026#34;,\u0026#34;/identify\u0026#34;).permitAll() .antMatchers(\u0026#34;/user/**\u0026#34;).hasRole(\u0026#34;USER\u0026#34;) .and().formLogin() .loginPage(\u0026#34;/login\u0026#34;) .loginProcessingUrl(\u0026#34;/identify/login\u0026#34;) .and().logout() // 指定处理注销请求的url, 即注销表单的action对应的地址  .logoutUrl(\u0026#34;/identify/logout\u0026#34;) // 指定注销后的跳转页面  .logoutSuccessUrl(\u0026#34;/index\u0026#34;) // 注销时是否一并也让HttpSession 无效化  .invalidateHttpSession(true) .and().csrf().disable(); } } 映射路径\n@RequestMapping(\u0026#34;/logout\u0026#34;) public String logout() { return \u0026#34;logout\u0026#34;; } 页面编写\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Logout\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;/identify/logout\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Are you sure?\u0026lt;/h2\u0026gt; \u0026lt;!-- 如果没有在配置类中关闭csrf验证, 则需要在表单中加入下面的表单项 --\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; th:if=\u0026#34;${_csrf != null}\u0026#34; th:name=\u0026#34;${_csrf.parameterName}\u0026#34; th:value=\u0026#34;${_csrf.token}\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Yes, logout\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!-- 如果关闭了csrf验证, 则注销请求可用get发送 --\u0026gt; \u0026lt;a href=\u0026#34;/identify/logout\u0026#34;\u0026gt;Logout\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2020-03-31T22:34:17Z","permalink":"https://chaosalphard.github.io/p/springsecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E4%B8%8E%E6%B3%A8%E9%94%80/","title":"SpringSecurity自定义登录与注销"},{"content":"设置超时时间 在application.yml中\n# 设置超时时间ribbon:# 指与服务器建立链接的超时时间(单位: ms)ConnectTimeout:1000# 指与服务器建立链接之后，从服务器读取到可用资源所花时间ReadTimeout:5000配置日志输出 OpenFeign有4个日志级别\n NONE: 不输出任何日志 BASIC: 仅记录请求方法、URL、响应状态吗以及执行时间 HEADERS: 除了BASIC中的信息外，还记录请求和响应的头信息 FULL: 输出所有信息  编写配置类\npackage com.ilirus.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class OpenFeignConfig { @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } } 在application.yml中配置控制台日志输出级别\nlogging:level:com.ilirus.springcloud.service.PaymentFeignService:debug","date":"2020-03-29T22:50:00Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A010-openfeign%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","title":"[笔记]SpringCloud学习10: OpenFeign超时配置与日志记录"},{"content":"Feign 简介  Feign是一个声明式的WebService客户端。它的出现使开发WebService客户端变得很简单。使用Feign只需要创建一个接口加上对应的注解。\nFeign 是一种声明式、模板化的HTTP 客户端。在SpringCloud 中使用Feign，可以做到使用HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问HTTP 请求。\n Feign 和 OpenFeign OpenFeign在Feign的基础上支持了SpringMVC的注解。\n在OpenFeign中，除了自身提供的注解之外，还支持使用JAX-RS注解，或者SpringMVC注解。\nOpenFeign的@FeignClient注解可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。\nOpenFeign同样使用声明式方式定义Web服务客户端，其次，OpenFeign还可以通过集成Ribbon或Eureka来实现负载均衡的HTTP 客户端。\nOpenFeign 的使用 在服务消费方的pom.xml中，引入以下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 创建相应的Service接口\npackage com.ilirus.springcloud.service; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; // value为服务提供方在Eureka中注册的名称 // RequestMapping为提供方对应的请求地址 @FeignClient(value = \u0026#34;irs-provider-payment\u0026#34;) public interface PaymentFeignService { @GetMapping(\u0026#34;/payment/query/{id}\u0026#34;) public CommonResult\u0026lt;Payment\u0026gt; getPaymentByID(@PathVariable(\u0026#34;id\u0026#34;) Long id); } 创建Controller\npackage com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import com.ilirus.springcloud.enums.Status; import com.ilirus.springcloud.service.PaymentFeignService; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.*; import org.springframework.web.client.RestTemplate; import javax.annotation.Resource; @RestController @RequestMapping(\u0026#34;/consumer\u0026#34;) @Slf4j public class OrderController { @Resource private PaymentFeignService paymentFeignService; @GetMapping(\u0026#34;/payment/query/{id}\u0026#34;) public CommonResult query(@PathVariable(\u0026#34;id\u0026#34;) Long id) { return paymentFeignService.getPaymentByID(id); } } 在启动类中使用@EnableFeignClients注解\npackage com.ilirus.springcloud; import com.ilirus.springcloud.config.ApplicationontextConfig; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients public class OrderFeignMain80 { ... } ","date":"2020-03-29T03:07:11Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A009-openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/","title":"[笔记]SpringCloud学习09: OpenFeign服务调用"},{"content":"Spring Security 是什么 Spring Security是一套认证授权框架，支持认证模式如HTTP BASIC 认证头 (基于 IETF RFC-based 标准)，HTTP Digest 认证头 ( IETF RFC-based 标准)，Form-based authentication (用于简单的用户界面)，OpenID 认证等，Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制。\nSpring Security可以对所以进入系统的请求进行拦截，效验每个请求是否能访问对应的资源。\nSpring Security 如何工作 Spring Security对Web 资源的保护是靠Filter来实现的，当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的过滤器，类型为org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求都会经过这个过滤器。\nSpringSecurityFilterChain中包含的各个Filter都作为Bean被Spring所管理，他们是Spring Security的核心，各司其职，但这些Filter并不直接处理用户的认证，也不直接处理用户的授权，而出把这些工作交给认证管理器(AuthenticationManager)和决策管理器(AccessDecisionManager)进行处理。\n认证流程  SpringSecurity认证流程 \n引入依赖 在pom.xml中写入以下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 编写配置 package com.ilirus.oauth.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // 在内存中创建用户  auth.inMemoryAuthentication() // 使用BCryptPasswordEncoder 加密密码  .passwordEncoder(new BCryptPasswordEncoder()) // 用户名为 user  .withUser(\u0026#34;user\u0026#34;) // 密码为 123  .password(new BCryptPasswordEncoder().encode(\u0026#34;123\u0026#34;)) //拥有 USER 权限  .roles(\u0026#34;USER\u0026#34;); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 匹配\u0026#34;/\u0026#34;,\u0026#34;/index\u0026#34;,\u0026#34;/error\u0026#34;  .antMatchers(\u0026#34;/\u0026#34;,\u0026#34;/index\u0026#34;,\u0026#34;/error\u0026#34;) // 不需要权限即可访问  .permitAll() // 匹配\u0026#34;/user\u0026#34; 路径下的所有  .antMatchers(\u0026#34;/user/**\u0026#34;) // 拥有USER 权限才可访问  .hasRole(\u0026#34;USER\u0026#34;) .antMatchers(\u0026#34;/admin/**\u0026#34;) .hasRole(\u0026#34;ADMIN\u0026#34;) .and() // 允许使用表单登录  .formLogin() // 自定义登录页面地址  .loginPage(\u0026#34;/login\u0026#34;) // 指定处理登录的url, 即登录表单的action对应的地址  .loginProcessingUrl(\u0026#34;/login/identify\u0026#34;) // 成功后默认跳转到\u0026#34;/user\u0026#34;  .defaultSuccessUrl(\u0026#34;/user\u0026#34;) .and().logout() // 自定义注销地址  .logoutUrl(\u0026#34;/logout\u0026#34;) // 注销后跳转到 \u0026#34;/login\u0026#34;  .logoutSuccessUrl(\u0026#34;/login\u0026#34;) // 注销时是否让HttpSession 无效化  .invalidateHttpSession(true) .and() // 禁用跨域请求验证  .csrf().disable(); } } 如果不想关闭CSRF保护，则需要在自定义的登录表单中添加如下代码\n\u0026lt;input type=\u0026#34;hidden\u0026#34; th:if=\u0026#34;${_csrf != null}\u0026#34; th:name=\u0026#34;${_csrf.parameterName}\u0026#34; th:value=\u0026#34;${_csrf.token}\u0026#34; /\u0026gt; 至此，一个最简单的SpringSecurity 验证就引入到了demo 中\n使用UserDetailsManager创建用户: @Bean public UserDetailsService userDetailsService() { InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User .withUsername(\u0026#34;user\u0026#34;) .password(\u0026#34;123\u0026#34;) .roles(\u0026#34;USER\u0026#34;) .build()); return manager; } // 密码编码器 @Bean public PasswordEncoder passwordEncoder() { // NoOpPasswordEncoder: 不进行编码  return NoOpPasswordEncoder.getInstance(); } 连接数据库 修改之前的配置类\n@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { // 密码编码器  return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/\u0026#34;,\u0026#34;/index\u0026#34;,\u0026#34;/error\u0026#34;).permitAll() .antMatchers(\u0026#34;/user/**\u0026#34;).hasRole(\u0026#34;USER\u0026#34;) .and().formLogin(); } } 自定义一个service，继承UserDetailsService类\npackage com.ilirus.oauth.service; import com.ilirus.oauth.dao.UserDao; import com.ilirus.oauth.entities.UserEntity; import org.springframework.security.core.userdetails.User; import lombok.extern.slf4j.Slf4j; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; import javax.annotation.Resource; @Service @Slf4j public class UserService implements UserDetailsService { @Resource private UserDao dao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { log.info(\u0026#34;Username: \u0026#34;+username); // 数据库查询  UserEntity user = dao.getUser(username); UserDetails userDetails = User.withUsername(user.getName()) .password(user.getPassword()) .roles(\u0026#34;USER\u0026#34;).build(); return userDetails; } } loadUserByUsername方法中的参数即为登录表单中的用户名，在数据库中查询到对应用户的信息后，将其装入UserDetails中，然后返回给DaoAuthenticationProvider。\nDaoAuthenticationProvider会使用PasswordEncoder对用户提交的表单中的密码进行编码，然后将其与从UserDetailService中接收到的UserDetail 中的密码信息进行对比，以判断是否通过。\n","date":"2020-03-23T04:35:18Z","permalink":"https://chaosalphard.github.io/p/springsecurity%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/","title":"SpringSecurity简单入门"},{"content":"Ribbon 介绍  Ribbon是Netflix发布的一款用于负载均衡的开源项目，是一个客户端的负载均衡器。\n Ribbon会基于某些规则(轮询，随机等)决定要调用的服务链接，并且可以使用Ribbon实现自定义的负载均衡算法。\n负载均衡是什么 负载均衡(Load Balance)简单来说就是将用户的请求平摊到各个服务器上，从而提高服务的承载能力。\nRibbon 本地负载均衡和Nginx 服务端负载均衡的区别 Nginx: 客户端所有请求都先发给Nginx，让后由Nginx 服务器实现请求转发。(集中式LB)\nRibbon: 在调用微服务接口的时候，由Ribbon 的负载均衡算法决定调用哪个服务接口。(进程内LB)\n集中式LB 和进程内LB 集中式Load Balancer: 在服务的消费方和提供方之间使用独立的LB 设施，由该设施负责把请求访问通过某种策略转发制服务提供方\n进程内Load Balancer: 将LB 逻辑集成到消费方，消费方从服务注册中心获知有那些服务地址可用，然后自己再从这些地址中选择一个合适的服务器\nRibbon 引入 修改pom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --\u0026gt; \u0026lt;/dependency\u0026gt; Ribbon已经集成在Eureka Client中，如果pom.xml中已经引入Eureka Client，则可以不用再引入Ribbon\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Ribbon 的使用 使用@LoadBalancer注解授予RestTemplate负载均衡功能，\n@Configuration public class ApplicationontextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力  public RestTemplate getRestTemplate() { return new RestTemplate(); } } 使用@Resource或者@Autowired 装配具有负载均衡能力的RestTemplate\n@RestController @RequestMapping(\u0026#34;/test\u0026#34;) public class TestController { private static final String TEST_URL = \u0026#34;http://irs-provider-test/test\u0026#34;; @Resource private RestTemplate restTemplate; @GetMapping(\u0026#34;/get\u0026#34;) public CommonResult get() { // restTemplate 现在已经具有了负载均衡能力  return restTemplate.getForObject(TEST_URL+\u0026#34;/get\u0026#34;, CommonResult.class); } } Ribbon 默认算法介绍  RoundRobinRule: 轮询 RandomRule: 随机 RetryRule: 先按照RoundRobinRule策略获取服务，如果获取服务失败会在指定时间内重试 WeightedResponseTimeRule: 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大。如果统计信息不足，则使用RoundRobinRule策略。等信息足够，则切换到WeightedResponseTimeRule策略 ZoneAvoidanceRule: 复合判断 服务所在的区域的性能 和 服务的可用性 以选择服务器 BestAvailableRule: 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 AvaliabilityFilteringRule: 会先过滤由于多次访问故障而处于断路器跳闸的状态的服务 和 并发的连接数量超过阈值的服务，然后对剩余的服务列表进行轮询  Ribbon 负载规则替换  如果多个Ribbon客户端需要配置负载规则，则自定义配置类不能放在@ComponentScan所能扫描到的包下，否则自定义配置类会被所有的Ribbon共享，达不到定制的目的。\n 创建自定义配置类\n@Configuration public class LoadBalancerRuleConfig { @Bean public IRule LBRule() { // 定义负载均衡规则  return new RandomRule(); } } 在启动类中加上@RibbonClient注解\n@SpringBootApplication @EnableEurekaClient // 这里的name 指的是服务提供方的name // 即当前消费方使用自定义配置与其通信的服务提供方的 spring.application.name 的属性 @RibbonClient(name = \u0026#34;irs-provider-payment\u0026#34;, configuration = {LoadBalancerRuleConfig.class}) public class OrderMain80 { public static void main(String[] args) { SpringApplication.run(OrderMain80.class, args); } } ","date":"2020-03-21T03:44:07Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A008-ribbon%E5%9F%BA%E7%A1%80/","title":"[笔记]SpringCloud学习08: Ribbon基础"},{"content":"Eureka 自我保护机制 保护模式主要用于一组客户端和服务端之间存在网络分区场景下的保护，一旦进入保护模式，Eureka Server会尝试保护其服务注册表中的信息，将不再删除服务注册表中的信息，也就是不会注销任何微服务\n 一句话概括: 如果某一时刻，Eureka Server中某个微服务不可用了，Eureka不会立即清除，而是会尝试对该微服务的信息进行保存 (CAP中的AP)\n 为什么需要自我保护机制  为了防止Eureka Client可以正常运行，但与Eureka Server直接网络不同的情况下，Eureka Server错误地将可以正常运行的Client端移除\n 默认情况下，如果Eureka Server在一定时间内(默认90s)没有接收到某个服务实例的心跳时，Eureka Server会注销该实例。但当网络分区故障发生时(延时，拥挤)，微服务与Eureka Server之间无法正常通讯时，超时移除节点是不正确的行为——微服务自身很可能是正常状态，也就是说不应该注销此服务。\nEureka通过自我保护模式来解决这个问题——当Eureka Server短时间内丢失过多Client端时，那么这个节点将进入自我保护模式。\n也就是说宁可保留错误的服务注册信息，也不会盲目注销任何可能正常的服务实例\n如何判断Eureka 是否进入了自我保护模式 如果在Eureka Server首页看到以下提示，则说明Eureka进入了保护模式\n EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY\u0026rsquo;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.\n 如何禁止自我保护机制 在Erueka Server 端的application.yml文件中，添加以下内容\neureka:server:# 关闭自我保护机制enable-self-preservation:false# 移除服务的超时时间，单位毫秒eviction-interval-timer-in-ms:15000在Eureka Client 端的application.yml文件中，添加以下内容\neureka:# eureka 客户端instance:# Eureka Client 端向Server 端发送心跳的时间间隔，单位秒，默认30s# 修改心跳时间主要是因为修改了Server 端的超时时间(15000ms = 15s)# 所以对应的修改Client 端的心跳时间lease-renewal-interval-in-seconds:5# Eureka Server 端在收到最后一次心跳后等待时间上限，单位秒，超时将剔除服务，默认90slease-expiration-duration-in-seconds:15","date":"2020-03-20T03:02:19Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/","title":"[笔记]SpringCloud学习07: Eureka自我保护"},{"content":"获取Eureka Server 端注册成功的服务信息  对于注册进Eureka里面的微服务，可以通过服务发现来获取该服务的信息\n 修改对应工程(Eureka Client 端)的Controller\npackage com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.enums.Status; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; @RestController @RequestMapping(\u0026#34;/payment\u0026#34;) @Slf4j public class PaymentController { @Resource private DiscoveryClient discoveryClient; @GetMapping(\u0026#34;/discovery\u0026#34;) public CommonResult discovery() { List\u0026lt;String\u0026gt; services = discoveryClient.getServices(); return CommonResult.ofData(Status.SUCCESS, services); } @GetMapping(\u0026#34;/discovery/{instances}\u0026#34;) public CommonResult discovery(@PathVariable String instances) { List\u0026lt;ServiceInstance\u0026gt; serviceInstances = discoveryClient.getInstances(instances); return CommonResult.ofData(Status.SUCCESS, serviceInstances); } } 修改启动类\npackage com.ilirus.springcloud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @MapperScan(\u0026#34;com.ilirus.springcloud.dao\u0026#34;) @EnableEurekaClient @EnableDiscoveryClient public class PaymentMain8001 { ... }  \n \n","date":"2020-03-20T02:03:59Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/","title":"[笔记]SpringCloud学习06: Eureka服务发现"},{"content":"服务提供方集群搭建 参考之前搭建好的服务提供方工程，再创建一个新的工程，要注意application.yml中，spring.application.name属性要和之前的一致，完成后启动服务\n eureka \n服务消费方请求地址修改 在消费方工程中，将请求地址改为微服务名称\npackage com.ilirus.springcloud.controller; /* import ... */ @RestController @RequestMapping(\u0026#34;/consumer\u0026#34;) @Slf4j public class OrderController { private static final String PAYMENT_URL = \u0026#34;http://irs-provider-payment/payment\u0026#34;; @Resource private RestTemplate restTemplate; @GetMapping(\u0026#34;/payment/create\u0026#34;) public CommonResult create(Payment payment) { return restTemplate.postForObject(PAYMENT_URL+\u0026#34;/create\u0026#34;, payment, CommonResult.class); } /* ... */ } 因为目前irs-provider-payment服务下有两个实例，直接使用服务名并不能让程序知道你想用具体哪一个，所以还需要进一步配置\nRestTemplate 配置负载均衡 修改RestTemplate配置类\npackage com.ilirus.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力  public RestTemplate getRestTemplate() { return new RestTemplate(); } } 至此，全部配置完成\n 负载均衡 \n","date":"2020-03-19T22:02:13Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/","title":"[笔记]SpringCloud学习05: 服务提供方集群"},{"content":"Eureka 集群原理 我们假设有三台 Eureka Server 组成的集群，只要三个地方的任意一个Eureka Server不出现问题，都不会影响整个架构的稳定性。\n Eureka集群 \n从图中可以看出Eureka Server集群相互之间通过Replicate来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl 指向其他节点。\n如果某台Eureka Server 宕机，Eureka Client 的请求会自动切换到新的Eureka Server 节点。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它Eureka Server 当前所知的所有节点中。\n另外Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个Eureka Server 同时也是Eureka Client，多个Eureka Server 之间通过P2P的方式完成服务注册表的同步。\nEureka Server 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。\nEureka保证AP (CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance))\nEureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka Client 在向某个Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。\nEureka 集群搭建 新建一个Eureka Server，并修改application.yml文件\nserver:port:7002eureka:instance:hostname:eureka7002.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7001.com:7001/eureka/修改之前的单机eureka配置文件\nserver:port:7001eureka:instance:hostname:eureka7001.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7002.com:7002/eureka/ 因为是在同一台机器上，所以需要修改host文件将eureka7001.com和eureka7002.com映射为127.0.0.1\n 微服务注册进集群 回到之前的子工程中，修改application.yml文件中的eureka配置\neureka:# eureka 客户端client:register-with-eureka:truefetch-registry:trueservice-url:# 服务中心链接defaultZone:http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka启动服务，查看是否正确  集群 \n","date":"2020-03-17T23:33:16Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/","title":"[笔记]SpringCloud学习04: Eureka集群"},{"content":"Eureka Server端的搭建 创建一个Maven项目，在pom.xml中写入以下依赖:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --\u0026gt; \u0026lt;/dependency\u0026gt; 创建启动类\npackage com.ilirus.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaServerMain7001.class, args); } } 配置yml\nserver:port:7001eureka:# eureka 服务端instance:hostname:localhost# eureka服务端实例名称client:register-with-eureka:false# 是否向服务中心注册自己feth-registry:false# 是否向服务中心检索已有的注册信息service-url:# 设置Eureka Server 的交互地址。查询服务和注册服务都需要依赖这个地址defaultZone:http://${eureka.instance.hostname}:${server.port}/eureka/启动工程并查看是否有误\nEureka Client端的注册 回到之前的子项目中，向pom.xml中添加以下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改application.yml文件\nspring:application:name:irs-provider-payment8001# 名称eureka:# eureka 客户端client:register-with-eureka:true# 向服务中心注册自己fetch-registry:true# 向服务中心获取已有的注册信息, 集群必须设置为true才能配合ribbon使用负载均衡service-url:# 服务中心链接defaultZone:http://localhost:7001/eureka修改启动类并添加@EnbaleEurekaClient注解\npackage com.ilirus.springcloud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @MapperScan(\u0026#34;com.ilirus.springcloud.dao\u0026#34;) @EnableEurekaClient public class PaymentMain8001 { ... } 启动工程，刷新eureka管理网页，查看服务是否成功注册服务中心  管理页面 \n微服务显示信息完善 在对应工程中(Eureka Client 端)的application.yml文件中添加以下内容\neureka:instance:# 实例的显示idinstance-id:projectName# 显示ip地址prefer-ip-address:true","date":"2020-03-16T00:36:52Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/","title":"[笔记]SpringCloud学习03: Eureka的搭建"},{"content":"什么是服务治理 当我们的服务与服务之间通讯调用的时候，如果简单粗暴的用httpclient去请求，不经过第三方的组件管理，然后访问路径写死，那么如果有一个服务更换了路径，所有的服务都需要手动更换该服务的访问路径。维护的成本很高。\n就是因为出现了这些问题，所以引入了服务治理(SOA governance)这个概念，同时衍生了这类的实现组件，也就是注册中心。典型的代表：zookeeper，Eureka，Consul。服务治理也引入了 服务调用、负载均衡、容错等功能。\n 简单的总结：把服务看成一个地方。当我们服务调用的时候，就是从一个地方到另一个地方，这时候我们需要地图导航才能到达，当我们去的路程有一段路可能修路，无法通过的时候，导航就会帮我们规划另一条路线。这里的导航就是注册中心，会一定的时间就会刷新一下路况，就好像我们注册中心 (Erueka为例) 每隔30秒就会刷新一下服务的地址。\n Eureka设计 Eureka采用了CS的设计构架，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server中心并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否运行正常。\n当服务器(服务提供方)启动的时候，会把当前自己服务器的信息(服务地址、通信地址等)以别名的方式注册到注册中心上。另一方(服务消费方)以该别名的方式去注册中心上获取到实际的服务器通讯地址，然后再实现本地RPC调用远程RPC。调用框架核心在于注册中心，注册中心管理每个服务与服务间的依赖关系(服务治理)，也就是说，在任何RPC远程框架中，都会有一个注册中心。\n Eureka \n Eureka Server: 提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态一致(最终一致性) Service Provider: 服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到 Service Consumer: 服务消费方，从Eureka获取注册服务列表，从而能够消费服务  Eureka组件 Eureka包含两个组件：Eureka Server和Eureka Client\nEureka Server Eureka Server提供注册服务，各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表会储存所有可用服务节点的信息，服务节点的信息可在管理界面中直观的看到。\nEureka Server 同时也是一个Eureka Client 在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server 进行拉取注册表、服务注册和发送心跳等操作。\nEureka Client Eureka Client 可向注册中心进行访问来获取服务提供方通讯地址。在启动后，Eureka Client将会向Eureka Server发送心跳(默认间隔为30s)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server则会将该节点从服务器注册表中移除(默认90s)。\n服务提供方  启动后，向注册中心发起register请求，注册服务 在运行过程中，定时向注册中心发送renew心跳，证明\u0026quot;我还活着\u0026quot; 停止服务提供者，向注册中心发起cancel请求，清空当前服务注册信息  服务消费方  启动后，从注册中心拉取服务注册信息 在运行过程中，定时更新服务注册信息 发起向服务提供方远程调用时  ","date":"2020-03-14T03:28:00Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/","title":"[笔记]SpringCloud学习02: Eureka基础"},{"content":"dependencyManagement元素的使用 使用dependencyManagement元素能让所有在子项目中引用一个依赖而不用显式的列出版本号，Maven会沿父子层向上查找，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement中指定的版本号\n例如在父项目中:\n\u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 在子项目里:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 这样做的好处是，如果多个子项目都引用同一个依赖，则可以统一对子项目依赖进行管理版本\n 如果某个子项目需要另一个版本，那么只需要在那个子项目依赖中声明version即可\n \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.48\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   父项目中的dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显式声明需要用的依赖。  如果需要所有子项目都继承某个依赖，则需要在父项目中使用dependencies，需要注意的是dependencies要放在dependencyManagement上方   如果不在子项目中声明依赖，则不会从父项目中继承，只有在子项目中声明了依赖，且没有指定具体版本，才会从父项目中继承，并且version和scope都读取自父pom文件 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本   ","date":"2020-03-12T17:16:24Z","permalink":"https://chaosalphard.github.io/p/maven%E4%B8%ADdependencymanagement%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Maven中dependencyManagement元素的使用"},{"content":"建立项目 父工程的创建 IDEA: Create New Project -\u0026gt; Maven -\u0026gt; 输入groupid和artifactId -\u0026gt; 完成\n之后在IDEA设置中还有几个地方要设置:\n Build选项中的Compiler选项中的Annotation Processing目录中，在Enable annotation processing选项前打勾 Build选项中的Compiler选项中的Java Compiler目录中，将Target bytecode version 选为8 (可选)Editor选项中的File Types目录中，将*.iml;*.idea; 添加到Ignore files and patterns中，这是用于在IDEA资源管理器中隐藏对应后缀的文件  修改pom.xml文件，在version下添加\u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n\u0026lt;groupId\u0026gt;com.ilirus.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;irscloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 修改properties\n\u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;junit.version\u0026gt;4.12\u0026lt;/junit.version\u0026gt; \u0026lt;log4j.version\u0026gt;1.2.17\u0026lt;/log4j.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.16.18\u0026lt;/lombok.version\u0026gt; \u0026lt;mysql.version\u0026gt;8.0.14\u0026lt;/mysql.version\u0026gt; \u0026lt;druid.version\u0026gt;1.1.16\u0026lt;/druid.version\u0026gt; \u0026lt;mybatis.spring.boot.version\u0026gt;2.1.2\u0026lt;/mybatis.spring.boot.version\u0026gt; \u0026lt;/properties\u0026gt; 修改dependencies\n\u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- springboot 2.2.2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring cloud hoxton.SR1 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;Hoxton.SR1\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- spring cloud alibaba 2.1.0.RELEASE --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- alibaba --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${druid.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis.spring.boot.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${junit.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${log4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 修改build\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;addResources\u0026gt;true\u0026lt;/addResources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 最终pom.xml\n点击展开```xml 4.0.0 com.ilirus.springcloud irscloud 1.0-SNAPSHOT pom\n UTF-8 1.8 1.8 4.12 1.2.17 1.16.18 8.0.14 1.1.16 2.1.2     org.springframework.boot spring-boot-dependencies 2.2.2.RELEASE pom import   org.springframework.cloud spring-cloud-dependencies Hoxton.SR1 pom import   com.alibaba.cloud spring-cloud-alibaba-dependencies 2.1.0.RELEASE pom import   mysql mysql-connector-java ${mysql.version}   com.alibaba druid ${druid.version}   org.mybatis.spring.boot mybatis-spring-boot-starter ${mybatis.spring.boot.version}   junit junit ${junit.version}   log4j log4j ${log4j.version}   org.projectlombok lombok ${lombok.version} true       org.springframework.boot spring-boot-maven-plugin  true true      ```  之后在Maven Project窗口中的Lifcycle下执行install选项以检查是否正确\n子工程的创建 创建子工程module 在Project窗口中右键点击父工程，在弹出的菜单中选择New -\u0026gt; Module -\u0026gt; 在弹出的窗口中选择Maven -\u0026gt; 确认Add as module to和Parent皆为父工程，并输入artifactId -\u0026gt; 确认Nodule name(IDEA会自动去掉某些特殊符号) -\u0026gt; 完成\n返回父工程的pom.xml中，查看是否有modules元素\n\u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;child-project\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 配置子工程依赖 向子工程的pom.xml添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 最终pom.xml\n点击展开```xml  com.ilirus.springcloud irscloud 1.0-SNAPSHOT  4.0.0 irs-provider-payment8001\n  org.springframework.boot spring-boot-starter-web   org.springframework.boot spring-boot-starter-actuator   com.alibaba druid-spring-boot-starter 1.1.10   org.mybatis.spring.boot mybatis-spring-boot-starter   mysql mysql-connector-java   org.springframework.boot spring-boot-starter-jdbc   org.springframework.boot spring-boot-devtools   org.projectlombok lombok true   org.springframework.boot spring-boot-starter-test test    ```  编写application.yml 在子工程的src/main/resources目录下创建application.yml文件\n点击展开```yml server: port: 8001 # 端口 spring: application: name: child-project # 名称 datasource: type: com.alibaba.druid.pool.DruidDataSource # 数据源类型 driver-class-name: com.mysql.cj.jdbc.Driver # 数据库驱动包 url: jdbc:mysql://127.0.0.1:3306/irscloud?useSSL=false\u0026amp;characterEncoding=utf8\u0026amp;useUnicode=true username: \u0026hellip; password: \u0026hellip;\nmybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.ilirus.springcloud.entities # entity别名类所在的package\n\u0026lt;/details\u0026gt; ### 创建启动类 在子工程的`src/main/java/\u0026lt;groupId\u0026gt;`目录下创建对应的启动类 \u0026lt;details\u0026gt;\u0026lt;summary\u0026gt;点击展开\u0026lt;/summary\u0026gt;```java package com.ilirus.springcloud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\u0026quot;com.ilirus.springcloud.dao\u0026quot;) public class ChildProjectMain { public static void main(String[] args) { SpringApplication.run(ChildProject.class, args); } }  编写实体类 点击展开```java package com.ilirus.springcloud.entities; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable;\n@Data @AllArgsConstructor @NoArgsConstructor public class Payment implements Serializable { private Long id; private String serial; }\n 返回给前端的Result类 ```java package com.ilirus.springcloud.entities; import com.ilirus.springcloud.enums.Status; import org.jetbrains.annotations.Contract; import org.jetbrains.annotations.NotNull; public class CommonResult\u0026lt;T\u0026gt; { private Integer code; private String message; private T data; @NotNull @Contract(\u0026quot;_ -\u0026gt; new\u0026quot;) public static\u0026lt;T\u0026gt; CommonResult\u0026lt;T\u0026gt; Of(@NotNull Status status) { return new CommonResult\u0026lt;T\u0026gt;(status.getCode(), status.getMessage()); } @NotNull @Contract(\u0026quot;_, _ -\u0026gt; new\u0026quot;) public static\u0026lt;T\u0026gt; CommonResult\u0026lt;T\u0026gt; OfData(@NotNull Status status, T data) { return new CommonResult\u0026lt;T\u0026gt;(status.getCode(), status.getMessage(), data); } private CommonResult(Integer code, String message) { this(code, message, null); } private CommonResult(Integer code, String message, T data) { this.code = code; this.message = message; this.data = data; } public Integer getCode() { return this.code; } public String getMessage() { return this.message; } public T getData() { return this.data; } }  编写枚举类 点击展开```java package com.ilirus.springcloud.enums; import org.jetbrains.annotations.Contract;\npublic enum Status { SUCCESS(200,\u0026ldquo;sucess\u0026rdquo;), FAIL(400,\u0026ldquo;fail\u0026rdquo;), NO_DATA_FOUND(404,\u0026ldquo;not found\u0026rdquo;) ;\nprivate Integer code; private String message; Status(Integer code, String message) { this.code = code; this.message = message; } @Contract(pure = true) public Integer getCode() { return code; } @Contract(pure = true) public String getMessage() { return message; }  }\n\u0026lt;/details\u0026gt; ### 编写Dao \u0026lt;details\u0026gt;\u0026lt;summary\u0026gt;点击展开\u0026lt;/summary\u0026gt;```java package com.ilirus.springcloud.dao; import com.ilirus.springcloud.entities.Payment; import org.apache.ibatis.annotations.Param; import java.util.Optional; public interface PaymentDao { public Optional\u0026lt;Payment\u0026gt; getPaymentByID(@Param(\u0026quot;id\u0026quot;) Long id); public int createPayment(Payment payment); } mapper文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.ilirus.springcloud.dao.PaymentDao\u0026#34;\u0026gt; \u0026lt;resultMap id=\u0026#34;BaseResultMap\u0026#34; type=\u0026#34;com.ilirus.springcloud.entities.Payment\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34; jdbcType=\u0026#34;BIGINT\u0026#34;/\u0026gt; \u0026lt;id column=\u0026#34;serial\u0026#34; property=\u0026#34;serial\u0026#34; jdbcType=\u0026#34;VARCHAR\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getPaymentByID\u0026#34; parameterType=\u0026#34;Long\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select id, serial from payment where id=#{id} limit 1; \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026#34;createPayment\u0026#34; parameterType=\u0026#34;Payment\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; insert into payment(serial) values(#{serial}); \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt;  编写Service 点击展开```java package com.ilirus.springcloud.service; import com.ilirus.springcloud.entities.Payment; import org.apache.ibatis.annotations.Param;\npublic interface PaymentService { public Payment getPaymentByID(@Param(\u0026ldquo;id\u0026rdquo;) Long id);\npublic int createPayment(Payment payment);  }\n 实现类 ```java package com.ilirus.springcloud.service.impl; import com.ilirus.springcloud.dao.PaymentDao; import com.ilirus.springcloud.entities.Payment; import com.ilirus.springcloud.service.PaymentService; import org.springframework.stereotype.Service; import javax.annotation.Resource; @Service public class PaymentServiceImpl implements PaymentService { @Resource private PaymentDao paymentDao; @Override public Payment getPaymentByID(Long id) throws NullPointerException { return paymentDao.getPaymentByID(id).orElse(null); } @Override public int createPayment(Payment payment) { return paymentDao.createPayment(payment); } }  编写Controller 点击展开```java package com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import com.ilirus.springcloud.enums.Status; import com.ilirus.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.*;\nimport javax.annotation.Resource;\n@RestController @RequestMapping(\u0026quot;/payment\u0026quot;) @Slf4j public class PaymentController { @Resource private PaymentService paymentService;\n@PostMapping(\u0026quot;/create\u0026quot;) public CommonResult create(@RequestBody Payment payment) { int res = paymentService.createPayment(payment); log.info(\u0026quot;插入结果: \u0026quot;+res); if(res \u0026gt; 0) { return CommonResult.Of(Status.SUCCESS); } else { return CommonResult.Of(Status.FAIL); } } @GetMapping(\u0026quot;/query/{id}\u0026quot;) public CommonResult queryByID(@PathVariable(\u0026quot;id\u0026quot;) Long id) { Payment payment = paymentService.getPaymentByID(id); if(payment != null) { return CommonResult.OfData(Status.SUCCESS, payment); } else { return CommonResult.Of(Status.NO_DATA_FOUND); } }  }\n\u0026lt;/details\u0026gt; ### 编写测试 在子工程的`src/test/java/\u0026lt;groupId\u0026gt;`目录下创建对应的测试类 \u0026lt;details\u0026gt;\u0026lt;summary\u0026gt;点击展开\u0026lt;/summary\u0026gt;```java package com.ilirus.springcloud; import com.ilirus.springcloud.entities.Payment; import com.ilirus.springcloud.service.PaymentService; import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.annotation.Rollback; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.sql.SQLException; import java.time.Duration; @SpringBootTest class ChildProjectTest { @Resource PaymentService paymentService; @BeforeEach void echo() { System.out.println(\u0026quot;====Test Start====\u0026quot;); } @AfterAll static void done() { System.out.println(\u0026quot;====Test Done.====\u0026quot;); } @Test void checkQuery() { Payment payment = paymentService.getPaymentByID(1L); Assertions.assertNotNull(payment); } @Test @Transactional @Rollback void checkCreate() throws SQLException { Payment payment = new Payment(); payment.setSerial(\u0026quot;test\u0026quot;); int res = paymentService.createPayment(payment); System.out.println(res); Assertions.assertNotEquals(res, 0); Assertions.assertThrows(SQLException.class, () -\u0026gt; { ... }); Assertions.assertTimeout(Duration.ofSeconds(3), () -\u0026gt; { ... }); } }  提取子工程中的共同模块 再创建一个子工程，使你的父工程中目录下有两个子工程。\n再次创建一个子工程 按照之前的方式再创建一个子工程\n编写pom.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.ilirus.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;irscloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;artifactId\u0026gt;irs-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 提取共同模块 将另外两个子工程中共同的模块(entities/enums等)转移到此工程下\n运行maven clean install命令 运行maven clean install命令，同时检查是否有误\n修改原先的子工程 在子工程中引入通用包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.ilirus.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;irs-api-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在Run dashboard 中运行项目查看是否有误\n","date":"2020-03-12T00:55:33Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A001-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/","title":"[笔记]SpringCloud学习01: 项目的搭建"},{"content":"微服务是什么  　微服务是一种架构模式，它提倡将单一应用程序划分为一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务间采用轻量级的通信机制互相协作(例如基于HTTP协议的RESTful API)。\n每个服务都围绕具体业务进行构建，并能够独立的被部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。\n 微服务架构应满足哪些维度  服务的注册与发现 服务调用 服务熔断 负载均衡 服务降级 服务消息队列 配置中心管理 服务网关 服务监控 全链路追踪 自动化构建部署 服务定时任务调度操作  Spring Cloud 是什么  融合、协调、组装微服务相关技术，使构建分布式系统变更更容易。是分布式微服务架构的一种技术体现，是多种微服务架构落地技术的集合体。(微服务全家桶)\n Spring Cloud 版本命名规则 Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为管理Spring Cloud 与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud 版本对应的子项目版本。\n为避免Spring Cloud 的版本号与子项目版本号混淆，Spring Cloud 采用了英国伦敦地铁站的名称来命名，以字母A-Z的形式来发布迭代版本，也就是说Spring Cloud 是以字母作为版本号。\n当Spring Cloud 的发布内容累积到临界点或一个重大BUG被解决后，会发布一个service releases 版本，简称SR版本(SR1、SR2等)。\nSpring Cloud 和Spring Boot 的版本对应 在https://spring.io/projects/spring-cloud网页底部可查看SpringCloud和SpringBoot的版本对应关系\n SpringCloud和SpringBoot对应版本 \n更详细的依赖信息需要在https://start.spring.io/actuator/info中查讯\n在https://spring.io/projects/spring-cloud#learn页面中找到Spring Cloud 的Reference Doc在这个页面里可以找到官方推荐的Spring Boot版本\n","date":"2020-03-11T21:26:57Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A000-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8Espringcloud/","title":"[笔记]SpringCloud学习00: 微服务与SpringCloud"},{"content":"简单理解存储过程 存储过程是什么  存储过程(Stored Procedure) 是在数据库系统中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过调用存储过程并传递参数来执行它。\n  存储过程是用于特定操作的pl/sql语句块。 存储过程是预编译过的，经优化后存储在sql内存中，使用时无需再次编译，提高了使用效率。 存储过程的代码直接存放在数据库中，一般直接通过存储过程的名称调用，减少了网络流量，加快了系统执行效率。  存储过程与函数的区别  一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。 对于存储过程来说可以返回参数(output)，而函数只能返回值或者表对象。 存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM 关键字的后面。  存储过程的创建与调用 创建 CREATE[ORREPLACE]PROCEDUREprocedure_name(parameter1[model]datatype1,parameter2[model]datatype2..)IS[AS]BEGIN\u0026lt;PL/SQL\u0026gt;;END[procedure_name]; parameter用于指定参数，model用于指定参数模式，datatype用于指定参数类型。 定义存储过程的参数时，只能指定数据类型，不能指定数据长度。 IS/AS用于开始PL/SQL代码块。 创建存储过程时，既可以指定参数也可以不指定任何参数。  例如\ncreateprocedurepd_select_student_by_name(s_namenvarchar(20))isbeginselect*fromstudentwherestu_name=s_name;end;编译 ALTERPROCEDUREprocedure_nameCOMPILE调用 executeprocedure_name或者\nDECLAREparam1number;param2VARCHAR2(10):=\u0026#39;~Hello~\u0026#39;;BEGINprocedure_name(param1,param2);END;删除 DROPPROCEDUREprocedure_name;","date":"2019-10-05T14:00:50Z","permalink":"https://chaosalphard.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","title":"数据库存储过程"},{"content":"虽说Springboot的首选开发IDE是IntelliJ IDEA，然而对于老爷机来说IDEA太过庞大，对于因为某些原因而无法使用主力开发电脑时，使用VSCode来开发Springboot也不失为一个不错的选择。\n VSCode \n安装开发扩展 在商店中搜索Java Extension Pack 扩展，并安装。\n这是一个扩展包，VSCode 会自动安装关联的扩展：\n Cloudfoundry Manifest YML Support Concourse CI Pipeline Editor Debugger for Java Java Dependency Viewer Java Test Runner Language Support for Java(TM) by Red Hat Maven for Java   JavaExt \n在商店中搜索Spring Boot Extension Pack 扩展，并安装。\n这是一个扩展包，VSCode 会自动安装关联的扩展：\n Spring Boot Dashboard Spring Boot Tools Spring Initializr Java Support Visual Studio IntelliCode   MavenExt \n配置Java与Maven路径 打开VSCode的设置文件(setting.json)， 写入以下配置\n{ // java路径 \u0026#34;java.home\u0026#34;: \u0026#34;C:/Software/java11/jdk\u0026#34;, // maven配置文件路径 \u0026#34;java.configuration.maven.userSettings\u0026#34;: \u0026#34;C:/Software/maven-3.6.1/conf/settings.xml\u0026#34;, // 修改pom.xml后导入依赖的动作(automatic 为自动下载与导入) \u0026#34;java.configuration.updateBuildConfiguration\u0026#34;: \u0026#34;automatic\u0026#34;, // maven主程序路径 \u0026#34;maven.executable.path\u0026#34;: \u0026#34;C:/Software/maven-3.6.1/bin/mvn\u0026#34;, // 不显示在VSCode文件视图中的文件 \u0026#34;files.exclude\u0026#34;: { \u0026#34;**/.classpath\u0026#34;: true, \u0026#34;**/.project\u0026#34;: true, \u0026#34;**/.settings\u0026#34;: true, \u0026#34;**/.factorypath\u0026#34;: true, // 文件夹 \u0026#34;.mvn\u0026#34;: true, \u0026#34;.vscode\u0026#34;: true, \u0026#34;target\u0026#34;: true }, } 使用方式 按下F1，输入spring initializr，选择Generate a Maven Project选项即可。\n Init \n选中想要的插件按回车即可，结束选择的方式是选中Selected x dependencies选项，并按Enter键。\n Init \n配置启动项 在.vscode/launch.json文件中写入以下内容：\n\u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;java\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;DemoApplication\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;mainClass\u0026#34;: \u0026#34;com.example.springdemo.DemoApplication\u0026#34;, \u0026#34;projectName\u0026#34;: \u0026#34;springdemo\u0026#34; } ] 保存后再按下F5 即可启动项目。\n Start \nGradle也是类似的方式\n Start \n","date":"2019-10-03T20:36:06Z","permalink":"https://chaosalphard.github.io/p/vscode%E9%85%8D%E7%BD%AEspringboot%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","title":"VSCode配置Springboot开发环境"},{"content":"revert  git revert \u0026lt;commit\u0026gt;\n 生成一个撤消了commit 引入的修改的新提交，然后应用到当前分支。\ncommit 可以通过使用git log 来查看\nrevert 是提交一个 撤销了更改的 新提交，而不是从项目历史中移除这个提交。这会避免Git丢失项目历史，是一种比较安全的方式。\nreset  git reset\n 重设暂存区，但不改变工作区，匹配最近的一次提交。\n git reset --hard\n 重设暂存区和工作区，匹配最近的一次提交。\n--hard 会使git更改工作区中的文件。确定要扔掉本地的开发进度再使用。\n git reset \u0026lt;commit\u0026gt;\n 将暂存区重设到这个提交，但不改变工作区。\n所有commit 之后的更改会保留在工作区中，适用于重新提交更干净的项目历史。\n git reset --hard \u0026lt;commit\u0026gt;\n 将暂存区和工作区都重设到这个提交。\n git reset \u0026lt;file\u0026gt;\n 从暂存区移除某个文件，但不改变工作区。\nreset 和 revert  git revert 可以针对历史中任何一个提交，而 git reset 只能从当前提交向前回溯。比如，你想用 git reset 重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。\n revert被设计为撤销公开的提交的安全方式，reset被设计为重设本地更改。\n因为两个命令的目的不同，它们的实现也不一样：reset完全地移除了一堆更改，而revert保留了原来的更改，用一个新的提交来实现撤销。\n查看之前的内容 检出提交  git checkout \u0026lt;commit\u0026gt;\n 使用checkout commit 可以便捷地将commit 加载到电脑上。\n而且检出提交是一个只读操作，在查看其他commit的时候不会对你当前的状态(比如master分支)产生影响。\n在检出提交的时候，HEAD直接指向检出的提交。而不是指向分支。(分离HEAD)\n检出文件  git checkout \u0026lt;commit\u0026gt; \u0026lt;file\u0026gt;\n 会将工作区中的file文件变成commit中的那个文件，并将它加入暂存区。\n这会对你当前的工作区中的文件产生影响。\n参考资料  https://www.atlassian.com/git/tutorials/undoing-changes\n ","date":"2019-09-18T17:46:03Z","permalink":"https://chaosalphard.github.io/p/git%E6%8F%90%E4%BA%A4%E7%9A%84%E5%9B%9E%E6%BB%9A/","title":"Git提交的回滚"},{"content":"在Windows的UAC授权中增加密码验证 　通常情况下，当用户以管理员账户登录后，如果要进行某些需要管理员权限的操作(例如：为所有用户安装软件)，系统会弹出UAC(用户账户控制)弹窗，以向用户要求权限。\n普通用户需要输入管理员密码才可授予权限，而管理员账户只需点击 “是” 按钮即可授予权限。\n UAC \n　但是这样并不是很安全，所以我希望，即便是在管理员账户下，也需要进行密码验证。而且日常使用中，需要UAC授权的情况并不多见，所以增加密码验证这一步也并不会太影响日常使用。\n 以管理员账户登录，按下Win+R，输入gpedit.msc 以进入组策略编辑器 进入 计算机配置 -\u0026gt; Windows设置 -\u0026gt; 安全设置 -\u0026gt; 本地策略 -\u0026gt; 安全选项 选项卡 找到 用户账户控制：管理员批准模式中管理员的提升权限提示的行为 选项 将其属性更改为提示凭据 或者 在安全桌面上提示凭据 即可   UAC \n","date":"2019-09-11T23:50:21Z","permalink":"https://chaosalphard.github.io/p/%E5%9C%A8windows%E7%9A%84uac%E6%8E%88%E6%9D%83%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81/","title":"在Windows的UAC授权中增加密码验证"},{"content":" .content { width: 180px; height: 64px; margin: 0; padding: 0; border: none; background: transparent; position: relative; font-size: 24px; z-index: 0 } .result::before, .result::after { content: ''; position: absolute; top: -2px; bottom: -2px; left: -2px; right: -2px; } .result::before { border: 2px solid olive; animation: snake 4s linear infinite; } .result::after { border: 2px solid plum; animation: snake 4s linear infinite; animation-delay: -2s; } @keyframes snake { 0%, 100% { clip-path: inset(0 0 calc(100% - 2px) 0); } 25%{ clip-path: inset(0 0 0 calc(100% - 2px)); } 50%{ clip-path: inset(calc(100% - 2px) 0 0 0); } 75%{ clip-path: inset(0 calc(100% - 2px) 0 0); } }  成果展示 我是内容\n如果显示出现问题则说明你的浏览器不支持clip-path\n 浏览器支持:\n Chrome 55+ Firefox 54+   主要思路  使用伪元素实现一个大于目标元素的背景板.\n再使用clip-path将其裁剪到只剩上/下/左/右一个边.\n再使用animation实现动画效果.\n 实现过程 写一个普通的button\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .content { width: 180px; height: 64px; margin: 0; padding: 0; border: none; background: transparent; position: relative; font-size: 24px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button class=\u0026#34;content\u0026#34;\u0026gt;我是内容\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 加上::before\n.content::before { content: \u0026#39;\u0026#39;; position: absolute; top: -2px; bottom: -2px; left: -2px; right: -2px; background: olivedrab; border: 2px solid olive; z-index: -1; }  .st::before { content: ''; position: absolute; top: -2px; bottom: -2px; left: -2px; right: -2px; background: olivedrab; border: 2px solid olive; z-index: -1; }  我是内容\n使用clip-path裁剪\n.content::before { /* 上 */ clip-path: inset(0 0 calc(100% - 2px) 0); /* 右 */ clip-path: inset(0 0 0 calc(100% - 2px)); /* 下 */ clip-path: inset(calc(100% - 2px) 0 0 0); /* 左 */ clip-path: inset(0 calc(100% - 2px) 0 0); }  .block { display: block; } .st21::before { clip-path: inset(0 0 calc(100% - 2px) 0); } .st22::before { clip-path: inset(0 0 0 calc(100% - 2px)); } .st23::before { clip-path: inset(0 calc(100% - 2px) 0 0); } .st24::before { clip-path: inset(calc(100% - 2px) 0 0 0); }  我是内容 我是内容 我是内容 我是内容\n使用animation实现动画效果\n.content::before { content: \u0026#39;\u0026#39;; position: absolute; top: -2px; bottom: -2px; left: -2px; right: -2px; background: olivedrab; border: 2px solid olive; z-index: -1; animation: snake 10s linear infinite; } @keyframes snake { 0%, 100% { clip-path: inset(0 0 calc(100% - 2px) 0); } 25%{ clip-path: inset(0 0 0 calc(100% - 2px)); } 50%{ clip-path: inset(calc(100% - 2px) 0 0 0); } 75%{ clip-path: inset(0 calc(100% - 2px) 0 0); } }  .st1::before { animation: snake 10s linear infinite; }  我是内容\n去掉伪元素的背景\n.content { width: 180px; height: 64px; margin: 0; padding: 0; border: none; background: transparent; position: relative; font-size: 24px; } .content::before { content: \u0026#39;\u0026#39;; position: absolute; top: -2px; bottom: -2px; left: -2px; right: -2px; } .content::before { border: 2px solid olive; animation: snake 4s linear infinite; } @keyframes snake { 0%, 100% { clip-path: inset(0 0 calc(100% - 2px) 0); } 25%{ clip-path: inset(0 0 0 calc(100% - 2px)); } 50%{ clip-path: inset(calc(100% - 2px) 0 0 0); } 75%{ clip-path: inset(0 calc(100% - 2px) 0 0); } }  .content3 { width: 180px; height: 64px; margin: 0; padding: 0; border: none; background: transparent; position: relative; font-size: 24px; } .content3::before { content: ''; position: absolute; top: -2px; bottom: -2px; left: -2px; right: -2px; } .content3::before { border: 2px solid olive; animation: snake 4s linear infinite; }  我是内容\n再使用::after 伪元素添加一个新的边框，再使用animation-delay 错开动画时间\n我是内容\n","date":"2019-08-27T02:27:56Z","permalink":"https://chaosalphard.github.io/p/css%E8%9B%87%E5%BD%A2%E8%BE%B9%E6%A1%86/","title":"CSS蛇形边框"},{"content":"CSS样式的处理 安装css-loader和style-loader\nyarn add css-loader style-loader -D 在index.js中引入.css文件\nrequire(\u0026#39;./index.css\u0026#39;) 在webpack.config.js中配置css模块\nmodule.exports = { mode: \u0026#39;development\u0026#39;, entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#39;bundle.[hash:4].js\u0026#39;, path: path.resolve(__dirname, \u0026#39;dist\u0026#39;) }, devServer: { // ...  }, plugins: [ // ...  ], // 模块  module: { // 规则  rules: [ { // 匹配.css 结尾的文件  test: /\\.css$/, // 可用字符串, 也可用对象  // loader的顺序默认是从 右往左/下到上 执行  // css-loader, 解析@import语法  // style-loader, 把css 插入到head标签中  use: [ { loader: \u0026#39;style-loader\u0026#39;, options: { // 在顶部插入  insertAt: \u0026#39;top\u0026#39; } }, \u0026#39;css-loader\u0026#39; ] }, {// 也可以处理less文件  test: /\\.less$/, use: [ { loader: \u0026#39;style-loader\u0026#39;, options: { // 在顶部插入  insertAt: \u0026#39;top\u0026#39; } }, \u0026#39;css-loader\u0026#39;, // @import 解析  \u0026#39;less-loader\u0026#39; // .less -\u0026gt; .css  ] } ] } } ","date":"2019-08-05T22:24:12Z","permalink":"https://chaosalphard.github.io/p/webpack%E4%B8%ADcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/","title":"Webpack中CSS样式的处理"},{"content":"Git常用指令 git init: 为当前文件夹初始化Git仓库\ngit status: 查看状态(modified, untracked)\ngit add \u0026lt;file|path\u0026gt;: 添加指定文件/文件夹到暂存区(staging index)\ngit commit: 提交暂存区的文件到版本库\ngit commit -m 'msg': 提交暂存区的文件到版本库\ngit commit -am 'msg': 跳过git add步骤，直接提交所有工作区(working directory)已追踪文件\ngit log: 查看提交信息/记录\nGit的三层结构  working directory: 工作区 staging index: 暂存区 git directory: 版本库  Git文件的四种状态  Untracked: 未被追踪 Modified: 已被修改，但未添加到暂存区 Staged: 添加到了暂存区，但未提交到版本库 Committed: 数据被储存在本地库中  ","date":"2019-08-03T20:44:37Z","permalink":"https://chaosalphard.github.io/p/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","title":"Git常用指令"},{"content":"Webpack配置HTML template 安装html-webpack-plugin\nyarn add html-webpack-plugin -D :: or npm install html-webpack-plugin -D 配置webpack\n// 引入html-webpack-plugin模块 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) module.exports = { mode: \u0026#39;development\u0026#39;, entry: \u0026#39;./src/index.js\u0026#39;, output: { // bundle.[hash].js: 给打包的文件追加hash  // 可指定长度: [hash:\u0026lt;length\u0026gt;]  filename: \u0026#39;bundle.[hash:4].js\u0026#39;, path: path.resolve(__dirname, \u0026#39;dist\u0026#39;) }, devServer: { port: 3000, progress: true, contentBase: \u0026#39;./dev\u0026#39;, compress: true }, // 插件  plugins: [ new HtmlWebpackPlugin({ // 模版文件路径  template: \u0026#39;./src/index.html\u0026#39;, // 打包后的文件名字  filename: \u0026#39;index.html\u0026#39;, minify: { // 去除html中的双引号  removeAttributeQuotes: true, // 合并为一行  collapseWhitespace: true, }, // 给打包的文件加上hash戳  // \u0026lt;script src=bundle.js?5c5c6o9e\u0026gt;\u0026lt;/script\u0026gt;  hash: true }) ] } 创建index.html文件\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- template --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2019-08-03T19:25:57Z","permalink":"https://chaosalphard.github.io/p/webpack%E9%85%8D%E7%BD%AEhtml-template/","title":"Webpack配置HTML Template"},{"content":"删除所有提交记录 一种比较取巧的方法\n 新建分支 git checkout --orphan latest_branch 添加所有文件 git add -A 提交更改 git commit -am \u0026quot;merge commit\u0026quot; 删除分支 git branch -D master 重命名当前分支 git branch -m master 强制更新存储库 git push -f origin master  ","date":"2019-07-14T19:11:26Z","permalink":"https://chaosalphard.github.io/p/%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89git%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95/","title":"删除所有Git提交记录"},{"content":" webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n 安装Webpack :: 初始化 yarn init :: 安装webpack 和 webpack-cli :: -D表示是开发依赖, 上线时不需要 yarn add webpack webpack-cli -D 配置Webpack  从 Webpack v4.0.0 开始，可以不用引入配置文件。然而，webpack 仍然还是高度可配置的。\nWebpack 默认配置文件名为 webpack.config.js或webpackfile.js。\n也可以在启动时使用 \u0026ndash;config 参数指定配置文件名称\n // 引入path模块 (自带, 无需安装) const path = require(\u0026#39;path\u0026#39;) // 导出配置模块 module.exports = { // 打包模式 默认有两种 production|development  // production: 生产模式  // development: 开发模式  mode: \u0026#39;development\u0026#39;, // 入口文件  entry: \u0026#39;./src/index.js\u0026#39;, // 输出  output: { // 打包后的文件名  filename: \u0026#39;bundle.js\u0026#39;, // 打包后的路径 (要求必须是绝对路径)  path: path.resolve(__dirname/*指当前路径*/, \u0026#39;dist\u0026#39;/*指打包到的文件夹名称*/) }, // 开发服务器的配置  devServer: { // 端口  port: 3000, // 打包进度  progress: true, // 打包后文件的放置位置  contentBase: \u0026#39;./dev\u0026#39;, // 启用压缩  compress: true } } Webpack打包指令 :: 因为安装在devDependencies 中, 所以需要用npx 来执行 npx webpack Webpack打包后的文件 Webpack 打包后的是一个自执行函数(IIFE), 该函数接收一个对象作为参数:\n(function(modules) { // ... }) ({ // key: 模块的路径  \u0026#34;./src/index.js\u0026#34;: // value: 函数  (function(module, exports, __webpack_require__) { eval(\u0026#34;const str = __webpack_require__(/*! ./str.js */ \\\u0026#34;./src/str.js\\\u0026#34;)\\r\\n\\r\\nconsole.log(`Hello ${str}`)\\n\\n//# sourceURL=webpack:///./src/index.js?\u0026#34;); }), \u0026#34;./src/str.js\u0026#34;: (function(module, exports) { eval(\u0026#34;module.exports = \u0026#39;World\u0026#39;\\n\\n//# sourceURL=webpack:///./src/str.js?\u0026#34;); }) }) 函数内的实现\n// webpackBootstrap // webpack 启动函数 (function(modules) { // The module cache  // module 缓存  var installedModules = {}; // The require function  // 配置/实现require 方法  // (moduleId = \u0026#34;./src/index.js\u0026#34;)  function __webpack_require__(moduleId) { // Check if module is in cache  // 检查module是否有缓存  if(installedModules[moduleId]) { return installedModules[moduleId].exports; } // Create a new module (and put it into the cache)  // 创建module  var module = installedModules[moduleId] = { i: moduleId, l: false, exports: {} }; // Execute the module function  // 从module中的id(key), 找到value(函数), 用过call()来执行函数  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded  // 将module 标记为已加载(loaded)  module.l = true; // Return the exports of the module  // 返回module 的导出  return module.exports; } // expose the modules object (__webpack_modules__)  __webpack_require__.m = modules; // expose the module cache  __webpack_require__.c = installedModules; // define getter function for harmony exports  __webpack_require__.d = function(exports, name, getter) { if(!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; // define __esModule on exports  __webpack_require__.r = function(exports) { if(typeof Symbol !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#39;Module\u0026#39; }); } Object.defineProperty(exports, \u0026#39;__esModule\u0026#39;, { value: true }); }; // create a fake namespace object  // mode \u0026amp; 1: value is a module id, require it  // mode \u0026amp; 2: merge all properties of value into the ns  // mode \u0026amp; 4: return value when already ns object  // mode \u0026amp; 8|1: behave like require  __webpack_require__.t = function(value, mode) { if(mode \u0026amp; 1) value = __webpack_require__(value); if(mode \u0026amp; 8) return value; if((mode \u0026amp; 4) \u0026amp;\u0026amp; typeof value === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; value \u0026amp;\u0026amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, \u0026#39;default\u0026#39;, { enumerable: true, value: value }); if(mode \u0026amp; 2 \u0026amp;\u0026amp; typeof value != \u0026#39;string\u0026#39;) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key)); return ns; }; // getDefaultExport function for compatibility with non-harmony modules  __webpack_require__.n = function(module) { var getter = module \u0026amp;\u0026amp; module.__esModule ? function getDefault() { return module[\u0026#39;default\u0026#39;]; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, \u0026#39;a\u0026#39;, getter); return getter; }; // Object.prototype.hasOwnProperty.call  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // __webpack_public_path__  __webpack_require__.p = \u0026#34;\u0026#34;; // Load entry module and return exports  // 入口模块  return __webpack_require__(__webpack_require__.s = \u0026#34;./src/index.js\u0026#34;); }) ","date":"2019-06-21T23:22:15Z","permalink":"https://chaosalphard.github.io/p/webpack%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"Webpack的安装与配置"},{"content":"假设要用JavaScript实现一个阶乘函数，很容易想到用递归实现:\nfunction factorial(n) { if(n === 1) { return 1 } return n * factorial(n-1) } console.log(factorial(4)) // 24 在上述代码中，由于最后一步返回了一个表达式(n * factorial(n-1))，所以会保留n这个变量和函数factorial(n-1)的调用位置等信息，从而形成一层层的调用帧。\n递归十分消耗内存，因为要同时保存非常多个调用记录，容易出现\u0026quot;栈溢出\u0026quot;错误(Stack Overflow)\n尾调用 尾调用是指的一个函数的最后一个动作是返回另一个函数的调用\nfunction foo(n) { return meh(n) } // 并不一定要在函数尾部，只要是最后一步操作即可 // 以下meh 和nco 函数均属于尾调用 function foo(n) { if(n\u0026gt;0) { return meh(n) } return nco(n) } 不属于尾调用的情况\n// 函数调用后还有赋值操作，所以不属于尾调用，即使语义一样 function foo(n) { let tmp = meh(n) return tmp } // 函数调用后还有相加操作 function foo(n) { return meh(n) + 1 } // 没有返回函数调用 function foo(n) { meh(n) } 尾调用优化  　函数调用会在内存形成一个\u0026quot;调用记录\u0026quot;，又称\u0026quot;调用帧\u0026quot; (call frame)，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个\u0026quot;调用栈\u0026quot; (call stack)。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n 举例:\nfunction getItem(item) { return item } function foo() { let a=1 let b=2 return getItem(a+b) } foo() 上述代码中，如果函数getItem不是尾调用，函数foo就要保存内部变量m和n的值，以及函数getItem的调用位置等信息。\n但如果调用getItem后，函数foo就结束了，所以执行到最后一步，可以删除foo的调用帧，只保留getItem(3)的调用帧。\n \u0026ldquo;尾调用优化\u0026rdquo; (Tail call optimization)，即只保留内层函数的调用帧。\nPS: 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行\u0026quot;尾调用优化\u0026quot;。\n 尾递归 函数调用自身，称为递归；如果尾调用自身，就称为尾递归。\n 对于尾递归来说，由于只存在一个调用帧，所以能有效的避免\u0026quot;栈溢出\u0026quot;错误的发生。\n \"尾调用优化\"对递归操作意义重大，所以ES6也明确规定了，所有`ECMAScript`的实现，都必须部署\"尾调用优化\"。 -- 改写之前的代码:\nfunction factorial(n,total) { \u0026#34;use strict\u0026#34; total = total || 1 if(n \u0026lt;= 1) return total return factorial(n-1, n*total) } ES6的尾调用优化只在严格模式下开启，正常模式是无效的\n在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n arguments: 返回调用时函数的参数。 caller: 返回调用当前函数的那个函数。  尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\n参考:\n https://github.com/tc39/proposal-ptc-syntax/blob/master/README.md\n 补充(2019.06.02): 出于某些因素的考虑，目前V8引擎中的尾递归优化已经被去掉了\n大概原因可以看这篇博客:\n https://imweb.io/topic/5a244260a192c3b460fce275\n 尾递归优化的实现 正常模式下如何实现尾递归优化呢?\nfunction sum(x,y) { if (y \u0026gt; 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1,100000) 尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。\nfunction tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function sum(x,y) { if (y \u0026gt; 0) { return sum(x + 1, y - 1); } else { return x; } }) sum(1,100000) ","date":"2019-06-01T15:29:46Z","permalink":"https://chaosalphard.github.io/p/es6%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/","title":"ES6中的尾递归"},{"content":"Vue Router 的基本用法 安装Vue路由 vue add @vue/router :: 或者 npm install vue-router -S yarn add vue-router 引入路由 写在main.js文件中\n// 引入Router import Router from \u0026#39;vue-router\u0026#39;; // 引入路由跳转的组件 import Home from \u0026#39;./components/Home\u0026#39;; // 配置Router const router = new VueRouter({ // 路由模式 (hash | history | abstract(如果没有发现浏览器API, 会自动进入此模式))  // 使用history模式可以去掉地址栏的\u0026#39;#\u0026#39;字符, 但需要后端配置支持  // history 模式利用window.history API 来完成页面的跳转而无需重新加载页面  mode: \u0026#39;history\u0026#39;, base: process.env.BASE_URL, routes: [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: () =\u0026gt; import(\u0026#39;./views/About.vue\u0026#39;) } ] }) // 使用Router Vue.use(Router) new Vue({ router: router, render: function(h) { return h(App) } }).$mount(\u0026#39;#app\u0026#39;) 写在template中\n\u0026lt;template\u0026gt; \u0026lt;!-- 使用路由名称跳转 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;home\u0026#39;}\u0026#34;\u0026gt;主页\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;about\u0026#39;}\u0026#34;\u0026gt;关于\u0026lt;/router-link\u0026gt; \u0026lt;!-- 直接指定跳转路径 --\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;主页\u0026lt;/router-link\u0026gt; \u0026lt;/template\u0026gt; 也可将Router配置抽离到单独的js文件中\nexport default new VueRouter({ mode: \u0026#39;history\u0026#39;, base: process.env.BASE_URL, routes: [ { // 路径  path: \u0026#39;/\u0026#39;, // 名称  name: \u0026#39;home\u0026#39;, // 挂载的组件  component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, // 懒加载  component: () =\u0026gt; import(\u0026#39;./views/About.vue\u0026#39;), // 子路由  children: [{ path: \u0026#39;concat\u0026#39;, name: \u0026#39;concat\u0026#39;, component: Concat },{ path: \u0026#39;guide\u0026#39;, name: \u0026#39;guide\u0026#39;, component: Guide, // 子路由下的子路由  children: [ // ...  ] }], redirect: {name: \u0026#39;concat\u0026#39;} }, { // 匹配所有(上面没有匹配到的)  path: \u0026#39;*\u0026#39;, // 重定向  redirect: \u0026#39;/error/notfound\u0026#39; } ] }) 动态路由匹配 使用: 标记路径参数，当匹配到一个路由时，参数值会被设置到this.$route.params，以便在组件内使用。\nconst router = new Router({ routes: [{ path: \u0026#39;/user/:id\u0026#39;, component: User }] }) 可以设置多段路径参数\n   路由设置 匹配路径 Params     /user/:id /user/233 {id: \u0026lsquo;233\u0026rsquo;}   /user/:id/name/:name /user/233/name/ilirus {id: \u0026lsquo;233\u0026rsquo;, name: \u0026lsquo;ilirus\u0026rsquo;}    当使用路径参数时, 例如/user/233到/user/450, 原来的组件实例会被复用, 这导致组件的生命周期钩子不会被调用\n所以应该对$router监测变化(watch)，或者使用导航守卫\nwatch: { \u0026#39;$route\u0026#39; (to, from) { // ...  } } beforeRouteUpdate(to, from, next) { // ... } 高级匹配模式 vue-router使用path-to-regexp作为路径匹配引擎，所以支持更高级的匹配模式。\nconst router = new Router({ routes: [ // 使用?来将参数定义为可选项  {path: \u0026#39;/optional/:para?\u0026#39;}, {path: \u0026#39;/optional/(:para/)?name\u0026#39;} // 使用正则来实现仅匹配数字  {path: \u0026#39;/number/:id(\\\\d+)\u0026#39;} ] }) 在JavaScript中进行路由跳转 router.push() router.push(location, onComplete?, onAbort?)\n此方法会向history 栈添加一个新记录, 所以当用户点击后退按钮时，会返回到之前的URL\n此方法接收一个字符串路径，或者一个描述地址的对象作为参数\n// 字符串 router.push(\u0026#39;/user\u0026#39;) // 对象 router.push({path: \u0026#39;/user\u0026#39;}) router.push({name: \u0026#39;user\u0026#39;}) // 带参数 // -\u0026gt; /user/233 router.push({name: \u0026#39;user\u0026#39;, params: {id: \u0026#39;233\u0026#39;}}) // -\u0026gt; /user?id=233 router.push({name: \u0026#39;user\u0026#39;, query: {id: \u0026#39;233\u0026#39;}}) // 如果提供了path, 那么param会被忽略, query则不会 // -\u0026gt; /user/233 router.push({path: \u0026#39;/user/233\u0026#39;}) // -\u0026gt; /user router.push({path: \u0026#39;/user\u0026#39;, params: {id: \u0026#39;233\u0026#39;}}) // -\u0026gt; /user?id=233 router.push({path: \u0026#39;user\u0026#39;, params: {id: \u0026#39;233\u0026#39;}}) onComplete和onAbort 回调函数会在导航成功完成(在所有的异步钩子被解析之后) 或者终止(导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行调用\nrouter.replace() router.replace(location, onComplete?, onAbort?)\n此方法会替换掉当前的history 记录, 所以当用户点击后退按钮时，不会返回到之前的URL\n其余用法同router.push()方法\nrouter.go() router.go(n)\n此方法接收一个整数作为参数，意为在history 记录中前进多少步\n// 前进一步 router.go(1) // 后退一步 router.go(-1) // 前进十步, 如果记录不足, 则不会跳转 router.go(10) 视图命名 可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。\n如果 router-view 没有设置名字，那么默认为 default。\n\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view name=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; const router = new Router ({ routes: [{ path: \u0026#39;/\u0026#39;, components: { default: Nav, main: Main } }] }) 导航守卫  参数或查询的改变并不会触发 进入/离开 的导航守卫。可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。\n 全局前置守卫 const router = new Router({ ... }) // 全局前置守卫 // to: 即将要进入的目标路由 // from: 正要离开的路由 // next: 放行, 不调用next方法则不会进入目标路由, 根据参数的不同, 效果也不同 // next(): 进行管道中的下一个钩子, 如果全部钩子执行完了, 则导航的状态就是confirmed // next(false): 中断当前的导航, 如果浏览器的URL改变了, 会重置到from路由对应的地址 // next(\u0026#39;/\u0026#39;) | next({path: \u0026#39;/\u0026#39;}): 跳转到另一个地址, 会使当前的导航被中断, 然后进行一个新的导航 // next(Error): 导航会被终止, 且会触发router.onError() router.beforeEach((to, from, next) =\u0026gt; { // ... }) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前会一直处于等待中。\n全局后置钩子 此方法不接收next()函数也不会改变导航本身\nconst router = new Router({ ... }) router.afterEach((to, from) =\u0026gt; { // ... }) 路由独享守卫 用法与全局前置守卫相同\nconst router = new Router({ routes: [{ path: \u0026#39;/home\u0026#39;, component: Home, beforeEnter: (to, from, next) =\u0026gt; { // ...  } }] }) 组件内的守卫 可以在路由组件内直接定义这些路由导航守卫\n// 在渲染该组件的对应路由被 confirm 前调用 // 不能 获取组件实例 this, 因为当守卫执行前，组件实例还没被创建 beforeRouteEnter(to, from, next) { // ... }, // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 this beforeRouteUpdate(to, from, next) { // ... }, // 导航离开该组件的对应路由时调用 // 可以访问组件实例 this // 通常用来阻止用户在还未保存修改前突然离开 // 该导航可以通过 next(false) 来取消 beforeRouteLeave(to, from, next) { // ... } beforeRouteEnter 不能访问到this, 但可以通过给next()传递回调来访问组件实例, 且只有beforeRouteEnter方法支持给next()函数传递回调\nbeforeRouteEnter(to, from, next) { next(vm =\u0026gt; { // ...  }) }, 过渡动效 使用transition组件给router-view添加一些过渡效果\n\u0026lt;transition name=\u0026#34;slide\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt; 也可以动态设置过渡效果\n\u0026lt;transition :name=\u0026#34;transitionType\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/transition\u0026gt; watch: { \u0026#39;$route\u0026#39; (to, from) { const toDepth = to.path.split(\u0026#39;/\u0026#39;).length const fromDepth = from.path.split(\u0026#39;/\u0026#39;).length this.transitionType = toDepth \u0026lt; fromDepth ? \u0026#39;slide-right\u0026#39; : \u0026#39;slide-left\u0026#39; } } ","date":"2019-01-25T00:10:10Z","permalink":"https://chaosalphard.github.io/p/vue-router%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"Vue Router的安装与使用"},{"content":"使用Vue-cli搭建Vue项目 安装Vue-cli 在安装Vue-cli之前需要先安装node环境以及npm包管理工具\n安装好之后可以通过以下命令查看版本\n:: 查看node版本 node -v :: 查看npm版本 npm -v 全局安装Vue-cli\nnpm install @vue/cli -g :: 或者 yarn global add @vue/cli 安装后使用vue --version来查看版本\n运行以下命令在当前文件夹下创建一个项目\n:: 命令行创建项目 vue create \u0026lt;projectName\u0026gt; :: 使用可视化项目创建工具 vue ui 创建完成后，进入到刚才创建的文件夹下，运行npm run serve即可启动项目\n项目结构 \u0026lt;projectName\u0026gt; ├─node_modules ├─public │ └─index.html ├─src │ ├─assets │ ├─components │ ├─App.vue │ └─main.js └package.json  package.json 用于记录项目依赖的库 assets 用于存放静态资源，比如图片 components 用于存放组件 App.vue 根组件 main.js 项目入口脚本  写一个Hello World 写在vue文件中\n\u0026lt;!-- 模板: html结构 --\u0026gt; \u0026lt;!-- template中有且只能有一个根元素 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 行为: 逻辑处理 --\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;app\u0026#39;, data() { return {msg: \u0026#39;Hello World\u0026#39;} } } \u0026lt;/script\u0026gt; \u0026lt;!-- 样式: 样式表 --\u0026gt; \u0026lt;!-- 加入scope关键词代表样式仅作用于当前组件中 --\u0026gt; \u0026lt;!-- \u0026lt;style scope\u0026gt;\u0026lt;/style\u0026gt; --\u0026gt; \u0026lt;style\u0026gt; #app { text-align: center; color: #2c3e50; } \u0026lt;/style\u0026gt; 写在main.js中\n// 引入Vue import Vue from \u0026#39;vue\u0026#39; // 引入根组件 import App from \u0026#39;./App.vue\u0026#39; // 阻止Vue在启动时生成生产提示 Vue.config.productionTip = false // 实例化Vue对象 new Vue({ render: function(h) { return h(App) } }).$mount(\u0026#39;#app\u0026#39;) // 也可使用以下方式 new Vue({ el: \u0026#39;#app\u0026#39;, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, components: { App } }) 创建并使用自己的组件 在/src/components目录下创建.vue文件，注册之后在.vue文件中可以使用\u0026lt;compName/\u0026gt;或\u0026lt;compName\u0026gt;\u0026lt;/compName\u0026gt;的形式来使用组件\n全局注册组件 在main.js中注册组件\n// 引入组件 import compName from \u0026#39;./components/compName\u0026#39; // 全局注册组件 Vue.component(\u0026#34;compName\u0026#34;, compName) 局部注册组件 在要注册组件的.vue文件中\n\u0026lt;script\u0026gt; // 引入组件 import compName from \u0026#39;./components/compName.vue\u0026#39; export default { name: \u0026#39;app\u0026#39;, data() { return {msg: \u0026#39;Hello World\u0026#39;} }, //局部注册组件  components: { \u0026#39;compName\u0026#39;: compName } } \u0026lt;/script\u0026gt; 组件间的传值(props) 父组件向子组件传值 父组件中给子组件绑定属性值\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;compName v-bind:msg=\u0026#34;msg\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;app\u0026#39;, data() { return { msg: \u0026#34;Hello World\u0026#34; } }, components: { HelloWorld } } \u0026lt;/script\u0026gt; 在子组件中获取\n\u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, props: { msg: String, default: \u0026#39;Def\u0026#39; // 默认值  } } \u0026lt;/script\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, props: { msg: { type: String, required: true //required 为true 表示这个参数必须被传入  } } } \u0026lt;/script\u0026gt; 子组件向父组件传值 子组件中注册事件\nmethods:{ foo() { this.$emit(ctmEvent,trsValue) } } ctmEvent即为注册的事件名称\ntrsValue即为向父组件传递的值\n父组件中绑定事件\n\u0026lt;compName v-on:ctmEvent=\u0026#34;fun($event)\u0026#34; /\u0026gt; 父组件中绑定事件后，当子组件触发事件后，会执行对应的函数，使用$event 来获取到子组件传递过来的值\n定义函数来处理子组件传递过来的值，这里的para对应的是$event\nfun(para) { this.title = para } 组件的生命周期(钩子函数) export default { name: \u0026#39;app\u0026#39;, data() { ... }, methods: { ... }, // 组件实例化之前  // 数据观测(data observer)和event/watcher 事件配置之前被调用  beforeCreate() {}, // 组件实例化完毕, 但页面还没显示  // 实例创建完成后立即被调用, 数据观测(data observer)和event/watcher 已配置, $el属性不可见  created() {}, // 组件挂载之前, 页面依然未显示, (但虚拟Dom 已经配置 (存疑))  // 在挂载前被调用, 相关render 函数首次被调用  beforeMount() {}, // 组件挂载后, 此方法执行完成后, 页面显示  // el 被新创建的vm.$el替换并挂载到实例上之后调用  mounted() {}, // 组件更新前调用(此时仍然可以访问到更新前的Dom)  beforeUpdate() {}, // 组件更新后调用(Dom 更新后调用)  updated() {}, // keep-alive 组件激活时调用  activated() {}, // keep-alive 组件停用时调用  deactivated() {} // 组件销毁前  beforeDestroy() {}, // 组件销毁  destroyed() {}, // 捕获来自子组件的错误时调用  // 可以返回false 以阻止错误继续向上传播  errorCaptured(Error, Component, InfoString) { return false } } ","date":"2018-12-10T12:20:20Z","permalink":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8vue-cli%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/","title":"使用Vue-cli搭建Vue项目"},{"content":"Kotlin中的类 类 伴生对象 由于Kotlin没有静态方法，在大多数情况下，官方建议简单地使用包级函数。\n如果需要一个可以无需类实例来调用，但需要访问类内部的函数。\n可以把它写成一个用companion修饰的对象内方法。\ncompanion修饰的对象为伴生对象。\ncompanion object { fun isEmpty(str: String): Boolean { return \u0026#34;\u0026#34; == str } } 单例类 伴生对象更多的用途是用来创建一个单例类。\n如果只是简单的写法，直接用伴生对象返回一个val修饰的外部类对象就可以了，\n但是更多的时候我们希望在类被调用的时候才去初始化他的对象。\n以下代码将线程安全问题交给虚拟机在静态内部类加载时处理:\nclass Single private constructor() { companion object { fun get():Single{ return Holder.instance } } private object Holder { val instance = Single() } } 动态代理 Kotlin原生支持动态代理:\ninterface Animal{ fun bark() } class Dog :Animal { override fun bark() { println(\u0026#34;Wang Wang\u0026#34;) } } class Cat(animal: Animal) : Animal by animal { // ... } fun main(args: Array\u0026lt;String\u0026gt;) { Cat(Dog()).bark() } 伪多继承 Kotlin 的动态代理更多的是用在一种需要多继承的场景。\n使用一个代理类实现所有需要获取信息的接口方法。然后让不同的子类去实现所需的接口，请求统一交给代理类完成。\n这样不仅维护网络请求信息方便，而且每个类不会有额外多出来的方法。\n还是用猫狗来举例:\ninterface Animal{ fun bark() } interface Food{ fun eat() } class Delegate : Animal, Food { override fun eat() { println(\u0026#34;mouse\u0026#34;) } override fun bark() { println(\u0026#34;Nyan\u0026#34;) } } class Cat(animal: Animal, food: Food) : Animal by animal, Food by food { // ... } @JvmStatic fun main(args: Array\u0026lt;String\u0026gt;) { val delegate: Delegate = Delegate() Cat(delegate, delegate).bark() } ","date":"2018-12-08T20:02:20Z","permalink":"https://chaosalphard.github.io/p/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/","title":"Kotlin学习笔记03"},{"content":"Kotlin基本语法 变量、常量的定义 [修饰符] \u0026lt;var|val\u0026gt; \u0026lt;名称\u0026gt; : \u0026lt;类型\u0026gt; = \u0026lt;赋值\u0026gt;\n//var 代表变量，可被更改 var age: Int = 18 //val 代表常量, 定义后不能被修改, 定义时必须赋值 val name: String = \u0026#34;Ilirus\u0026#34; 基本数据类型 var boolean:Boolean = false var char:Char = \u0026#39;a\u0026#39; var byte:Byte = 127 var short:Short = 32767 var int:Int = 2147483647 var long:Long = 9223372036854775807 var float:Float = 2.33f var double:Double = 3.1415926 类型检测与自动转换 fun getStrLength(o: Any): Int { if(o is String){ //进行类型判断后, o会自动被转换为String类型  return o.length } return 0 } 返回空值与空值检测 如果引用或函数的返回值可能为空值，则必须显式标记nullable\n//在类型后面加上一个问号, 表示这个对象可能为空 //用两个感叹号表示一定不为空 fun getStuName(stu: Any?): String? { if(stu!=null){ return stu.getName } return null } Kotlin的空值检测能有效的避免NPE(NullPointException) 的出现\n例如这句代码student?.getName()，只会在student不为空时执行\n相反，这句代码student?:student=Student()，只会在student为空时执行\n如果要执行代码块的话，可以这样写\n//data不为空执行 data?.let{ // do something } //data为空执行 data?:let{ // do something } //或者  //data不为空执行 data?.run{ // do something } //data为空执行 data?:run{ // do something } run与let val str:String = \u0026#34;Ilirus\u0026#34; str?.let{ println(it) } str?.let{ s -\u0026gt; println(s) } str?.run{ println(this) } when关键词 when类似于Java中的switch\nfun printType(o:Any) { when(o){ is Int -\u0026gt; { println(\u0026#34;Int\u0026#34;) println(o) } is String -\u0026gt; { println(\u0026#34;String\u0026#34;) println(o.toUpperCase()) } is Char -\u0026gt; println(\u0026#34;Char\u0026#34;) else -\u0026gt; println(\u0026#34;Other\u0026#34;) } } in关键词 判断数字是否在某一区间内\nif( x in 1..100){ println(\u0026#34;yes\u0026#34;) } if( x !in 1..100){ println(\u0026#34;no\u0026#34;) } 遍历集合\nfor(item in arr){ println(\u0026#34;item: $item\u0026#34;) } for((index,item) in arr.withIndex()){ println(\u0026#34;$index- $item\u0026#34;) } //判断集合中是否含有指定对象 if(student in person){ println(\u0026#34;yes\u0026#34;) } 函数 函数的声明 //[修饰符] fun \u0026lt;函数名\u0026gt;([参数]) : \u0026lt;返回类型\u0026gt; fun sum(a: Int, b: Int): Int { return a+b } //方法体只有一条语句时可简化 fun sum(a: Int, b: Int) = a+b //方法为public时, 必须显式声明返回类型 public fun sum(a: Int, b: Int): Int = a+b 不返回值\nfun printSum(a: Int, b: Int): Unit { println(a+b) } //可省略Unit关键词, 即使方法是public修饰的 public printSum(a: Int, b: Int) { println(a+b) } 函数默认参数 fun hello(name: String = \u0026#34;User\u0026#34;): String = \u0026#34;Hello $name\u0026#34; 直接调用hello()，将得到默认字符串\u0026quot;Hello User\u0026quot;\n也可以自己传入参数hello(\u0026quot;Ilirus\u0026quot;)，来得到\u0026quot;Hello Ilirus\u0026quot;\n如果函数有较多的参数时，可以使用多行参数的写法\nfun hello(name: String = \u0026#34;User\u0026#34;, sid: Int = 0): String { return \u0026#34;Hello $nameYour SID is $sid\u0026#34; } 变参函数 使用vararg来表示这是一个变长参数\nfun hasEmpty(vararg array: Any?): Boolean { return array.any{ it == null || \u0026#34;\u0026#34;.equals(it) } } 扩展函数 给目标类添加一个方法，使其可以在当前类中被使用\nreceiverType: 表示函数的接收者，也就是函数扩展的对象\nfunctionName: 扩展函数的名称\nparams: 扩展函数的参数，可以为NULL\nfun receiverType.functionName(params){ //body } 例如\n//定义一个User类 class User( var name: String? = null ) //在另一个类(当前类)中扩展User类 fun User.setName(name: String){ this.name = name } fun User.getName(): String? { return this.name } //在当前类中执行User类的扩展方法 fun main(arg:Array\u0026lt;String\u0026gt;){ var usr = User() println(usr.setName(\u0026#34;Ilirus\u0026#34;)) println(usr.getName()) } 注意事项 其实扩展函数是静态解析的，而并不是真的给类添加了方法\nopen class Animal{ // } class Dog:Animal() object Main { fun Animal.bark() = \u0026#34;animal\u0026#34; fun Dog.bark() = \u0026#34;dog\u0026#34; fun Animal.printBark(anim: Animal){ println(anim.bark()) } @JvmStatic fun main(args: Array\u0026lt;String\u0026gt;) { Animal().printBark(Dog()) } } 最终输出的是animal，而不是dog\n因为扩展方法是静态解析的，在添加扩展方法的时候类型为Animal，那么即便运行时传入了子类对象，也依旧会执行参数中声明时类型的方法。\n函数入参 在Kotlin中，可以将一个函数作为参数传递给另一个函数\nfun checkEach(array: Array\u0026lt;Any\u0026gt;, callback: (Any) -\u0026gt; Unit): Unit { for(arr in array){ callback(arr) } } var method:(Any)-\u0026gt;Unit = { println(it) } checkEach(array, method) ","date":"2018-12-06T15:08:02Z","permalink":"https://chaosalphard.github.io/p/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/","title":"Kotlin学习笔记02"},{"content":"Kotlin项目的创建 创建一个Kotlin项目  Create Project -\u0026gt; Kotlin  选择Kotlin/JVM 或者 Kotlin/JS 选择SDK 选择Library   创建包 创建.kt文件  在创建的.kt文件中写入以下代码，运行。\nfun main(args: Array\u0026lt;String\u0026gt;){ println(\u0026#34;Hello Kotlin!\u0026#34;) } 使用Spring Boot + MyBatis 创建Web项目  Create Project -\u0026gt; Spring Initializr  选择Initializr Service URL (https://start.spring.io) Language 选择 Kotlin 选择插件   Core -\u0026gt; DevTools Web -\u0026gt; web Template Engines -\u0026gt; Thymeleaf SQL -\u0026gt; MySQL, MyBatis  完成    配置文件 使用application.properties文件或者application.yml文件皆可\n这里我们使用application.yml文件，注意空格\nspring:datasource:url:jdbc:mysql://localhost:3306/tieba?useSSL=false\u0026amp;serverTimezone=GMTusername:usrpassword:pwddriver-class-name:com.mysql.jdbc.Driver编写实体类 class User { var uid: Int? = null var account: String? = null var username: String? = null var password: String? = null var adminlv: Int? = null override fun equals(other: Any?): Boolean { if (this === other) return true if (javaClass != other?.javaClass) return false other as User if (uid != other.uid) return false if (account != other.account) return false if (username != other.username) return false if (password != other.password) return false if (adminlv != other.adminlv) return false return true } override fun hashCode(): Int { var result = uid ?: 0 result = 31 * result + (account?.hashCode() ?: 0) result = 31 * result + (username?.hashCode() ?: 0) result = 31 * result + (password?.hashCode() ?: 0) result = 31 * result + (adminlv ?: 0) return result } override fun toString(): String { return \u0026#34;User{\u0026#34; + \u0026#34;UID=$uid, \u0026#34; + \u0026#34;Account=\u0026#39;$account\u0026#39;, \u0026#34; + \u0026#34;Username=\u0026#39;$username\u0026#39;, \u0026#34; + \u0026#34;Password=\u0026#39;$password\u0026#39;, \u0026#34; + \u0026#34;Adminlv=$adminlv\u0026#34; + \u0026#34;}\u0026#34; } } 查询接口 @Mapper interface UserMapper { @Select(\u0026#34;select * from user where UID = #{uid}\u0026#34;) fun findUserByID(@Param(\u0026#34;uid\u0026#34;) phone: String): User @Select(\u0026#34;select * from user\u0026#34;) fun findAllUser(): List\u0026lt;User\u0026gt; @Insert(\u0026#34;insert into user values(null,#{aot},#{usr},#{pwd},1)\u0026#34;) fun addUser(@Param(\u0026#34;aot\u0026#34;) account: String, @Param(\u0026#34;usr\u0026#34;) username: String, @Param(\u0026#34;pwd\u0026#34;) password: String): Int } 业务层 接口\ninterface UserService { fun findAllUser(): List\u0026lt;User\u0026gt; fun addUser(users: List\u0026lt;User\u0026gt;): Int } 实现\n@Service(\u0026#34;UserService\u0026#34;) class UserServiceImpl : UserService { @Resource private lateinit var userDao: UserDao override fun findAllUser(): List\u0026lt;User\u0026gt; { return userDao!!.findAllUser() } @Transactional override fun addUser(user: User): Int { return userDao!!.addUser(user.account,user.username,user.password) } } 控制器 @Controller @RequestMapping(\u0026#34;/\u0026#34;) class HomePage { @Resource private lateinit var us: UserService @GetMapping(\u0026#34;\u0026#34;) fun home(model: Model): String { model.addAttribute(\u0026#34;res\u0026#34;, us?.findAllUser()) return \u0026#34;index.html\u0026#34; } } lateinit表示延迟初始化\n网页模板 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;UID\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;账号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;昵称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;密码MD5\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;权限等级\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34;it:${res}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${it.uid}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${it.account}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${it.username}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${it.password}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${it.adminlv}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2018-12-05T16:43:44Z","permalink":"https://chaosalphard.github.io/p/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/","title":"Kotlin学习笔记01"},{"content":"使用JUnit进行单元测试 生成测试类 在需要进行测试的类中 点击右键-\u0026gt;Go To-\u0026gt;Test 或者 使用快捷键Ctrl+Shift+T生成测试类\n生成的类\npublic class CustomDaoTest { @Resource private CustomDao dao; @Test public void findCustomByName() { } @Test public void findCustomByID() { } } 添加测试\n@SpringBootTest @RunWith(SpringRunner.class) public class CustomDaoTest { @Resource private CustomDao dao; @Test public void findCustomByName() { Custom c = dao.findCustomByName(\u0026#34;Ilirus\u0026#34;); assertEquals(c.getId(),1); } @Test public void findCustomByID() { Custom c = dao.findCustomByID(1); assertEquals(c.getId(),1); } } ","date":"2018-10-19T08:52:40Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A005/","title":"[笔记]SpringBoot学习05"},{"content":"Spring打包和自定义日志 Spring打包 jar包 View-\u0026gt;Tool Windows-\u0026gt;Maven Project\n展开Lifecycle\n右键package\nRun Maven Build\n在target文件夹中找到打包出来的.jar文件\n使用java -jar \u0026lt;jarName\u0026gt; 命令启动\nwar包 修改pom.xml \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; 改为 \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;\nSpringBootApplication类 改为\npublic class ClassName extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){ return builder.sources(ClassName.class); } public static void main(String[] args) { SpringApplication.run(ClassName.class, args); } } 再按照打包jar的方式打包\n日志 定义log变量\nimport org.apache.commons.logging.Log\nprivate Log log = LogFactory.getLog(className.class);\n输出log\nlog.debug(\u0026#34;输出debug信息\u0026#34;) log.info(\u0026#34;输出信息\u0026#34;); log.warn(\u0026#34;输出警告\u0026#34;); log.error(\u0026#34;输出错误\u0026#34;) log.fatal(\u0026#34;输出致命错误\u0026#34;) ","date":"2018-10-16T09:10:46Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A004/","title":"[笔记]SpringBoot学习04"},{"content":"Thymeleaf网页模板 使用 控制器方法中添加Model\n//import org.springframework.ui.Model; @RequestMapping(value = {\u0026#34;\u0026#34;}) private String DefPage(Model model){ String name = \u0026#34;Ilirus\u0026#34;; model.addAttribute(\u0026#34;name\u0026#34;,name); return \u0026#34;def\u0026#34;; } HTML中引入命名空间之后使用\n\u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:text=\u0026#34;${name}\u0026#34;\u0026gt;被替换的文本\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 语法  替换文本 \u0026lt;div th:text=\u0026quot;'替换: '+${name}\u0026quot;\u0026gt;被替换的文本\u0026lt;/div\u0026gt; 替换href \u0026lt;a th:href=\u0026quot;@{'localhost:8080/'+${url}}\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; 循环遍历  \u0026lt;div th:each=\u0026#34;li:${list}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{\u0026#39;localhost:8080/\u0026#39;+${li.url}}\u0026#34; th:text=\u0026#34;${li.text}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;  引入模板  定义模板 \u0026lt;th:block th:fragment=\u0026quot;domblock\u0026quot;\u0026gt;Dom Element here\u0026lt;/th:block\u0026gt; \u0026lt;div th:fragment=\u0026quot;nav\u0026quot;\u0026gt;Dom Element here\u0026lt;/div\u0026gt; 引入模板 \u0026lt;th:block th:insert=\u0026quot;path/file::domblock\u0026quot;\u0026gt;\u0026lt;/th:block\u0026gt; \u0026lt;div th:insert=\u0026quot;path/file::nav\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  th:insert th:replace th:include      使用webjar引入bootsrtap 在http://mvnrepository.com/网站中找到Bootstrap 复制Maven配置代码到pom.xml的\u0026lt;dependencies\u0026gt;里\n\u0026lt;!-- https://mvnrepository.com/artifact/org.webjars/bootstrap --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.webjars\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bootstrap\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 完成后编译器会导入Maven依赖\n","date":"2018-09-28T10:23:40Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A003/","title":"[笔记]SpringBoot学习03"},{"content":"使用JPA来链接数据库 环境配置:\nJDK: Java 8\nIDE: Intellij IDEA\n服务器: Tomcat 9\n创建JPA项目  Create Project -\u0026gt; Spring Initializr  选择JDK 选择Initializr Service URL (https://start.spring.io) 选择插件   Core -\u0026gt; DevTools Web -\u0026gt; web Template Engines -\u0026gt; Thymeleaf SQL -\u0026gt; JPA, MySQL  完成    配置JPA项目 配置application.properties文件 application.properties 中配置数据库链接\nspring.jpa.database=mysql spring.datasource.url=jdbc:mysql://localhost:3306/java1604 spring.datasource.username=java1604 spring.datasource.password=java1604 spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl 添加数据库链接 View -\u0026gt; Tool Windows -\u0026gt; Database -\u0026gt; 添加Data Source\n添加Hibernate配置文件  File -\u0026gt; Project Structure -\u0026gt; Modules 添加Hibernate框架 添加hibernate.cfg.xml配置文件  生成Model类  View -\u0026gt; Tool Windows -\u0026gt; Persistence hibernate.cfg.xml -\u0026gt; Generate -\u0026gt; By Database Schema  创建dao查询接口 public interface ModelDao extends CrudRepository\u0026lt;Model,Type\u0026gt; { //Do something or do nothing. } 创建Controller @Controller @RequestMapping(value = {\u0026#34;/\u0026#34;}) public class HomeController {} 使用@Autowired装配查询接口\n@Controller @RequestMapping(value = {\u0026#34;/\u0026#34;}) public class HomeController { @Autowired private ModelDao dao; @RequestMapping(value = {\u0026#34;/count\u0026#34;}) @ResponseBody public String Query(){ return String.valueOf(dao.count()); } } 访问localhost:8080/count来查看结果\n数据库操作 数据库的查询 @RequestMapping(value = {\u0026#34;/QueryAll\u0026#34;}) @ResponseBody private Iterable\u0026lt;Custom\u0026gt; Query(){ return dao.findAll(); } 数据库的添加 @RequestMapping(value = {\u0026#34;/Add\u0026#34;}) @ResponseBody public Object Add(String fn, String ln){ Map\u0026lt;String,String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); try { Custom c = new Custom(); c.setFirstName(fn); c.setLastName(ln); dao.save(c); map.put(\u0026#34;msg\u0026#34;,\u0026#34;保存成功\u0026#34;); } catch (Exception e) { e.printStackTrace(); map.put(\u0026#34;msg\u0026#34;,\u0026#34;保存失败\u0026#34;); } return map; } 自定义查询语句 创建接口\n@Repository public interface CustomDaoC extends JpaRepository\u0026lt;Custom,Integer\u0026gt; { //Do something or do nothing. } 实现方法\n@Repository public interface CustomDaoC extends JpaRepository\u0026lt;Custom,Integer\u0026gt; { //查询  @Query(value = \u0026#34;select * from Custom \u0026#34;, nativeQuery = true) List\u0026lt;Custom\u0026gt; QueryCustomAll(); //模糊查询  @Query(value = \u0026#34;select * from Custom where name like concat(\u0026#39;%\u0026#39;,?1,\u0026#39;%\u0026#39;)\u0026#34;, nativeQuery = true) List\u0026lt;Custom\u0026gt; QueryLike(String name); //修改  @Modifying @Query(value = \u0026#34;update custom set lastName=\u0026#39;?1\u0026#39; where sid=?2\u0026#34;, nativeQuery = true) void UpdateCustom(String name, String id); }  https://stackoverflow.com/questions/21456494/spring-jpa-query-with-like\n SSL配置\n https://blog.csdn.net/anla_/article/details/80295982 https://blog.csdn.net/qq_38380025/article/details/80267312\n ","date":"2018-09-20T11:34:24Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A002/","title":"[笔记]SpringBoot学习02"},{"content":"Spring学习笔记 环境配置:\nJDK: Java 8\nIDE: Intellij IDEA\n服务器: Tomcat 9\n在IDEA中创建Spring项目  Create Project -\u0026gt; Spring Initializr  选择JDK 选择Initializr Service URL (https://start.spring.io) 选择插件   Core -\u0026gt; DevTools Web -\u0026gt; web Template Engines -\u0026gt; Thymeleaf  完成    创建Controller来控制地址映射  创建容纳Controller的包和类 添加注解@Controller 添加路径映射@RequestMapping  @Controller //此路径将作为此类里面所有方法的根目录  @RequestMapping(value = {\u0026#34;/home\u0026#34;}) public class HomePage {} 添加方法  @Controller @RequestMapping(value = {\u0026#34;/home\u0026#34;}) public class HomePage { //此路径作为此方法的映射路径  @RequestMapping(value = {\u0026#34;/page\u0026#34;}) public String Page1(){ //此处return的字符串即为templates文件夹下的html文件名  return \u0026#34;p1\u0026#34;; } } 创建模板 在resources/templates/文件夹下创建html文件, 文件名与方法中return的值相同 启动服务器 在浏览器地址栏输入localhost:8080/home/page来访问页面  使用ResponseBody来进行内容输出  添加方法 添加@RequestMapping和@ResponseBody  @Controller @RequestMapping(value = {\u0026#34;/home\u0026#34;}) public class HomePage { @RequestMapping(value = {\u0026#34;/res\u0026#34;}) @ResponseBody public String ResponseBody(){ String str = \u0026#34;ReturnResponseBodyText\u0026#34;; return str; } } 启动服务器 在浏览器地址栏输入localhost:8080/home/res来访问页面  ","date":"2018-09-11T10:08:00Z","permalink":"https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A001/","title":"[笔记]SpringBoot学习01"},{"content":"初识SCSS Sass/SCSS 的区别 SCSS是Sass3 引入的新语法，其语法完全兼容CSS3，并且继承了Sass的功能。\nSass和SCSS的区别主要有以下两点:\n  文件拓展名不同 Sass文件以 .sass 后缀为拓展名，SCSS文件以 .scss 后缀为拓展名。\n  语法不同 Sass以缩进式语法规则来书写，不带{}和;，而SCSS的语法书写则与CSS相似。\n  Sass语法:\nbody margin: 0 background: #3694FA div width: 240px heigit: 240px border: width: 1px style: solid color: #3694FA 注意冒号后面一定要有空格\nSCSS语法:\nbody{ margin:0; background:#3694FA; div{ width:240px; height:240px; border:{ width: 1px; style: solid; color: #3694FA; } } } 最终输出CSS文件\nbody { margin: 0; background: #3694FA; } body div { width: 240px; height: 240px; border-width: 1px; border-style: solid; border-color: #3694FA; } SCSS的安装 安装Ruby Sass基于Ruby语言开发而成，因此需要先安装Ruby。\n或者使用node安装node-sass。\n注意需要将Ruby添加到环境变量中\n安装完成后输入以下指令来测试是否安装成功\nruby -v 更换Ruby源 因为国内网络原因导致gem无法正常访问，需要更换为国内源\n#删除原来的gem源 gem sources --remove https://rubygems.org/ #或者使用下面的指令移除所有的gem源 gem sources --clear-all #替换为国内的gem源(2018.8.26), 注意检查源是否失效 gem sources --add https://gems.ruby-china.com/ #查看是否替换成功 gem sources --list 安装Sass和Compass #安装Sass gem install sass #安装Compass gem install compass 测试是否安装成功\nsass -v compass -v 编译Sass/SCSS 命令行编译 #编译Sass文件 sass input.sass output.css #编译SCSS文件 sass input.scss output.css 监听文件变换，自动编译文件 #监听单个文件 sass --watch input-file:output-file #监听文件夹 sass --watch input-dir:output-dir 常用编译选项 #编译格式 sass --watch scss:css --style \u0026lt;nested|expanded|compact|compressed\u0026gt; #添加调试map sass --watch scss:css --sourcemap=\u0026lt;auto|file|inline|none\u0026gt; #开启debug信息 sass --watch scss:css --debug-info #使用CSS-superset SCSS 语法 sass --watch scss:css --scss #不使用编译缓存 sass --watch scss:css --no-cache 编译格式\nSass文件\nbody{ margin:0; background:#3694FA; div{ width:240px; height:240px; border:{ width: 1px; style: solid; color: #3694FA; } } } nested编译格式\nbody { margin: 0; background: #3694FA; } body div { width: 240px; height: 240px; border-width: 1px; border-style: solid; border-color: #3694FA; } expanded编译格式\nbody { margin: 0; background: #3694FA; } body div { width: 240px; height: 240px; border-width: 1px; border-style: solid; border-color: #3694FA; } compact编译格式\nbody { margin: 0; background: #3694FA; } body div { width: 240px; height: 240px; border-width: 1px; border-style: solid; border-color: #3694FA; } compressed编译格式\nbody{margin:0;background:#3694FA}body div{width:240px;height:240px;border-width:1px;border-style:solid;border-color:#3694FA} ","date":"2018-08-26T20:25:51Z","permalink":"https://chaosalphard.github.io/p/%E5%88%9D%E8%AF%86scss/","title":"初识SCSS"},{"content":"使用mysqldump/source指令备份/恢复数据库 备份数据 用法:\nmysqldump -u [用户名] -p [options] \u0026gt; [输出文件名] 示例\nmysqldump -u root -p \u0026gt; D:\\SQLBak\\Data.sql mysqldump常用选项  \u0026ndash;databases 指定需要备份的数据库名称\n用法:  mysqldump -u [用户名] -p --databases [dbName] \u0026gt; [输出文件名]  \u0026ndash;all-databases 备份所有的数据库\n用法:  mysqldump -u [用户名] -p --all-databases \u0026gt; [输出文件名]   \u0026ndash;tab[=dir_name] 不使用此选项，mysqldump仅输出一个sql文件。\n使用此选项，mysqldump会对每一个要备份的表输出两个文件，sql文件保存创建表时的sql语句，txt文件储存表中的数据。\ndirname即为sql和txt文件输出的路径。\n  \u0026ndash;add-drop-table 此选项会在每一个表前面加上drop table if exists 语句。\n  \u0026ndash;add-locks 此选项会在insert语句前面加上lock table 语句。\n  \u0026ndash;skip-comments 此选项会去掉输出文件中的注释\n  恢复数据 用法\nmysql -u [用户名] -p \u0026lt; [备份文件] 示例\nmysql -u root -p \u0026lt; D:\\SQLBak\\Data.sql 已登录mysql的情况下\nmysql\u0026gt; source [备份文件] 示例\nmysql\u0026gt; source D:\\SQLBak\\Data.sql 还原\u0026ndash;tab选项备份的文本格式的备份文件 mysql -u [用户名] -p \u0026lt; [sql备份文件] #还原表结构 mysqlimport -u [用户名] -p [数据库名] [txt备份文件] #还原表数据 已登录mysql的情况下\nsource [sql备份文件]; use [数据库名]; mysql\u0026gt; load data infile `[txt备份文件]` into [表名]; 导出查询结果到本地文件 用法\nmysql -u [用户名] -p --execute=\u0026quot;[sql语句]\u0026quot; [options] [数据库名] \u0026gt; [输出文件] 示例\nmysql -u root -p --execute=\u0026quot;select * from testtab;\u0026quot; testdb \u0026gt; D:\\SQLBak\\result.txt 常用选项   \u0026ndash;vertical 使用\u0026ndash;vertical选项可将每条记录分为多行显示。\n  \u0026ndash;html 使用\u0026ndash;html选项可将结果导出为html格式。\n  \u0026ndash;xml 使用\u0026ndash;xml选项可将结果导出为xml格式。\n  ","date":"2018-08-11T21:18:01Z","permalink":"https://chaosalphard.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","title":"MySQL数据库备份与恢复"},{"content":"配置Firefox浏览器书签打开方式 在Firefox浏览器中，书签和地址栏链接的打开方式默认是覆盖当前标签页的，那么，怎样让Firefox浏览器默认在新标签页打开书签和地址栏链接呢？\n其实很简单。\n首先，在浏览器地址栏输入\nabout:config 然后搜索\u0026quot;intab\u0026quot;\n将以下两个选项的值\n# 在新标签页打开书签 browser.tabs.loadBookmarksInTabs # 在新标签页打开url 地址 browser.urlbar.openintab 由false改为true即可\n适用版本61.0+\n","date":"2018-08-03T16:28:24Z","permalink":"https://chaosalphard.github.io/p/%E9%85%8D%E7%BD%AEfirefox%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%A6%E7%AD%BE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/","title":"配置Firefox浏览器书签打开方式"},{"content":"通过禁用内存修整来提高虚拟机性能 vmem 　VMware在运行每个虚拟机的时候会在硬盘上为相应的虚拟机生成一个内存实时镜像 .vmem 文件用于存储虚拟机内存的改变，这个文件主要是将虚拟机内存的内容映射到磁盘，以支持在虚拟机的暂停等功能。\n同时，VMware会在使用的时候统计内存中的数据的使用情况，然后将不常用的一些内存数据存入 .vmem 文件从而节省内存的使用。\n但是内存交换带来的大量读写操作会导致性能下降。\n解决方案 关闭虚拟机\n点击 虚拟机-\u0026gt;设置-\u0026gt;选项-\u0026gt;高级-\u0026gt;勾选“禁用内存页面修整”选项。\n找到*.vmx虚拟机定义文件\n在最后一行加入\nmainMem.useNamedFile = \u0026quot;FALSE\u0026quot; 完成\n需要注意的是，在添加这段代码后虚拟机的暂停、快速启动等操作会受到影响\n","date":"2018-07-05T21:14:34Z","permalink":"https://chaosalphard.github.io/p/%E9%80%9A%E8%BF%87%E7%A6%81%E7%94%A8%E5%86%85%E5%AD%98%E4%BF%AE%E6%95%B4%E6%9D%A5%E6%8F%90%E9%AB%98%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD/","title":"通过禁用内存修整来提高虚拟机性能"},{"content":"效果展示  \n效果实现 方法一 准备工作 首先把导航栏效果做出来\nHTML\n\u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;Title1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;Title2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;Title3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS\n.nav{ width: 1200px; height: 72px; display: flex; background-color: #DDD; justify-content: center; } .top{ margin: 0 20px 0 20px; background-color: #EEE; width: 10%; height: 100%; } .title{ display: flex; height: 100%; font-family: \u0026#34;微软雅黑\u0026#34;; font-size: 36px; justify-content: center; align-items: center; } 再给下拉框设置样式\n.list{ width: 100%; background: #EEE; } .list\u0026gt;a{ display: flex; justify-content: center; padding: 10px 0 10px 0; font-family: \u0026#34;微软雅黑\u0026#34;; font-size: 24px; text-decoration: none; color: #000; } 现在效果应该是这样的\n \n控制下拉框的显示与隐藏 隐藏下拉框\n.list{ opacity: 0; transform: scaleY(0); } 显示下拉框\n.top:hover\u0026gt;.list{ opacity: 1; transform: scaleY(1); } 添加动画效果 下拉效果\n.list{ opacity: 0; transform: scaleY(0); transform-origin: top center; transition: opacity 0.5s ease-out,transform 0.5s; } .top:hover\u0026gt;.list{ opacity: 1; transform: scaleY(1); }  \n淡出淡入效果\n.list{ opacity: 0; transform: scaleY(0); transform-origin: top center; transition: opacity 0.5s ease-out,transform 0s 0.5s; } .top:hover\u0026gt;.list{ opacity: 1; transform: scaleY(1); transition: opacity 0.5s ease-out,transform 0s; }  \n方法二 准备工作 HTML\n\u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title t1\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;first\u0026#34;\u0026gt;Title1\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title t2\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;first\u0026#34;\u0026gt;Title2\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title t3\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;first\u0026#34;\u0026gt;Title3\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;xxxxxx\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS\n.nav{ width: 100vw; height: 72px; display: flex; margin-top: 200px; background-color: #DDD; justify-content: center; } .top{ margin: 0 20px 0 20px; background-color: #EEE; width: 10%; height: 100%; position: relative; } .title\u0026gt;a{ display: block; font-family: \u0026#34;微软雅黑\u0026#34;; text-decoration: none; color: #000; text-align: center; background: #EEE; } .title\u0026gt;.first{ height: 72px; line-height: 72px; font-size: 36px; } .title\u0026gt;a:not(.first){ height: 52px; line-height: 52px; font-size: 24px; }  \n无动画效果的显示与隐藏 隐藏下拉框\n.title{ height: 72px; overflow: hidden; } 显示下拉框\n.title:hover{ overflow: visible; } 有动画效果的显示与隐藏 隐藏下拉框\n.title{ height: 72px; overflow: hidden; transition: height 0.5s ease-out; } 显示下拉框\n.title:hover{ /* 52px为下拉框项的高度, 72px为下拉框Title项的高度 */ height: calc(var(--n) * 52px + 72px); } /* n为下拉框项的数量 */ .t1{ --n:3; } .t2{ --n:5; } .t3{ --n:8; } 效果\n \n","date":"2018-06-12T21:20:50Z","permalink":"https://chaosalphard.github.io/p/css%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E6%A1%86%E6%95%88%E6%9E%9C/","title":"CSS实现下拉框效果"},{"content":"效果展示  \n效果实现 一个div，将文字放进去\n\u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;Welcome to Ilirus\u0026#39; blog\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 美化样式\nbody { --bg:url(\u0026#34;image.jpg\u0026#34;); background: var(--bg) fixed top center / cover; } .box{ background: hsla(0,0%,100%,0.2); color: aliceblue; font-size: 38px; width: 12em; height: 3em; display: flex; align-items: center; justify-content: center; border-radius: 0.6em; box-shadow: 0px 0px 3px 3px hsla(0,0%,0%,0.4); text-shadow: 0px 0px 8px #FFF; } 大致效果应该是这样的\n \n使用伪元素实现模糊效果\n为div创建一个伪元素\n.box::before{ content: \u0026#39;\u0026#39;; } 设置定位和宽高\n.box::before{ position: absolute; width: inherit; height: inherit; } 添加背景颜色，以便观察调试\n.box::before{ background: hsla(0,100%,83%,0.4); } 现在效果应该是这样\n \n添加模糊效果和border-radius\n.box::before{ border-radius: 0.6em; filter: blur(5px); }  \n伪元素把文本挡住了，给它设置z-index\n.box::before{ z-index: -1; }  \n现在将背景换成图片就可以了\n.box::before{ background: var(--bg) fixed top center / cover; }  \nCSS代码\nbody { --bg:url(\u0026#34;image.jpg\u0026#34;); background: var(--bg) fixed top center / cover; } .box{ background: hsla(0, 0%, 100%, 0.2); color: aliceblue; font-size: 38px; width: 12em; height: 3em; display: flex; align-items: center; justify-content: center; border-radius: 0.6em; box-shadow: 0px 0px 3px 3px hsla(0, 0%, 0%, 0.4); text-shadow: 0px 0px 8px #FFF; } .box::before{ content: \u0026#39;\u0026#39;; border-radius: 0.6em; position: absolute; width: inherit; height: inherit; background: var(--bg) fixed top center / cover; filter: blur(10px); z-index: -1; } ","date":"2018-05-28T02:10:10Z","permalink":"https://chaosalphard.github.io/p/css%E5%AE%9E%E7%8E%B0%E6%AF%9B%E7%8E%BB%E7%92%83%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C/","title":"CSS实现毛玻璃模糊效果"},{"content":"为什么a标签之间会有间隔 在网页的编写过程中经常会发现相邻的a标签之间有间隔\n\u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;2\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;3\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;下一页\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;  \n这其实是网页元素之间的留空导致的，那么最简单的解决方式就是a标签之间不留空格\n\u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;2\u0026lt;/a\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;3\u0026lt;/a\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;下一页\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 但是考虑到代码的可读性，这样写肯定是不行的，所以我们可以用注释来解决\n\u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt;\u0026lt;!-- --\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;2\u0026lt;/a\u0026gt;\u0026lt;!-- --\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;3\u0026lt;/a\u0026gt;\u0026lt;!-- --\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;下一页\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 但这样也不是长久之策，如果a标签数量较多的话就会很麻烦，所以还是得需要CSS来实现\n使CSS来消除a标签之间的间隔\n方法一 给a标签的父级元素设置font-size属性\ndiv { font-size:0px; } div\u0026gt;a { font-size:36px; }  \n缺点：子文本元素一定要设置font-size，否则会继承父元素的font-size: 0px 导致不显示。\n下面这张图是我没有给a标签设置font-size参数的情况，\n可以看到，由于我没有给a标签设置font-size数值，a标签继承了父级标签的font-size 大小导致字体小到看不见。\n但是一般情况下通常都会为文本元素设置font-size的大小，所以这个缺点影响不大。\n \n方法二 给a标签的父级元素设置letter-spacing属性\ndiv { /*一般来说-4px即可，但这个数值可以被加大*/ /*数值越大，子元素没有设置letter-spacing时错位效果越严重*/ letter-spacing:-4px; } div\u0026gt;a { letter-spacing: 0; }  \n缺点：子文本元素一定要设置letter-spacing: 0，否则会继承父元素的letter-spacing 导致文字错位。\n下面这张图是我没有给a标签设置letter-spacing参数的情况，可以看到，在父级标签letter-spacing参数设为-4px时，即使a标签文本错位，在一定程度上也不影响阅读，所以我比较喜欢用这种写法。\n \n方法三 父元素使用flex布局\ndiv{ display: flex; /*justify-content可接受的值有[flex-start|center|flex-end]*/ justify-content: flex-start; align-items: center; }  \n子元素并不需要特别设置属性，但是会改变布局结构，视情况使用。\n","date":"2018-05-24T12:28:42Z","permalink":"https://chaosalphard.github.io/p/%E5%8E%BB%E9%99%A4a%E6%A0%87%E7%AD%BE%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%94/","title":"去除a标签之间的间隔"},{"content":"VHD/VHDX简介 什么是VHD VHD 是Microsoft Virtual Hard Disk format（微软虚拟磁盘文件）的简称。可以由Windows Vista/7/8/10，Windows Server 2008R2 等系统创建。\n一个VHD文件可以被虚拟为一块硬盘，并且可以像操作一块硬盘一样操作VHD文件，例如：读取、写入、创建分区、格式化等等。\n什么是VHDX 随着虚拟环境的企业工作负荷的增加以及性能要求的提高，虚拟硬盘 (VHD) 格式需要适应这些变化。因此，Windows Server 2012 中的 Hyper-V 引入了一个新版本的VHD格式，称为VHDX。\n与旧的VHD格式相比，VHDX具有更大的存储容量。它优化了动态磁盘和差异磁盘的结构对齐方式，以防止在新的大型扇区物理磁盘上性能降级。同时还能在电源故障期间提供数据损坏保护。\nVHDX格式的主要新功能如下：\n 支持的虚拟硬盘的存储容量高达 64 TB。 通过记录对VHDX元数据结构的更新，可以在电源发生故障时保护数据不会被损坏。 改进了虚拟硬盘格式的对齐方式，可在大型扇区磁盘上更好地工作。  VHDX 格式还提供以下功能：\n 动态磁盘和差异磁盘有较大的数据块大小，可让这些磁盘满足工作负荷的需求。 拥有4KB的逻辑扇区，可以在为4KB扇区设计的应用程序和作负荷使用该磁盘时提供较高的性能。 能够存储有关用户可能想记录的文件的自定义元数据，如操作系统版本或应用的修补程序。 高效地表示数据（也称为“剪裁”），使文件大小更小并且允许基础物理存储设备回收未使用的空间。（剪裁需要直接连接到虚拟机或 SCSI 磁盘的物理磁盘以及与剪裁兼容的硬件。)  VHD/VHDX的优点   维护简单\n 操作VHD就和操作物理硬盘一样，我们可以对其进行分区、格式化、压缩、删除等等操作，并且这些操作并不会影响你的物理分区。    加载自如\n VHD磁盘可以进行分离操作，这样在磁盘管理中就无法找到VHD磁盘分区。如果想要再次挂载，只需对VHD磁盘文件进行挂载操作即可。    轻松备份\n 备份时仅需要将 .vhd/.vhdx 文件进行备份，文件中所包含的所有信息(包括分区表等信息)就被备份下来了。    迁移方便\n 只需要将 .vhd/.vhdx 文件复制到目标计算机上，再进行附加操作即可完成迁移。也可以通过服务器进行分发。也可以在物理机和虚拟机之间进行迁移。    VHD系统的特点 安装简便 VHD系统安装非常简单，到了Windows10系统更是如此，甚至可以从别的电脑上拷一个Windows10的VHD来启动，类似于即插即用。\n性能强劲 VHD系统如同真实的系统一样，可以直接使用计算机的物理硬件，性能与真实系统相差无几，这与虚拟机有明显的差别。虚拟机使用虚拟出来的硬件，VHD系统直接使用物理硬件。\n备份方便 直接将 .vhd/.vhdx 文件复制一份，就完成了备份工作。\n此外，VHD还提供了更为方便的备份技术——“差分磁盘”。使用差分磁盘，即可实现系统的“秒备份”，“秒还原”。\n删除方便 当你不想使用VHD系统时，只需要将对应的 .vhd/.vhdx 文件删除，再将对应的引导条目删除即可。\n如何部署VHD系统 如果你从网络上或者你朋友那里获得了部署有Windows10系统的vhd/vhdx文件，只需将其拷入你的计算机，然后添加引导项即可完成VHD系统的部署。\n如果没有也没关系，下面将会介绍如何从零开始部署VHD系统\n创建VHD/VHDX文件 以下命令均在Windows10环境下进行，Windows7可能略有不同\n使用Windows磁盘管理创建\n创建vhdx文件\n \n设置大小\n \n初始化磁盘，GPT还是MBR看个人情况，推荐选GPT格式\n \n新建分区\n \n完成\n使用命令行创建\n#启动diskpart工具 diskpart #创建一个大小为25600MB的固定大小的vhdx文件 #如果想创建动态拓展大小的vhdx文件，换成type=expandable即可 create vdisk file=E:\\vhd.vhdx maximum=25600 type=fixed #选中刚才创建的vhdx文件 select vdisk file=E:\\vhd.vhdx #挂载硬盘 attach vdisk #创建主分区 create partition primary #设置卷标 assign letter=V #格式化分区 format quick label=vhdx exit 完成\n部署Windows系统到VHD虚拟磁盘 首先将vhdx文件挂载到系统上，如果已挂载则可跳过这一步\ndiskpart select vdisk file=E:\\vhd.vhdx attach vdisk exit 将系统部署到vhdx文件中\n下载.iso镜像文件或者.wim映像文件。\n如果是.iso镜像文件则将其解压或者挂载到虚拟光驱。\n#获得镜像信息 Dism /Get-ImageInfo /imagefile:D:\\Windows10\\sources\\install.wim #部署镜像到vhdx中 Dism /apply-image /imagefile:D:\\Windows10\\sources\\install.wim /index:1 /ApplyDir:V:\\ 等待部署完成\n参数解释：\nimagefile: install.wim文件所在的位置\nindex: 系统版本所对应的索引路径\nApplyDir: 要部署镜像的驱动器盘符\n添加引导项 #将V盘的系统添加到引导项，V即为你vhd虚拟磁盘的盘符 bcdboot V:\\Windows /l zh-CN /d 如果你是在PE下进行的，则需要为ESP分区分配盘符\nbcdboot V:\\Windows /s Z: /f uefi /l zh-cn /d 参数解释：\n/l: 语言\n/s: 要将引导文件复制到的磁盘的盘符，通常是ESP分区所在位置\n/f: 引导方式\n/d: 保留现在的默认启动条目\n使用bcdedit指令来查看引导项，或者用msconfig来查看引导项。\n\\\u0026gt;bcdedit Windows 启动管理器 -------------------- 标识符 {bootmgr} device partition=\\Device\\HarddiskVolume1 path \\EFI\\Microsoft\\Boot\\bootmgfw.efi description Windows Boot Manager locale zh-CN inherit {globalsettings} default {default} resumeobject {3fa12b79-202e-11e8-8e30-ddc8fe2935d0} displayorder {default} {current} toolsdisplayorder {memdiag} timeout 5 Windows 启动加载器 ------------------- 标识符 {current} device partition=C: path \\Windows\\system32\\winload.efi description SSD Win10 locale zh-CN inherit {bootloadersettings} recoverysequence {3fa12b6f-202e-11e8-8e30-ddc8fe2935d0} recoveryenabled Yes isolatedcontext Yes allowedinmemorysettings 0x15000075 osdevice partition=C: systemroot \\Windows resumeobject {3fa12b79-202e-11e8-8e30-ddc8fe2935d0} nx OptIn bootmenupolicy Standard Windows 启动加载器 ------------------- 标识符 {3fa12b75-202e-11e8-8e30-ddc8fe2935d0} device partition=E: path \\Windows\\system32\\winload.efi description Virtual Win10 locale zh-CN inherit {bootloadersettings} isolatedcontext Yes allowedinmemorysettings 0x15000075 osdevice partition=E: systemroot \\Windows resumeobject {3fa12b75-202e-11e8-8e30-ddc8fe2935d0} nx OptIn bootmenupolicy Standard 使用bcdedit /set指令来为启动项命名\n#bcdedit /set {标识符} description \u0026#34;要更改的启动项名称\u0026#34; bcdedit /set {3fa12b75-202e-11e8-8e30-ddc8fe2935d0} description \u0026#34;VW10\u0026#34; 取消挂载，重启电脑，引导进入VHD系统即可\ndiskpart select vdisk file=E:\\vhd.vhdx detach vdisk exit 使用差分磁盘进行备份和还原 差分磁盘如何实现“秒备份”，“秒还原” 差分磁盘是指基于父盘的子盘，子盘能读取父盘的所有数据，同时对子盘的所有改动不会影响到父盘。\n因此，一旦建立了子盘，就相当于为父盘建立了一个还原点，由于子盘自身不带数据，所以创建非常快，大小非常小(4MB左右)，子盘的大小会随着子盘的使用逐渐增大。\n同时，如果想要还原，只需要再次为父盘创建一个子盘即可，原来的子盘同样可以使用或删除。\n基于此，使用差分磁盘可以使用最少的空间，创建多个系统，供不同的人使用。并且备份和还原对硬盘的损伤也降到了最低。\n创建差分磁盘\ndiskpart create vdisk file=E:\\VDisk\\child01.vhdx parent=E:\\VDisk\\vhd.vhdx exit 参数解释：\nfile: 创建的子盘的位置和名称\nparent: 父盘的位置\n将子盘添加到启动项\ndiskpart select vdisk file=E:\\VDisk\\child01.vhdx attach vdisk exit bcdboot V:\\Windows /l zh-CN /d 子盘的启动项名称同样可以通过bcdedit /set指令更改。\n由于子盘是基于父盘的数据创建的，创建完毕的子盘和父盘的数据是一模一样的，但是父盘内的数据就无法修改，否则会导致子盘数据错误，无法打开。\n因此，将父盘的vhdx文件设为“只读”属性，同时在Win+R的运行框中输入msconfig，进入启动项管理，将父盘的启动项删除。\n以后进行还原操作时，只需要将原本的子盘删除，创建一个新子盘，再将其添加到启动项即可。你也可以将指令写为bat批处理，双击执行。\ndel E:\\VDisk\\child01.vhdx diskpart create vdisk file=E:\\VDisk\\child01.vhdx parent=E:\\VDisk\\vhd.vhdx select vdisk file=E:\\VDisk\\child01.vhdx attach vdisk exit bcdboot V:\\Windows /l zh-CN /d ","date":"2018-05-20T10:30:12Z","permalink":"https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8vhd%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E8%99%9A%E6%8B%9F%E7%B3%BB%E7%BB%9F/","title":"使用VHD创建本地虚拟系统"}]