<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SpringCloud on Ilirus</title><link>https://chaosalphard.github.io/tags/springcloud/</link><description>Recent content in SpringCloud on Ilirus</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 29 Mar 2020 22:50:00 +0000</lastBuildDate><atom:link href="https://chaosalphard.github.io/tags/springcloud/index.xml" rel="self" type="application/rss+xml"/><item><title>[笔记]SpringCloud学习10: OpenFeign超时配置与日志记录</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A010-openfeign%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 29 Mar 2020 22:50:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A010-openfeign%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</guid><description>设置超时时间 在application.yml中
# 设置超时时间ribbon:# 指与服务器建立链接的超时时间(单位: ms)ConnectTimeout:1000# 指与服务器建立链接之后，从服务器读取到可用资源所花时间ReadTimeout:5000配置日志输出 OpenFeign有4个日志级别
NONE: 不输出任何日志 BASIC: 仅记录请求方法、URL、响应状态吗以及执行时间 HEADERS: 除了BASIC中的信息外，还记录请求和响应的头信息 FULL: 输出所有信息 编写配置类
package com.ilirus.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class OpenFeignConfig { @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } } 在application.yml中配置控制台日志输出级别</description></item><item><title>[笔记]SpringCloud学习09: OpenFeign服务调用</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A009-openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</link><pubDate>Sun, 29 Mar 2020 03:07:11 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A009-openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</guid><description>Feign 简介 Feign是一个声明式的WebService客户端。它的出现使开发WebService客户端变得很简单。使用Feign只需要创建一个接口加上对应的注解。
Feign 是一种声明式、模板化的HTTP 客户端。在SpringCloud 中使用Feign，可以做到使用HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问HTTP 请求。
Feign 和 OpenFeign OpenFeign在Feign的基础上支持了SpringMVC的注解。
在OpenFeign中，除了自身提供的注解之外，还支持使用JAX-RS注解，或者SpringMVC注解。
OpenFeign的@FeignClient注解可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
OpenFeign同样使用声明式方式定义Web服务客户端，其次，OpenFeign还可以通过集成Ribbon或Eureka来实现负载均衡的HTTP 客户端。
OpenFeign 的使用 在服务消费方的pom.xml中，引入以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 创建相应的Service接口
package com.ilirus.springcloud.service; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; // value为服务提供方在Eureka中注册的名称 // RequestMapping为提供方对应的请求地址 @FeignClient(value = &amp;#34;irs-provider-payment&amp;#34;) public interface PaymentFeignService { @GetMapping(&amp;#34;/payment/query/{id}&amp;#34;) public CommonResult&amp;lt;Payment&amp;gt; getPaymentByID(@PathVariable(&amp;#34;id&amp;#34;) Long id); } 创建Controller
package com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import com.ilirus.springcloud.enums.Status; import com.ilirus.springcloud.service.PaymentFeignService; import lombok.extern.slf4j.Slf4j; import org.</description></item><item><title>[笔记]SpringCloud学习08: Ribbon基础</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A008-ribbon%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 21 Mar 2020 03:44:07 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A008-ribbon%E5%9F%BA%E7%A1%80/</guid><description>Ribbon 介绍 Ribbon是Netflix发布的一款用于负载均衡的开源项目，是一个客户端的负载均衡器。
Ribbon会基于某些规则(轮询，随机等)决定要调用的服务链接，并且可以使用Ribbon实现自定义的负载均衡算法。
负载均衡是什么 负载均衡(Load Balance)简单来说就是将用户的请求平摊到各个服务器上，从而提高服务的承载能力。
Ribbon 本地负载均衡和Nginx 服务端负载均衡的区别 Nginx: 客户端所有请求都先发给Nginx，让后由Nginx 服务器实现请求转发。(集中式LB)
Ribbon: 在调用微服务接口的时候，由Ribbon 的负载均衡算法决定调用哪个服务接口。(进程内LB)
集中式LB 和进程内LB 集中式Load Balancer: 在服务的消费方和提供方之间使用独立的LB 设施，由该设施负责把请求访问通过某种策略转发制服务提供方
进程内Load Balancer: 将LB 逻辑集成到消费方，消费方从服务注册中心获知有那些服务地址可用，然后自己再从这些地址中选择一个合适的服务器
Ribbon 引入 修改pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --&amp;gt; &amp;lt;/dependency&amp;gt; Ribbon已经集成在Eureka Client中，如果pom.xml中已经引入Eureka Client，则可以不用再引入Ribbon
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Ribbon 的使用 使用@LoadBalancer注解授予RestTemplate负载均衡功能，
@Configuration public class ApplicationontextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 使用@Resource或者@Autowired 装配具有负载均衡能力的RestTemplate</description></item><item><title>[笔记]SpringCloud学习07: Eureka自我保护</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</link><pubDate>Fri, 20 Mar 2020 03:02:19 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</guid><description>Eureka 自我保护机制 保护模式主要用于一组客户端和服务端之间存在网络分区场景下的保护，一旦进入保护模式，Eureka Server会尝试保护其服务注册表中的信息，将不再删除服务注册表中的信息，也就是不会注销任何微服务
一句话概括: 如果某一时刻，Eureka Server中某个微服务不可用了，Eureka不会立即清除，而是会尝试对该微服务的信息进行保存 (CAP中的AP)
为什么需要自我保护机制 为了防止Eureka Client可以正常运行，但与Eureka Server直接网络不同的情况下，Eureka Server错误地将可以正常运行的Client端移除
默认情况下，如果Eureka Server在一定时间内(默认90s)没有接收到某个服务实例的心跳时，Eureka Server会注销该实例。但当网络分区故障发生时(延时，拥挤)，微服务与Eureka Server之间无法正常通讯时，超时移除节点是不正确的行为——微服务自身很可能是正常状态，也就是说不应该注销此服务。
Eureka通过自我保护模式来解决这个问题——当Eureka Server短时间内丢失过多Client端时，那么这个节点将进入自我保护模式。
也就是说宁可保留错误的服务注册信息，也不会盲目注销任何可能正常的服务实例
如何判断Eureka 是否进入了自我保护模式 如果在Eureka Server首页看到以下提示，则说明Eureka进入了保护模式
EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&amp;rsquo;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
如何禁止自我保护机制 在Erueka Server 端的application.yml文件中，添加以下内容
eureka:server:# 关闭自我保护机制enable-self-preservation:false# 移除服务的超时时间，单位毫秒eviction-interval-timer-in-ms:15000在Eureka Client 端的application.yml文件中，添加以下内容
eureka:# eureka 客户端instance:# Eureka Client 端向Server 端发送心跳的时间间隔，单位秒，默认30s# 修改心跳时间主要是因为修改了Server 端的超时时间(15000ms = 15s)# 所以对应的修改Client 端的心跳时间lease-renewal-interval-in-seconds:5# Eureka Server 端在收到最后一次心跳后等待时间上限，单位秒，超时将剔除服务，默认90slease-expiration-duration-in-seconds:15</description></item><item><title>[笔记]SpringCloud学习06: Eureka服务发现</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Fri, 20 Mar 2020 02:03:59 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>获取Eureka Server 端注册成功的服务信息 对于注册进Eureka里面的微服务，可以通过服务发现来获取该服务的信息
修改对应工程(Eureka Client 端)的Controller
package com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.enums.Status; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; @RestController @RequestMapping(&amp;#34;/payment&amp;#34;) @Slf4j public class PaymentController { @Resource private DiscoveryClient discoveryClient; @GetMapping(&amp;#34;/discovery&amp;#34;) public CommonResult discovery() { List&amp;lt;String&amp;gt; services = discoveryClient.getServices(); return CommonResult.ofData(Status.SUCCESS, services); } @GetMapping(&amp;#34;/discovery/{instances}&amp;#34;) public CommonResult discovery(@PathVariable String instances) { List&amp;lt;ServiceInstance&amp;gt; serviceInstances = discoveryClient.getInstances(instances); return CommonResult.ofData(Status.SUCCESS, serviceInstances); } } 修改启动类
package com.ilirus.springcloud; import org.</description></item><item><title>[笔记]SpringCloud学习05: 服务提供方集群</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/</link><pubDate>Thu, 19 Mar 2020 22:02:13 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/</guid><description>服务提供方集群搭建 参考之前搭建好的服务提供方工程，再创建一个新的工程，要注意application.yml中，spring.application.name属性要和之前的一致，完成后启动服务
eureka
服务消费方请求地址修改 在消费方工程中，将请求地址改为微服务名称
package com.ilirus.springcloud.controller; /* import ... */ @RestController @RequestMapping(&amp;#34;/consumer&amp;#34;) @Slf4j public class OrderController { private static final String PAYMENT_URL = &amp;#34;http://irs-provider-payment/payment&amp;#34;; @Resource private RestTemplate restTemplate; @GetMapping(&amp;#34;/payment/create&amp;#34;) public CommonResult create(Payment payment) { return restTemplate.postForObject(PAYMENT_URL+&amp;#34;/create&amp;#34;, payment, CommonResult.class); } /* ... */ } 因为目前irs-provider-payment服务下有两个实例，直接使用服务名并不能让程序知道你想用具体哪一个，所以还需要进一步配置
RestTemplate 配置负载均衡 修改RestTemplate配置类
package com.ilirus.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 至此，全部配置完成</description></item><item><title>[笔记]SpringCloud学习04: Eureka集群</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/</link><pubDate>Tue, 17 Mar 2020 23:33:16 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/</guid><description>Eureka 集群原理 我们假设有三台 Eureka Server 组成的集群，只要三个地方的任意一个Eureka Server不出现问题，都不会影响整个架构的稳定性。
Eureka集群
从图中可以看出Eureka Server集群相互之间通过Replicate来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl 指向其他节点。
如果某台Eureka Server 宕机，Eureka Client 的请求会自动切换到新的Eureka Server 节点。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它Eureka Server 当前所知的所有节点中。
另外Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个Eureka Server 同时也是Eureka Client，多个Eureka Server 之间通过P2P的方式完成服务注册表的同步。
Eureka Server 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。
Eureka保证AP (CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance))
Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka Client 在向某个Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。
Eureka 集群搭建 新建一个Eureka Server，并修改application.yml文件
server:port:7002eureka:instance:hostname:eureka7002.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7001.com:7001/eureka/修改之前的单机eureka配置文件
server:port:7001eureka:instance:hostname:eureka7001.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7002.com:7002/eureka/ 因为是在同一台机器上，所以需要修改host文件将eureka7001.com和eureka7002.com映射为127.0.0.1
微服务注册进集群 回到之前的子工程中，修改application.yml文件中的eureka配置
eureka:# eureka 客户端client:register-with-eureka:truefetch-registry:trueservice-url:# 服务中心链接defaultZone:http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka启动服务，查看是否正确 集群</description></item><item><title>[笔记]SpringCloud学习03: Eureka的搭建</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 16 Mar 2020 00:36:52 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/</guid><description>Eureka Server端的搭建 创建一个Maven项目，在pom.xml中写入以下依赖:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --&amp;gt; &amp;lt;/dependency&amp;gt; 创建启动类
package com.ilirus.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaServerMain7001.class, args); } } 配置yml
server:port:7001eureka:# eureka 服务端instance:hostname:localhost# eureka服务端实例名称client:register-with-eureka:false# 是否向服务中心注册自己feth-registry:false# 是否向服务中心检索已有的注册信息service-url:# 设置Eureka Server 的交互地址。查询服务和注册服务都需要依赖这个地址defaultZone:http://${eureka.instance.hostname}:${server.port}/eureka/启动工程并查看是否有误
Eureka Client端的注册 回到之前的子项目中，向pom.xml中添加以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 修改application.yml文件
spring:application:name:irs-provider-payment8001# 名称eureka:# eureka 客户端client:register-with-eureka:true# 向服务中心注册自己fetch-registry:true# 向服务中心获取已有的注册信息, 集群必须设置为true才能配合ribbon使用负载均衡service-url:# 服务中心链接defaultZone:http://localhost:7001/eureka修改启动类并添加@EnbaleEurekaClient注解
package com.ilirus.springcloud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.</description></item><item><title>[笔记]SpringCloud学习02: Eureka基础</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 14 Mar 2020 03:28:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/</guid><description>什么是服务治理 当我们的服务与服务之间通讯调用的时候，如果简单粗暴的用httpclient去请求，不经过第三方的组件管理，然后访问路径写死，那么如果有一个服务更换了路径，所有的服务都需要手动更换该服务的访问路径。维护的成本很高。
就是因为出现了这些问题，所以引入了服务治理(SOA governance)这个概念，同时衍生了这类的实现组件，也就是注册中心。典型的代表：zookeeper，Eureka，Consul。服务治理也引入了 服务调用、负载均衡、容错等功能。
简单的总结：把服务看成一个地方。当我们服务调用的时候，就是从一个地方到另一个地方，这时候我们需要地图导航才能到达，当我们去的路程有一段路可能修路，无法通过的时候，导航就会帮我们规划另一条路线。这里的导航就是注册中心，会一定的时间就会刷新一下路况，就好像我们注册中心 (Erueka为例) 每隔30秒就会刷新一下服务的地址。
Eureka设计 Eureka采用了CS的设计构架，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server中心并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否运行正常。
当服务器(服务提供方)启动的时候，会把当前自己服务器的信息(服务地址、通信地址等)以别名的方式注册到注册中心上。另一方(服务消费方)以该别名的方式去注册中心上获取到实际的服务器通讯地址，然后再实现本地RPC调用远程RPC。调用框架核心在于注册中心，注册中心管理每个服务与服务间的依赖关系(服务治理)，也就是说，在任何RPC远程框架中，都会有一个注册中心。
Eureka
Eureka Server: 提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态一致(最终一致性) Service Provider: 服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到 Service Consumer: 服务消费方，从Eureka获取注册服务列表，从而能够消费服务 Eureka组件 Eureka包含两个组件：Eureka Server和Eureka Client
Eureka Server Eureka Server提供注册服务，各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表会储存所有可用服务节点的信息，服务节点的信息可在管理界面中直观的看到。
Eureka Server 同时也是一个Eureka Client 在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server 进行拉取注册表、服务注册和发送心跳等操作。
Eureka Client Eureka Client 可向注册中心进行访问来获取服务提供方通讯地址。在启动后，Eureka Client将会向Eureka Server发送心跳(默认间隔为30s)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server则会将该节点从服务器注册表中移除(默认90s)。
服务提供方 启动后，向注册中心发起register请求，注册服务 在运行过程中，定时向注册中心发送renew心跳，证明&amp;quot;我还活着&amp;quot; 停止服务提供者，向注册中心发起cancel请求，清空当前服务注册信息 服务消费方 启动后，从注册中心拉取服务注册信息 在运行过程中，定时更新服务注册信息 发起向服务提供方远程调用时</description></item><item><title>[笔记]SpringCloud学习01: 项目的搭建</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A001-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/</link><pubDate>Thu, 12 Mar 2020 00:55:33 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A001-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/</guid><description>建立项目 父工程的创建 IDEA: Create New Project -&amp;gt; Maven -&amp;gt; 输入groupid和artifactId -&amp;gt; 完成
之后在IDEA设置中还有几个地方要设置:
Build选项中的Compiler选项中的Annotation Processing目录中，在Enable annotation processing选项前打勾 Build选项中的Compiler选项中的Java Compiler目录中，将Target bytecode version 选为8 (可选)Editor选项中的File Types目录中，将*.iml;*.idea; 添加到Ignore files and patterns中，这是用于在IDEA资源管理器中隐藏对应后缀的文件 修改pom.xml文件，在version下添加&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
&amp;lt;groupId&amp;gt;com.ilirus.springcloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;irscloud&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; 修改properties
&amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;junit.version&amp;gt;4.12&amp;lt;/junit.version&amp;gt; &amp;lt;log4j.version&amp;gt;1.2.17&amp;lt;/log4j.version&amp;gt; &amp;lt;lombok.version&amp;gt;1.16.18&amp;lt;/lombok.version&amp;gt; &amp;lt;mysql.version&amp;gt;8.0.14&amp;lt;/mysql.version&amp;gt; &amp;lt;druid.version&amp;gt;1.1.16&amp;lt;/druid.version&amp;gt; &amp;lt;mybatis.spring.boot.version&amp;gt;2.1.2&amp;lt;/mybatis.spring.boot.version&amp;gt; &amp;lt;/properties&amp;gt; 修改dependencies
&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- springboot 2.2.2 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring cloud hoxton.SR1 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR1&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description></item><item><title>[笔记]SpringCloud学习00: 微服务与SpringCloud</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A000-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8Espringcloud/</link><pubDate>Wed, 11 Mar 2020 21:26:57 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A000-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8Espringcloud/</guid><description>微服务是什么 　微服务是一种架构模式，它提倡将单一应用程序划分为一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务间采用轻量级的通信机制互相协作(例如基于HTTP协议的RESTful API)。
每个服务都围绕具体业务进行构建，并能够独立的被部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。
微服务架构应满足哪些维度 服务的注册与发现 服务调用 服务熔断 负载均衡 服务降级 服务消息队列 配置中心管理 服务网关 服务监控 全链路追踪 自动化构建部署 服务定时任务调度操作 Spring Cloud 是什么 融合、协调、组装微服务相关技术，使构建分布式系统变更更容易。是分布式微服务架构的一种技术体现，是多种微服务架构落地技术的集合体。(微服务全家桶)
Spring Cloud 版本命名规则 Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为管理Spring Cloud 与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud 版本对应的子项目版本。
为避免Spring Cloud 的版本号与子项目版本号混淆，Spring Cloud 采用了英国伦敦地铁站的名称来命名，以字母A-Z的形式来发布迭代版本，也就是说Spring Cloud 是以字母作为版本号。
当Spring Cloud 的发布内容累积到临界点或一个重大BUG被解决后，会发布一个service releases 版本，简称SR版本(SR1、SR2等)。
Spring Cloud 和Spring Boot 的版本对应 在https://spring.io/projects/spring-cloud网页底部可查看SpringCloud和SpringBoot的版本对应关系
SpringCloud和SpringBoot对应版本
更详细的依赖信息需要在https://start.spring.io/actuator/info中查讯
在https://spring.io/projects/spring-cloud#learn页面中找到Spring Cloud 的Reference Doc在这个页面里可以找到官方推荐的Spring Boot版本</description></item></channel></rss>