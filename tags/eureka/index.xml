<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Eureka on Ilirus</title><link>https://chaosalphard.github.io/tags/eureka/</link><description>Recent content in Eureka on Ilirus</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 20 Mar 2020 03:02:19 +0000</lastBuildDate><atom:link href="https://chaosalphard.github.io/tags/eureka/index.xml" rel="self" type="application/rss+xml"/><item><title>[笔记]SpringCloud学习07: Eureka自我保护</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</link><pubDate>Fri, 20 Mar 2020 03:02:19 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</guid><description>Eureka 自我保护机制 保护模式主要用于一组客户端和服务端之间存在网络分区场景下的保护，一旦进入保护模式，Eureka Server会尝试保护其服务注册表中的信息，将不再删除服务注册表中的信息，也就是不会注销任何微服务
一句话概括: 如果某一时刻，Eureka Server中某个微服务不可用了，Eureka不会立即清除，而是会尝试对该微服务的信息进行保存 (CAP中的AP)
为什么需要自我保护机制 为了防止Eureka Client可以正常运行，但与Eureka Server直接网络不同的情况下，Eureka Server错误地将可以正常运行的Client端移除
默认情况下，如果Eureka Server在一定时间内(默认90s)没有接收到某个服务实例的心跳时，Eureka Server会注销该实例。但当网络分区故障发生时(延时，拥挤)，微服务与Eureka Server之间无法正常通讯时，超时移除节点是不正确的行为——微服务自身很可能是正常状态，也就是说不应该注销此服务。
Eureka通过自我保护模式来解决这个问题——当Eureka Server短时间内丢失过多Client端时，那么这个节点将进入自我保护模式。
也就是说宁可保留错误的服务注册信息，也不会盲目注销任何可能正常的服务实例
如何判断Eureka 是否进入了自我保护模式 如果在Eureka Server首页看到以下提示，则说明Eureka进入了保护模式
EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&amp;rsquo;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
如何禁止自我保护机制 在Erueka Server 端的application.yml文件中，添加以下内容
eureka:server:# 关闭自我保护机制enable-self-preservation:false# 移除服务的超时时间，单位毫秒eviction-interval-timer-in-ms:15000在Eureka Client 端的application.yml文件中，添加以下内容
eureka:# eureka 客户端instance:# Eureka Client 端向Server 端发送心跳的时间间隔，单位秒，默认30s# 修改心跳时间主要是因为修改了Server 端的超时时间(15000ms = 15s)# 所以对应的修改Client 端的心跳时间lease-renewal-interval-in-seconds:5# Eureka Server 端在收到最后一次心跳后等待时间上限，单位秒，超时将剔除服务，默认90slease-expiration-duration-in-seconds:15</description></item><item><title>[笔记]SpringCloud学习06: Eureka服务发现</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Fri, 20 Mar 2020 02:03:59 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>获取Eureka Server 端注册成功的服务信息 对于注册进Eureka里面的微服务，可以通过服务发现来获取该服务的信息
修改对应工程(Eureka Client 端)的Controller
package com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.enums.Status; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; @RestController @RequestMapping(&amp;#34;/payment&amp;#34;) @Slf4j public class PaymentController { @Resource private DiscoveryClient discoveryClient; @GetMapping(&amp;#34;/discovery&amp;#34;) public CommonResult discovery() { List&amp;lt;String&amp;gt; services = discoveryClient.getServices(); return CommonResult.ofData(Status.SUCCESS, services); } @GetMapping(&amp;#34;/discovery/{instances}&amp;#34;) public CommonResult discovery(@PathVariable String instances) { List&amp;lt;ServiceInstance&amp;gt; serviceInstances = discoveryClient.getInstances(instances); return CommonResult.ofData(Status.SUCCESS, serviceInstances); } } 修改启动类
package com.ilirus.springcloud; import org.</description></item><item><title>[笔记]SpringCloud学习05: 服务提供方集群</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/</link><pubDate>Thu, 19 Mar 2020 22:02:13 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/</guid><description>服务提供方集群搭建 参考之前搭建好的服务提供方工程，再创建一个新的工程，要注意application.yml中，spring.application.name属性要和之前的一致，完成后启动服务
eureka
服务消费方请求地址修改 在消费方工程中，将请求地址改为微服务名称
package com.ilirus.springcloud.controller; /* import ... */ @RestController @RequestMapping(&amp;#34;/consumer&amp;#34;) @Slf4j public class OrderController { private static final String PAYMENT_URL = &amp;#34;http://irs-provider-payment/payment&amp;#34;; @Resource private RestTemplate restTemplate; @GetMapping(&amp;#34;/payment/create&amp;#34;) public CommonResult create(Payment payment) { return restTemplate.postForObject(PAYMENT_URL+&amp;#34;/create&amp;#34;, payment, CommonResult.class); } /* ... */ } 因为目前irs-provider-payment服务下有两个实例，直接使用服务名并不能让程序知道你想用具体哪一个，所以还需要进一步配置
RestTemplate 配置负载均衡 修改RestTemplate配置类
package com.ilirus.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 至此，全部配置完成</description></item><item><title>[笔记]SpringCloud学习04: Eureka集群</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/</link><pubDate>Tue, 17 Mar 2020 23:33:16 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/</guid><description>Eureka 集群原理 我们假设有三台 Eureka Server 组成的集群，只要三个地方的任意一个Eureka Server不出现问题，都不会影响整个架构的稳定性。
Eureka集群
从图中可以看出Eureka Server集群相互之间通过Replicate来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl 指向其他节点。
如果某台Eureka Server 宕机，Eureka Client 的请求会自动切换到新的Eureka Server 节点。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它Eureka Server 当前所知的所有节点中。
另外Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个Eureka Server 同时也是Eureka Client，多个Eureka Server 之间通过P2P的方式完成服务注册表的同步。
Eureka Server 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。
Eureka保证AP (CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance))
Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka Client 在向某个Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。
Eureka 集群搭建 新建一个Eureka Server，并修改application.yml文件
server:port:7002eureka:instance:hostname:eureka7002.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7001.com:7001/eureka/修改之前的单机eureka配置文件
server:port:7001eureka:instance:hostname:eureka7001.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7002.com:7002/eureka/ 因为是在同一台机器上，所以需要修改host文件将eureka7001.com和eureka7002.com映射为127.0.0.1
微服务注册进集群 回到之前的子工程中，修改application.yml文件中的eureka配置
eureka:# eureka 客户端client:register-with-eureka:truefetch-registry:trueservice-url:# 服务中心链接defaultZone:http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka启动服务，查看是否正确 集群</description></item><item><title>[笔记]SpringCloud学习03: Eureka的搭建</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 16 Mar 2020 00:36:52 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/</guid><description>Eureka Server端的搭建 创建一个Maven项目，在pom.xml中写入以下依赖:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --&amp;gt; &amp;lt;/dependency&amp;gt; 创建启动类
package com.ilirus.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaServerMain7001.class, args); } } 配置yml
server:port:7001eureka:# eureka 服务端instance:hostname:localhost# eureka服务端实例名称client:register-with-eureka:false# 是否向服务中心注册自己feth-registry:false# 是否向服务中心检索已有的注册信息service-url:# 设置Eureka Server 的交互地址。查询服务和注册服务都需要依赖这个地址defaultZone:http://${eureka.instance.hostname}:${server.port}/eureka/启动工程并查看是否有误
Eureka Client端的注册 回到之前的子项目中，向pom.xml中添加以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 修改application.yml文件
spring:application:name:irs-provider-payment8001# 名称eureka:# eureka 客户端client:register-with-eureka:true# 向服务中心注册自己fetch-registry:true# 向服务中心获取已有的注册信息, 集群必须设置为true才能配合ribbon使用负载均衡service-url:# 服务中心链接defaultZone:http://localhost:7001/eureka修改启动类并添加@EnbaleEurekaClient注解
package com.ilirus.springcloud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.</description></item><item><title>[笔记]SpringCloud学习02: Eureka基础</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 14 Mar 2020 03:28:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/</guid><description>什么是服务治理 当我们的服务与服务之间通讯调用的时候，如果简单粗暴的用httpclient去请求，不经过第三方的组件管理，然后访问路径写死，那么如果有一个服务更换了路径，所有的服务都需要手动更换该服务的访问路径。维护的成本很高。
就是因为出现了这些问题，所以引入了服务治理(SOA governance)这个概念，同时衍生了这类的实现组件，也就是注册中心。典型的代表：zookeeper，Eureka，Consul。服务治理也引入了 服务调用、负载均衡、容错等功能。
简单的总结：把服务看成一个地方。当我们服务调用的时候，就是从一个地方到另一个地方，这时候我们需要地图导航才能到达，当我们去的路程有一段路可能修路，无法通过的时候，导航就会帮我们规划另一条路线。这里的导航就是注册中心，会一定的时间就会刷新一下路况，就好像我们注册中心 (Erueka为例) 每隔30秒就会刷新一下服务的地址。
Eureka设计 Eureka采用了CS的设计构架，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server中心并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否运行正常。
当服务器(服务提供方)启动的时候，会把当前自己服务器的信息(服务地址、通信地址等)以别名的方式注册到注册中心上。另一方(服务消费方)以该别名的方式去注册中心上获取到实际的服务器通讯地址，然后再实现本地RPC调用远程RPC。调用框架核心在于注册中心，注册中心管理每个服务与服务间的依赖关系(服务治理)，也就是说，在任何RPC远程框架中，都会有一个注册中心。
Eureka
Eureka Server: 提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态一致(最终一致性) Service Provider: 服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到 Service Consumer: 服务消费方，从Eureka获取注册服务列表，从而能够消费服务 Eureka组件 Eureka包含两个组件：Eureka Server和Eureka Client
Eureka Server Eureka Server提供注册服务，各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表会储存所有可用服务节点的信息，服务节点的信息可在管理界面中直观的看到。
Eureka Server 同时也是一个Eureka Client 在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server 进行拉取注册表、服务注册和发送心跳等操作。
Eureka Client Eureka Client 可向注册中心进行访问来获取服务提供方通讯地址。在启动后，Eureka Client将会向Eureka Server发送心跳(默认间隔为30s)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server则会将该节点从服务器注册表中移除(默认90s)。
服务提供方 启动后，向注册中心发起register请求，注册服务 在运行过程中，定时向注册中心发送renew心跳，证明&amp;quot;我还活着&amp;quot; 停止服务提供者，向注册中心发起cancel请求，清空当前服务注册信息 服务消费方 启动后，从注册中心拉取服务注册信息 在运行过程中，定时更新服务注册信息 发起向服务提供方远程调用时</description></item></channel></rss>