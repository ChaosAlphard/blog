<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Ilirus</title><link>https://chaosalphard.github.io/tags/java/</link><description>Recent content in Java on Ilirus</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 25 May 2023 20:22:46 +0800</lastBuildDate><atom:link href="https://chaosalphard.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java开发知识点简单总结-数据库</title><link>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Thu, 25 May 2023 20:22:46 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>MySQL 数据库三范式 第一范式 1NF：表中字段的数据，不可以再拆分
这张表因为姓名字段可再拆分所以不符合第一范式
ID 姓名 年龄 1 销售部小张 28 而这张表符合
ID 部门 姓名 年龄 1 销售部 小张 28 第二范式 2NF：在满足第一范式的情况下，遵循唯一性，消除部分依赖。
即：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值
通俗来讲就是一个表只能描述一件事情
学号 姓名 年龄 课程名称 成绩 学分 001 小张 28 语文 90 3 001 小张 28 数学 90 2 学号做主键，可确定姓名，但不能确定课程与成绩。所以不符合第二范式</description></item><item><title>Java开发知识点简单总结-Spring</title><link>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/</link><pubDate>Thu, 25 May 2023 20:21:46 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/</guid><description>Spring Spring IoC IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。
为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）
将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。
Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。
什么是 Spring Bean 简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。
将一个类声明为 Bean 的注解有哪些 @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。 @Component 和 @Bean 的区别是什么 @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。 @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。 @Autowired 和 @Resource 的区别是什么 @Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)</description></item><item><title>Java开发知识点简单总结</title><link>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 May 2023 15:21:46 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</guid><description>Java基础 面向对象的特点 封装，继承，多态
包装类型的缓存机制 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False
接口和抽象类有什么共同点和区别 共同点 ：
都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。 区别 ：
接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。 深拷贝和浅拷贝区别？什么是引用拷贝？ 引用拷贝就是两个不同的引用指向同一个对象。如 Object a = new Object(); Object b = a; 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。 字符串 String s1 = new String(&amp;ldquo;abc&amp;rdquo;);这句话创建了几个字符串对象？
会创建 1 或 2 个字符串对象。
如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象(new String()和&amp;quot;abc&amp;quot;)。否则创建一个字符串对象(new String())</description></item><item><title>Java中HashMap的实现原理</title><link>https://chaosalphard.github.io/p/java%E4%B8%ADhashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 24 May 2023 00:16:32 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E4%B8%ADhashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>实现原理 HashMap的实现原理
HashMap 是由数组与链表组成的，又叫链表散列。
HashMap 初始容量默认为16，如果在创建 HashMap 手动指定容量，则会自动将容量调整到大于指定容量且最接近指定容量2的整数次幂大小。
当调用 put() 方法储存 K/V键值对 时，会首先计算 K 的 hash 值，然后根据数组长度，计算得出对应的数组下标，如果 K 的 hash 值已经存在，且它们两者的 equals 返回 true，则更新键值对的值，如果返回 fasle，则说明发生 hash碰撞，jdk1.7之前会将新的键值对插入到链表头部，jdk1.8之后则是插入到链表尾部。
当数组中的元素个数大于 容量*负载因子(默认为0.75) 时，数组会进行扩容，扩容后大小变为2倍。
如果由于碰撞导致链表大小超过8，并且数组大小大于等于64时，则会将其转换为红黑树以提高查询效率，如果由于删除元素导致红黑树节点数量少于6时，则会转换为链表。
HashMap的容量为什么是2的整数次幂 在 HashMap 中，存储桶（buckets）的数量等于数组的长度。通过哈希函数将键映射到对应的存储桶，然后在存储桶中查找或存储对应的值。使用 2 的幂次方作为数组的长度，可以通过位运算代替取模运算，提高计算效率。
此外，使用 2 的幂次方作为数组长度还能够更好地分散哈希码的分布，减少哈希冲突的概率。如果数组长度不是 2 的幂次方，那么在计算哈希码与数组长度取模时，低位可能不会被充分利用，可能导致一些位的哈希码无法影响到存储桶的选择，从而增加哈希冲突的可能性。
因此，为了提高散列算法的效率和减少哈希冲突，HashMap 选择将长度设置为 2 的幂次方。这样可以通过位运算代替取模运算，提高计算效率，并且更好地分散哈希码的分布，减少哈希冲突的概率。
HashMap的负载因子为什么默认是0.75 负载因子是 HashMap 中用于衡量存储桶利用率的一个参数。在 HashMap 中，负载因子表示存储桶中键值对的平均数量与存储桶数组长度的比值。
较低的负载因子意味着存储桶中的键值对数量相对较少，可以更好地分散键的hash，减少多个键映射到同一个存储桶的情况，从而减少哈希冲突的概率。
较高的负载因子意味着更高存储桶利用率。可以用更少的存储桶储存更多的键值对，节省了更多的空间。
使用0.75作为默认负载因子是为了在减少hash碰撞与提高存储桶利用率之间达到一种平衡。
Hash的计算方法 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.</description></item><item><title>Java中ArrayList与LinkedList的区别</title><link>https://chaosalphard.github.io/p/java%E4%B8%ADarraylist%E4%B8%8Elinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 22 May 2023 13:58:14 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E4%B8%ADarraylist%E4%B8%8Elinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>ArrayList的底层实现 ArrayList 底层是基于数组来实现的，而数组是使用一组连续的空间来存储数据类型相同的数据，并且数组的空间大小是固定的。
因为数组的空间大小固定，存储的数据类型也相同，所以我们就可以通过寻址公式类随机访问数组中的任意一个下标的元素。
address[i] = baseAddress + i * dataTypeSize 因为 ArrayList 基于数组实现，而数组的空间大小是固定的，所以当数组的空间用完了，就需要对 ArrayList 底层的数组进行扩容。
当使用 ArrayList 默认的构造函数创建对象时，底层的数组实际是被赋值为一个空数组，但我们第一次调用往其中添加元素时，才会触发具体扩容逻辑，第一次扩容默认的初始化容量为10，使用了延迟加载的实现方式避免空间浪费。
ArrayList的扩容逻辑
在调用 add() 方法时，会判断 ArrayList 中 elementData 这个数组的容量是否等于 ArrayList 的大小，也就是判断 elementData 数组是不是满的，如果等于则说明当前数组空间满了，则调用 grow() 方法进行扩容，之后再添加元素到到数组中。
在看看 grow() 方法中又调用了一个带参方法 grow(int minCapacity) 参数是当前大小+1，那么我们来看下这个带参数的 grow 方法。
private Object[] grow(int minCapacity) { // 记录容量大小 int oldCapacity = elementData.length; // 判断容量大于0，并且数组不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA // DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个数组是使用ArrayList的无参构造函数时赋值给elementData的 // 也就是说这个if语句不会处理使用默认的无参构造函数创建的数组 if (oldCapacity &amp;gt; 0 || elementData !</description></item><item><title>单例模式</title><link>https://chaosalphard.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 21 Sep 2021 22:03:11 +0800</pubDate><guid>https://chaosalphard.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
实现 懒汉式 需要时加载 线程不安全 public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 启动时加载 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 双检锁 即 Double-Checked Locking</description></item><item><title>Minecraft Mod 开发手册04: 合成表与掉落物</title><link>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C04-%E5%90%88%E6%88%90%E8%A1%A8%E4%B8%8E%E6%8E%89%E8%90%BD%E7%89%A9/</link><pubDate>Sun, 06 Jun 2021 02:44:16 +0800</pubDate><guid>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C04-%E5%90%88%E6%88%90%E8%A1%A8%E4%B8%8E%E6%8E%89%E8%90%BD%E7%89%A9/</guid><description>添加合成表 在resources/data/&amp;lt;你的Mod注册的命名空间&amp;gt;/recipes 文件夹下，创建一个json 文件，名称没有要求，但最好以被添加合成表的物品的名称为前缀。
添加无序合成表 以mod_icon 为例
mod_icon.json
{ // 指定该合成表为无序合成 &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shapeless&amp;#34;, // 指定合成需要的原料, 物品名字格式为 &amp;lt;命名空间&amp;gt;:&amp;lt;物品名称&amp;gt; &amp;#34;ingredients&amp;#34;: [{ &amp;#34;item&amp;#34;: &amp;#34;minecraft:melon_slice&amp;#34; }, { &amp;#34;item&amp;#34;: &amp;#34;minecraft:carrot&amp;#34; }, { &amp;#34;item&amp;#34;: &amp;#34;minecraft:sweet_berries&amp;#34; }, { &amp;#34;item&amp;#34;: &amp;#34;minecraft:pumpkin_pie&amp;#34; }, { &amp;#34;item&amp;#34;: &amp;#34;minecraft:honey_bottle&amp;#34; }, { &amp;#34;item&amp;#34;: &amp;#34;minecraft:milk_bucket&amp;#34; }], // 指定合成结果 &amp;#34;result&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;irs_widget_pack:mod_icon&amp;#34;, &amp;#34;count&amp;#34;: 4 } } 给mod_icon 添加第二个合成表
mod_icon_from_mod_icon_block.json
{ &amp;#34;type&amp;#34;: &amp;#34;minecraft:crafting_shapeless&amp;#34;, &amp;#34;ingredients&amp;#34;: [{ &amp;#34;item&amp;#34;: &amp;#34;irs_widget_pack:mod_icon_block&amp;#34; }], &amp;#34;result&amp;#34;: { &amp;#34;item&amp;#34;: &amp;#34;irs_widget_pack:mod_icon&amp;#34;, &amp;#34;count&amp;#34;: 8 } } 添加有序合成表 以mod_icon_block 为例</description></item><item><title>Minecraft Mod 开发手册03: 第一个方块</title><link>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C03-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%B9%E5%9D%97/</link><pubDate>Sat, 05 Jun 2021 22:42:08 +0800</pubDate><guid>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C03-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%B9%E5%9D%97/</guid><description>新建方块 class ModIconBlock: Block(settings) { companion object { // 使用木板的方块预设 val settings: Settings = Settings.of(Material.WOOD) // 方块硬度 .strength(2.0F) // 方块声音 .sounds(BlockSoundGroup.WOOD); // 方块实例 val INSTANCE = ModIconBlock(); // 方块的物品形式实例 val ITEM_INSTANCE = BlockItem(instance, Item.Settings().rarity(Rarity.RARE).group(ModItemGroup.ITEM)); val identifier = Identifier(&amp;#34;irs_widget_pack&amp;#34;, &amp;#34;mod_icon_block&amp;#34;) } } 注册方块 @Suppress(&amp;#34;unused&amp;#34;) fun init() { // 创建方块标识，方块注册完成后还需要注册物品形式的物品标识 Registry.register(Registry.BLOCK, ModIconBlock.identifier, ModIconBlock.INSTANCE) Registry.register(Registry.ITEM, ModIconBlock.identifier, ModIconBlock.ITEM_INSTANCE) } 给方块添加材质 添加材质文件 在resources/assets/&amp;lt;你的Mod注册的命名空间&amp;gt;/textures/block 文件夹下，创建一个与你添加物品同名的png 文件。
配置方块状态 在resources/assets/&amp;lt;你的Mod注册的命名空间&amp;gt;/blockstates 文件夹下，创建一个与你添加物品同名的json 文件。</description></item><item><title>Minecraft Mod 开发手册02: 新建物品栏分组</title><link>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C02-%E6%96%B0%E5%BB%BA%E7%89%A9%E5%93%81%E6%A0%8F%E5%88%86%E7%BB%84/</link><pubDate>Sun, 23 May 2021 23:01:27 +0800</pubDate><guid>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C02-%E6%96%B0%E5%BB%BA%E7%89%A9%E5%93%81%E6%A0%8F%E5%88%86%E7%BB%84/</guid><description>注册物品栏分组 新建一个类，用于存放自定义的物品栏分组的实例
class ModItemGroup { companion object { @JvmStatic val ITEM: ItemGroup = FabricItemGroupBuilder .build(Identifier(&amp;#34;irs_widget_pack&amp;#34;,&amp;#34;item&amp;#34;)) { ItemStack(ModIcon.instance) } } } FabricItemGroupBuilder.build方法接收两个参数，第一个是物品栏分组的名称，第二个是显示的图标
将物品放入自定义物品栏中 修改之前定义好的物品
@JvmStatic val settings: Settings = Settings() // 物品分组修改为我们自定义的分组 .group(ModItemGroup.ITEM) 添加翻译 修改之前的语言文件，按照对应的格式，为新增的物品分组添加翻译
{ &amp;#34;itemGroup.irs_widget_pack.item&amp;#34;: &amp;#34;物品&amp;#34; } 进入游戏，即可看到效果 成果</description></item><item><title>Minecraft Mod 开发手册01: 第一个物品</title><link>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C01-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%A9%E5%93%81/</link><pubDate>Fri, 21 May 2021 21:13:06 +0000</pubDate><guid>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C01-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%89%A9%E5%93%81/</guid><description>向Minecraft中添加物品 定位入口 找到fabric.mod.json 文件中entrypoints.main 键所对应的类
{ // ... &amp;#34;entrypoints&amp;#34;: { &amp;#34;main&amp;#34;: [ &amp;#34;com.ilirus.widget.pack.WidgetPackKt::init&amp;#34; ] }, // ... } 我这里的值是com.ilirus.widget.pack.WidgetPackKt::init，说明com.ilirus.widget.pack 包下WidgetPack.kt 类中的init 方法是Mod的入口
WidgetPack.kt
@Suppress(&amp;#34;unused&amp;#34;) fun init() { println(&amp;#34;Hello Minecraft!&amp;#34;) } 可以看到init 方法里面什么都没有，不过这个类之后会用到，所以先记下来
新建物品 新建一个class，继承net.minecraft.item.Item 类，Item类的构造器接收一个参数类型为Settings 类的参数，这个Settings 类是Item 的内部类。
Settings 类可以对Item 的属性进行配置。
class ModIcon(settings: Settings) : Item(settings) { companion object { val settings: Settings = Settings() // 物品分组, 配置物品出现在创造模式物品栏的哪一个选项卡中 .group(ItemGroup.MISC) // 此物品作为合成材料参与合成后返回的物品, // 比如牛奶桶参与合成后会返回铁桶 // .recipeRemainder(Items.HONEYCOMB) // 稀有度 (物品名的颜色) .</description></item><item><title>Minecraft Mod 开发手册00: 开发环境搭建</title><link>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C00-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Thu, 20 May 2021 00:02:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/minecraft-mod-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C00-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>Fabric开发环境搭建 Minecraft目前有Forge和Fabric两大Mod平台，这里我选择使用较新的Fabric平台。
开发工具 jdk8以上 任意IDE 创建项目 下载Fabric官方的项目初始模板，Kotlin开发人员可以下载Kotlin版 修改gradle.properties 文件 修改maven_group 为你的组织名(类似于Maven中的GroupId) 修改archives_base_name 为你的模组名(类似于Maven中的ArtifactId) 修改minecraft_version 为你的模组的目标版本(你要为哪个Minecraft版本开发Mod) 修改yarn_mappings、loader_version 与fabric_version 为minecraft_version 对应的版本，版本对应关系可在这里查看 修改src目录下的目录名称，对应到你的maven_group与archives_base_name 修改src/resources/fabric.mod.json id 为你的模组的命名空间 entrypoints.main 为你的模组的入口(main方法所在类) mixins 为mixins.json 所在位置 修改&amp;lt;modid&amp;gt;.mixins.json(modid为你的模组的命名空间, fabric.mod.json中id对应的值) package 为mixin所在的包名 client 为mixin的类名 最后，将修改好的项目导入到你的IDE中 修改Gradle构建编译器(可选) 如果你使用的是IntelliJ IDEA, 它默认使用Gradle来构建你的项目，而这在Fabric中是不必要的，通过以下步骤来使你的IntelliJ IDEA使用自己的编译器
在Build Tools -&amp;gt; Gradle 设置项中，修改Build and run using 以及Run tests using 选项为IntelliJ IDEA 在Project Structure -&amp;gt; Project 设置项中，修改Project compiler output 为$PROJECT_DIR$/out 启动Minecraft 在Gradle任务中执行runClient 即可启动Minecraft客户端</description></item><item><title>使用ControllerAdvice统一封装Controller返回数据</title><link>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8controlleradvice%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85controller%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</link><pubDate>Sun, 10 Jan 2021 08:02:12 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8controlleradvice%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85controller%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</guid><description>在给前端提供Api接口时，通常会约定好一个统一返回格式，这样方便前端处理返回结果
@RestController @RequestMapping(&amp;#34;/index&amp;#34;) public class IndexController { @GetMapping public R&amp;lt;Data&amp;gt; index() { return R.ofSuccess(new Data()); } } 但每次都要用统一返回类手动封装一次再返回还是比较麻烦的，可以使用@ControllerAdvice 注解来进行统一封装，避免每次手动封装
定义ControllerAdvice
// 这里的annotations = ApiResult.class 代表只有在类上有@ApiResult 注解的Controller 才会被处理 // 如果不写则默认对所有Controller 进行处理 @RestControllerAdvice(annotations = ApiResult.class) public class ResponseAdvice implements ResponseBodyAdvice&amp;lt;Object&amp;gt; { @Override public boolean supports(MethodParameter returnType, Class&amp;lt;? extends HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterType) { // 判断返回类型是否已经是定义好的统一返回类型, 以及@ApiResult 注解是否启用 // 返回true 则表示进入下一步处理, 返回false 则表示不做处理, 原样返回 return !returnType.getParameterType().isAssignableFrom(R.class)&amp;amp;&amp;amp; !returnType.hasMethodAnnotation(ApiResult.Disable.class); } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&amp;lt;?</description></item><item><title>Validate自定义校验注解</title><link>https://chaosalphard.github.io/p/validate%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</link><pubDate>Wed, 18 Nov 2020 20:12:21 +0000</pubDate><guid>https://chaosalphard.github.io/p/validate%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</guid><description>自定义Validator校验注解 通常来说, Hibernate Validation提供的注解已经够用了, 但有时候还是需要根据业务自定义校验规则.
自定义注解 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE }) @Repeatable(Time.List.class) // 设置自定义注解实现类 @Constraint(validatedBy = {TimeValidate.class}) public @interface Time { boolean allowNull() default false; String regexp() default &amp;#34;^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9]$&amp;#34;; String message() default &amp;#34;时间格式错误&amp;#34;; Class&amp;lt;?&amp;gt;[] groups() default {}; Class&amp;lt;? extends Payload&amp;gt;[] payload() default {}; @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE }) public @interface List { Time[] value(); } } 自定义注解实现 // 需要实现ConstraintValidator, 第一项参数是要校验的注解, 第二项是要校验的值的类型 public class TimeValidate implements ConstraintValidator&amp;lt;Time, String&amp;gt; { private boolean allowNull; private Pattern regexp; // 初始化 @Override public void initialize(Time annotation) { allowNull = annotation.</description></item><item><title>Validate参数分组校验</title><link>https://chaosalphard.github.io/p/validate%E5%8F%82%E6%95%B0%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/</link><pubDate>Tue, 10 Nov 2020 12:30:22 +0000</pubDate><guid>https://chaosalphard.github.io/p/validate%E5%8F%82%E6%95%B0%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/</guid><description>Validator分组校验 定义接口, 接口里面不需要写任何东西, Validator会把接口视为一个一个的组
public interface IGet {} public interface IList {} public interface IAdd {} public interface IEdit {} public interface IDelete {} // 如果一个组继承了另一个组, // 则在校验属于这个组的参数时, // 也会一并校验被继承组的参数 public interface ISexFilter extends Default {} 修改参数实体类
@Data public class Param { // groups 定义该字段所属的&amp;#34;组&amp;#34; @NotNull(message = &amp;#34;id不能为空&amp;#34;, groups = {IGet.class, IEdit.class, IDelete.class}) @Null(message = &amp;#34;获取列表时不需要ID&amp;#34;, groups = IList.class) private Integer id; @NotBlank(message = &amp;#34;name不能为空&amp;#34;, groups = IAdd.class) @Null(message = &amp;#34;不能修改name&amp;#34;, groups = IEdit.</description></item><item><title>使用Validate实现参数统一校验以及自定义校验规则</title><link>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8validate%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/</link><pubDate>Sun, 08 Nov 2020 22:40:20 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8validate%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/</guid><description>JSR-303是一项标准, JSR-349是其的升级版本, 添加了一些新特性, 这项标准规定了一些校验规范, 如@Null, @NotNull, @Pattern, 位于javax.validation.constraints包下, 只提供规范不提供实现.
Hibernate Validation是对这个规范的实践, 他提供了相应的实现, 并增加了一些其他校验注解, 如@Email, @Length, @Range等.
引入Validator依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate.validator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;6.1.6.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置Validator Validator默认会对所有数据进行校验, 然后返回结果, 如果想要在校验到数据不符合规则时直接返回结果的话, 则需要进行配置
@Configuration public class ValidatorConfiguration { @Bean public Validator validator() { return Validation.byProvider(HibernateValidator.class) .configure() // 设置校验到任意数据不符合规则时直接返回结果, 不再对剩余数据进行校验 .failFast(true) .buildValidatorFactory() .getValidator(); } } 使用Validator对Controller参数进行校验 参数实体类
@Data public class Param { @NotNull(message = &amp;#34;id不能为空&amp;#34;) private Integer id; @NotBlank(message = &amp;#34;name不能为空&amp;#34;) private String name; @NotNull(message = &amp;#34;age不能为空&amp;#34;) private Integer age; @NotNull(message = &amp;#34;sex不能为空&amp;#34;) private Byte sex; private String time; } Controller</description></item><item><title>使用自定义断言处理常见的异常</title><link>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 19 Oct 2020 23:37:23 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/</guid><description>Java中空判断随处可见，通常我们都是手动判断是否为空，然后再抛出自定义异常以及记录信息，例如:
var data = dao.findById(id); if(data == null) { log.error(&amp;#34;数据为空, id{}&amp;#34;, id); throw new CustomException(Status.USER_NOT_EXIST); } 这样的代码写多了就觉得麻烦，可不可以简化一下呢
使用Assert替代null判断 　我们都知道sprng中有一个Assert类，其中有一个方法notNull() 可以用来判断是否为空，并且输出自定义提示，何不根据此改造一下，做一个自定义的Assert类
创建枚举类接口 创建默认枚举方法，需要与你自定义枚举中的属性对应
public interface IBaseEnum { int getCode(); String getMessage(); } 创建自定义异常 public class CustomException extends Exception { private int code; private String detail; private Object data; public CustomException(IBaseEnum enums, String detail, Object data) { super(enums.getMessage()); this.code = enums.getCode(); this.detail = detail; this.data = data; } public CustomException(int code, String message, String detail, Object data) { super(message); this.</description></item><item><title>Java是值传递还是引用传递</title><link>https://chaosalphard.github.io/p/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 20 Apr 2020 23:45:38 +0000</pubDate><guid>https://chaosalphard.github.io/p/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid><description>进入正题之前先简单说说值传递和引用传递的区别
按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
下面是我用Rust来做的一个简单示范。
Rust
可以看到，虽然call_by_value函数和call_by_reference函数都将接收到的参数的值修改为了12450，但是由于call_by_reference函数接收的是by_ref变量的引用，所以在函数内修改by_ref的值会影响到函数外部的by_ref变量，而call_by_value函数接收的是by_val变量的值，所以在函数内修改by_val的值不会影响到函数外部的by_val变量。
对于基本数据类型, Java是值传递还是引用传递? 看下图
00
可以看到，在函数内的修改并没有影响到函数外部的num，所以对于基本数据类型, Java是值传递
对于基本数据的包装类, 也是值传递
01
对于引用类型, Java是值传递还是引用传递? 看下图
02
可以看到，在函数内的修改已经影响到了函数外部的lis，这似乎证明了对于引用类型, Java是引用传递
但是, 我们都知道, 对于引用类型, 变量保存的是指向其堆内存的地址, 也就是说, 如果将引用类型赋值给另一个变量, 修改当前变量的值, 另一个变量也会被改变, 如何理解呢? 请看下图
03
可以看到, 虽然只是修改了lis而没有去修改copy, 但由于lis和copy指向的是同一内存地址, 所以对lis的修改也会体现在copy上
ref
回到正题，既然知道了lis变量是对于堆内存中ArrayList的引用, 那么之前的结果就不成立了, 修改changeValue方法再看 04
可以看到, 在函数中将一个新的ArrayList的引用赋值给了lis变量, 但是函数外的lis变量依然指向的是原来的ArrayList, 所以得出结论, 对于引用类型, Java也是值传递
结论 无论是对于基本数据类型还是引用类型，Java都是值传递，但要注意的是，对于引用类型，变量保存的是其引用，所以通过函数接收的变量去修改其指向的引用类型，也会影响到函数外的变量，而给函数接收的变量赋予新的引用，则不会影响到函数外的变量。</description></item><item><title>Java8中新增的时间处理API</title><link>https://chaosalphard.github.io/p/java8%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86api/</link><pubDate>Sat, 18 Apr 2020 23:40:28 +0000</pubDate><guid>https://chaosalphard.github.io/p/java8%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86api/</guid><description>Java8新的时间处理API 原有的java.util.Date与新增的java.time有何差异？
java.util.Date设定为可变类型 SimpleDateFormat是非线程安全的 新的API 基于ISO 标准日历系统, 遵循Gregorian 规则 java.time包下的所有类都是不可变类型 java.time包下的所有类都是线程安全的 java.time简单介绍 java.time由以下5个包组成:
java.time: 包含值对象的基础包 java.time.chrono: 提供对不同的日历系统的访问 java.time.format: 格式化和解析时间和日期 java.time.temporal: 包括底层框架和扩展特性 java.time.zone: 包含时区支持的类 关于java.time下, 类的简介:
Instant: 时间戳 LocalDate: 只包含日期，比如: 2020-01-01 LocalTime: 只包含时间，比如: 12:00:00 LocalDateTime: 包含日期和时间，比如: 2020-01-01T12:00:00 Duration: 时间段, 主要用于计算两个时间之间的差值 Peroid: 时间段, 主要用于计算两个日期之间的差值 ZoneOffset: 时区偏移量，比如: +8:00 ZonedDateTime: 带时区的日期时间 Clock: 时钟，可以获取或指定时区, 也可获取当前的时刻 DateTimeFormatter: 时间格式化 关于java.time下大部分类的方法前缀简介:
of: 静态工厂方法(用类名去调用)。 parse: 静态工厂方法，关注于解析(用类名去调用)。 now: 静态工厂方法，用当前时间创建实例(用类名去调用) get: 获取某些东西的值。 is: 检查某些东西的是否是true。 with: 返回一个部分状态改变了的时间日期对象拷贝(单独一个with方法,参数为TemporalAdjusters类型) plus: 返回一个时间增加了的、时间日期对象拷贝(如果参数是负数也能够有minus方法的效果) minus: 返回一个时间减少了的、时间日期对象拷贝 to: 把当前时间日期对象转换成另外一个，可能会损失部分状态.</description></item><item><title>OAuth2.0资源服务器搭建与配置</title><link>https://chaosalphard.github.io/p/oauth2.0%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 11 Apr 2020 22:52:26 +0000</pubDate><guid>https://chaosalphard.github.io/p/oauth2.0%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description>OAuth2.0资源服务器搭建 引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-oauth2&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 编写配置文件 SecurityConfig.java
@Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&amp;#34;/res/**&amp;#34;) // 需要通过验证 .authenticated() .anyRequest().permitAll() .and().csrf().disable(); } } ResourceServerConfig.java
@Configuration @EnableResourceServer public class ResourceServerConfig extends ResourceServerConfigurerAdapter { @Autowired private TokenStore tokenStore; @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(&amp;#34;res1&amp;#34;) // 资源id, 需要与ClientDetailsServiceConfigurer中的resourceIds一致 .tokenServices(tokenService()) // 验证令牌服务 .</description></item><item><title>OAuth2.0授权服务器搭建与配置</title><link>https://chaosalphard.github.io/p/oauth2.0%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 09 Apr 2020 01:00:25 +0000</pubDate><guid>https://chaosalphard.github.io/p/oauth2.0%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid><description>OAuth2.0授权服务器搭建 向pom.xml中添加以下依赖
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-oauth2&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 配置client端的详情信息
@Configuration @EnableAuthorizationServer public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { // 配置客户端详情信息 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() // inMemory: 使用内存方式 // 客户端ID .withClient(&amp;#34;c1&amp;#34;) // 客户端密钥, 加密方式需要与SpringSecurity中的方式一致 .secret(new BCryptPasswordEncoder().encode(&amp;#34;secret&amp;#34;)) // 客户端可以访问的资源列表 .resourceIds(&amp;#34;res1&amp;#34;) // 允许的授权类型 .authorizedGrantTypes(&amp;#34;authorization_code&amp;#34;, &amp;#34;password&amp;#34;, &amp;#34;client_credentials&amp;#34;, &amp;#34;implicit&amp;#34;, &amp;#34;refresh_token&amp;#34;) // 允许的授权范围 .scopes(&amp;#34;all&amp;#34;) // 自动授权, 如果是授权码模式, 且设置为false, 则会跳转到授权页面 .autoApprove(false) // 授权成功后重定向地址, 授权成功后会在该地址后附带上授权码 .</description></item><item><title>OAuth2.0简介</title><link>https://chaosalphard.github.io/p/oauth2.0%E7%AE%80%E4%BB%8B/</link><pubDate>Tue, 07 Apr 2020 03:14:56 +0000</pubDate><guid>https://chaosalphard.github.io/p/oauth2.0%E7%AE%80%E4%BB%8B/</guid><description>什么是OAuth OAuth(开放授权)是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源(如照片，视频，联系人列表)，而无需将用户名和密码提供给第三方应用。
举个例子: 用户借助QQ认证去登录网站A，如果认证通过了，就不需要用户手动在网站A注册账户了。
那么怎么样才算认证通过？网站A成功从QQ获取用户信息则认为认证成功了。那么如何从QQ那里获取用户的身份信息呢？用户信息的拥有者是用户本人，QQ需要经过用户同意才可以为网站A生成令牌，而网站A拿到此令牌才可从QQ获取用户信息。
OAuth的思路 OAuth在&amp;quot;第三方应用程序&amp;quot;与&amp;quot;服务提供商&amp;quot;之间，设置了一个授权层(authorization layer)。&amp;ldquo;第三方应用程序&amp;quot;不能直接登录&amp;quot;服务提供商&amp;rdquo;，只能登录授权层，以此将用户与第三方应用程序区分开来。&amp;ldquo;第三方应用程序&amp;quot;登录授权层所用的令牌(token)，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。
&amp;ldquo;第三方应用程序&amp;quot;登录授权层以后，&amp;ldquo;服务提供商&amp;quot;根据令牌的权限范围和有效期，向&amp;quot;第三方应用程序&amp;quot;开放用户储存的资料。
运行流程 Third-party application: 第三方应用程序，也可称为&amp;quot;客户端&amp;rdquo;，即例子中的&amp;quot;网站A&amp;rdquo;。它本身不储存资源，需要通过资源所有者的授权去请求资源服务器的资源。 HTTP service: HTTP服务提供商，即例子中的QQ。 Resource Owner: 资源所有者，也就是用户。 User Agent: 用户代理，一般是指浏览器。 Authorization server: 认证服务器，即服务提供商用来处理认证的服务器，用于服务提供商对资源拥有者的身份进行认证、对资源访问进行授权、认证成功后给客户端发放令牌(Access Token, 客户端访问资源服务器的凭据)。 Resource server: 资源服务器，即服务提供商存放用户资源的服务器。 认证服务器与资源服务器，它们可以是同一台服务器，也可以是不同的服务器。
运行流程
用户打开第三方应用程序以后，第三方应用程序要求用户给予授权。 用户同意给予第三方应用程序授权。 第三方应用程序使用上一步获得的授权，向认证服务器申请令牌。 认证服务器对第三方应用程序进行认证以后，确认无误，同意发放令牌。 第三方应用程序使用令牌，向资源服务器申请获取资源。 资源服务器确认令牌无误，同意向第三方应用程序开放资源。 第三方应用程序拿到资源后，即可得知认证通过。 参考:
理解Oauth2.0 一图搞定OAuth2.0</description></item><item><title>SpringSecurity使用注解进行授权控制</title><link>https://chaosalphard.github.io/p/springsecurity%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83%E6%8E%A7%E5%88%B6/</link><pubDate>Sat, 04 Apr 2020 02:10:29 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83%E6%8E%A7%E5%88%B6/</guid><description>使用注解进行授权控制 从SpringSecurity2.0版本开始，支持服务层方法的安全性支持，目前有@Secured，@PreAuthorize，@PostAuthorize三类注解
在@Configuration实例上使用@EnableGlobalMethodSecurity注解来启用基于注解的授权控制
@Configuration @EnableWebSecurity // 启用方法授权 @EnableGlobalMethodSecurity( // 启用@Secured注解 securedEnabled = true, // 启用@PreAuthorize和@PostAuthorize注解 prePostEnabled = true ) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... } 之后向方法(类、方法或者接口)添加注解就会限制对该方法的访问
@Secured注解 @RestController public class IndexController { // IS_AUTHENTICATED_ANONYMOUSLY: 表示可以匿名访问 @Secured(&amp;#34;IS_AUTHENTICATED_ANONYMOUSLY&amp;#34;) @RequestMapping(&amp;#34;/r&amp;#34;) public String resource() { return getUserName()+&amp;#34;访问资源&amp;#34;; } // ROLE_USER: 表示需要有USER权限才能访问 @Secured(&amp;#34;ROLE_USER&amp;#34;) @RequestMapping(&amp;#34;/r1&amp;#34;) public String resource1() { return getUserName()+&amp;#34;访问资源1&amp;#34;; } } @PreAuthorize和@PostAuthorize注解 @RestController public class IndexController { // @PreAuthorize 会在方法执行前进行权限验证 // isAnonymous() 允许匿名访问 @PreAuthorize(&amp;#34;isAnonymous()&amp;#34;) @RequestMapping(&amp;#34;/pre/a&amp;#34;) public String preAssets() { return getUserName()+&amp;#34;访问preAssets&amp;#34;; } // 拥有USER 权限才可访问 @PreAuthorize(&amp;#34;hasRole(&amp;#39;USER&amp;#39;)&amp;#34;) @RequestMapping(&amp;#34;/pre/a1&amp;#34;) public String preAssets1() { return getUserName()+&amp;#34;访问preAssets1&amp;#34;; } // @PostAuthorize 会在方法执行后进行权限验证 // 拥有USER 和ADMIN 任一权限即可访问 @PostAuthorize(&amp;#34;hasAnyRole(&amp;#39;USER&amp;#39;, &amp;#39;ADMIN&amp;#39;)&amp;#34;) @RequestMapping(&amp;#34;/post/a1&amp;#34;) public String postAssets1() { System.</description></item><item><title>SpringSecurity会话管理</title><link>https://chaosalphard.github.io/p/springsecurity%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</link><pubDate>Fri, 03 Apr 2020 01:00:28 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</guid><description>在Controller中获取认证信息 @Controller public class IndexController { @RequestMapping(&amp;#34;/user&amp;#34;) public String user(Model model) { String username = getUserName(); model.addAttribute(&amp;#34;username&amp;#34;,username); return &amp;#34;user&amp;#34;; } private String getUserName() { // 获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 检查用户是否认证 if(authentication == null || !authentication.isAuthenticated()) { return &amp;#34;游客&amp;#34;; } Object principal = authentication.getPrincipal(); if(principal instanceof UserDetails) { return ((UserDetails) principal).getUsername(); } else { return principal.toString(); } } } 会话控制 在配置类中通过下列选项控制会话何时创建以及Spring Security 如何与之交互
always: 如果没有session, 则创建一个 ifRequired: 如果需要, 则创建一个.</description></item><item><title>SpringSecurity自定义登录与注销</title><link>https://chaosalphard.github.io/p/springsecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E4%B8%8E%E6%B3%A8%E9%94%80/</link><pubDate>Tue, 31 Mar 2020 22:34:17 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E4%B8%8E%E6%B3%A8%E9%94%80/</guid><description>自定义登录页 修改配置
@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&amp;#34;/&amp;#34;,&amp;#34;/index&amp;#34;,&amp;#34;/error&amp;#34;,&amp;#34;/identify&amp;#34;).permitAll() .antMatchers(&amp;#34;/user/**&amp;#34;).hasRole(&amp;#34;USER&amp;#34;) .and().formLogin() // 自定义登录页面地址 .loginPage(&amp;#34;/login&amp;#34;) // 指定处理登录请求的url, 即登录表单的action对应的地址 .loginProcessingUrl(&amp;#34;/identify/login&amp;#34;) // 成功后默认跳转到的url .defaultSuccessUrl(&amp;#34;/user&amp;#34;) .and() // 禁用跨域请求验证 .csrf().disable(); } } 映射路径
// RequestMapping 的路径, 即为配置类中loginPage设置的路径 @RequestMapping(&amp;#34;/login&amp;#34;) public String login() { return &amp;#34;login&amp;#34;; } 页面编写
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34; xmlns:th=&amp;#34;http://www.thymeleaf.org&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Login&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- action中的url即为配置类中, loginProcessingUrl项设置的url --&amp;gt; &amp;lt;!</description></item><item><title>[笔记]SpringCloud学习10: OpenFeign超时配置与日志记录</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A010-openfeign%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 29 Mar 2020 22:50:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A010-openfeign%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</guid><description>设置超时时间 在application.yml中
# 设置超时时间ribbon:# 指与服务器建立链接的超时时间(单位: ms)ConnectTimeout:1000# 指与服务器建立链接之后，从服务器读取到可用资源所花时间ReadTimeout:5000配置日志输出 OpenFeign有4个日志级别
NONE: 不输出任何日志 BASIC: 仅记录请求方法、URL、响应状态吗以及执行时间 HEADERS: 除了BASIC中的信息外，还记录请求和响应的头信息 FULL: 输出所有信息 编写配置类
package com.ilirus.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class OpenFeignConfig { @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } } 在application.yml中配置控制台日志输出级别</description></item><item><title>[笔记]SpringCloud学习09: OpenFeign服务调用</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A009-openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</link><pubDate>Sun, 29 Mar 2020 03:07:11 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A009-openfeign%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</guid><description>Feign 简介 Feign是一个声明式的WebService客户端。它的出现使开发WebService客户端变得很简单。使用Feign只需要创建一个接口加上对应的注解。
Feign 是一种声明式、模板化的HTTP 客户端。在SpringCloud 中使用Feign，可以做到使用HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问HTTP 请求。
Feign 和 OpenFeign OpenFeign在Feign的基础上支持了SpringMVC的注解。
在OpenFeign中，除了自身提供的注解之外，还支持使用JAX-RS注解，或者SpringMVC注解。
OpenFeign的@FeignClient注解可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
OpenFeign同样使用声明式方式定义Web服务客户端，其次，OpenFeign还可以通过集成Ribbon或Eureka来实现负载均衡的HTTP 客户端。
OpenFeign 的使用 在服务消费方的pom.xml中，引入以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 创建相应的Service接口
package com.ilirus.springcloud.service; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; // value为服务提供方在Eureka中注册的名称 // RequestMapping为提供方对应的请求地址 @FeignClient(value = &amp;#34;irs-provider-payment&amp;#34;) public interface PaymentFeignService { @GetMapping(&amp;#34;/payment/query/{id}&amp;#34;) public CommonResult&amp;lt;Payment&amp;gt; getPaymentByID(@PathVariable(&amp;#34;id&amp;#34;) Long id); } 创建Controller
package com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.entities.Payment; import com.ilirus.springcloud.enums.Status; import com.ilirus.springcloud.service.PaymentFeignService; import lombok.extern.slf4j.Slf4j; import org.</description></item><item><title>SpringSecurity简单入门</title><link>https://chaosalphard.github.io/p/springsecurity%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 23 Mar 2020 04:35:18 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</guid><description>Spring Security 是什么 Spring Security是一套认证授权框架，支持认证模式如HTTP BASIC 认证头 (基于 IETF RFC-based 标准)，HTTP Digest 认证头 ( IETF RFC-based 标准)，Form-based authentication (用于简单的用户界面)，OpenID 认证等，Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制。
Spring Security可以对所以进入系统的请求进行拦截，效验每个请求是否能访问对应的资源。
Spring Security 如何工作 Spring Security对Web 资源的保护是靠Filter来实现的，当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的过滤器，类型为org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求都会经过这个过滤器。
SpringSecurityFilterChain中包含的各个Filter都作为Bean被Spring所管理，他们是Spring Security的核心，各司其职，但这些Filter并不直接处理用户的认证，也不直接处理用户的授权，而出把这些工作交给认证管理器(AuthenticationManager)和决策管理器(AccessDecisionManager)进行处理。
认证流程 SpringSecurity认证流程
引入依赖 在pom.xml中写入以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 编写配置 package com.ilirus.oauth.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // 在内存中创建用户 auth.</description></item><item><title>[笔记]SpringCloud学习08: Ribbon基础</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A008-ribbon%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 21 Mar 2020 03:44:07 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A008-ribbon%E5%9F%BA%E7%A1%80/</guid><description>Ribbon 介绍 Ribbon是Netflix发布的一款用于负载均衡的开源项目，是一个客户端的负载均衡器。
Ribbon会基于某些规则(轮询，随机等)决定要调用的服务链接，并且可以使用Ribbon实现自定义的负载均衡算法。
负载均衡是什么 负载均衡(Load Balance)简单来说就是将用户的请求平摊到各个服务器上，从而提高服务的承载能力。
Ribbon 本地负载均衡和Nginx 服务端负载均衡的区别 Nginx: 客户端所有请求都先发给Nginx，让后由Nginx 服务器实现请求转发。(集中式LB)
Ribbon: 在调用微服务接口的时候，由Ribbon 的负载均衡算法决定调用哪个服务接口。(进程内LB)
集中式LB 和进程内LB 集中式Load Balancer: 在服务的消费方和提供方之间使用独立的LB 设施，由该设施负责把请求访问通过某种策略转发制服务提供方
进程内Load Balancer: 将LB 逻辑集成到消费方，消费方从服务注册中心获知有那些服务地址可用，然后自己再从这些地址中选择一个合适的服务器
Ribbon 引入 修改pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --&amp;gt; &amp;lt;/dependency&amp;gt; Ribbon已经集成在Eureka Client中，如果pom.xml中已经引入Eureka Client，则可以不用再引入Ribbon
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Ribbon 的使用 使用@LoadBalancer注解授予RestTemplate负载均衡功能，
@Configuration public class ApplicationontextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 使用@Resource或者@Autowired 装配具有负载均衡能力的RestTemplate</description></item><item><title>[笔记]SpringCloud学习07: Eureka自我保护</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</link><pubDate>Fri, 20 Mar 2020 03:02:19 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A007-eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4/</guid><description>Eureka 自我保护机制 保护模式主要用于一组客户端和服务端之间存在网络分区场景下的保护，一旦进入保护模式，Eureka Server会尝试保护其服务注册表中的信息，将不再删除服务注册表中的信息，也就是不会注销任何微服务
一句话概括: 如果某一时刻，Eureka Server中某个微服务不可用了，Eureka不会立即清除，而是会尝试对该微服务的信息进行保存 (CAP中的AP)
为什么需要自我保护机制 为了防止Eureka Client可以正常运行，但与Eureka Server直接网络不同的情况下，Eureka Server错误地将可以正常运行的Client端移除
默认情况下，如果Eureka Server在一定时间内(默认90s)没有接收到某个服务实例的心跳时，Eureka Server会注销该实例。但当网络分区故障发生时(延时，拥挤)，微服务与Eureka Server之间无法正常通讯时，超时移除节点是不正确的行为——微服务自身很可能是正常状态，也就是说不应该注销此服务。
Eureka通过自我保护模式来解决这个问题——当Eureka Server短时间内丢失过多Client端时，那么这个节点将进入自我保护模式。
也就是说宁可保留错误的服务注册信息，也不会盲目注销任何可能正常的服务实例
如何判断Eureka 是否进入了自我保护模式 如果在Eureka Server首页看到以下提示，则说明Eureka进入了保护模式
EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&amp;rsquo;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
如何禁止自我保护机制 在Erueka Server 端的application.yml文件中，添加以下内容
eureka:server:# 关闭自我保护机制enable-self-preservation:false# 移除服务的超时时间，单位毫秒eviction-interval-timer-in-ms:15000在Eureka Client 端的application.yml文件中，添加以下内容
eureka:# eureka 客户端instance:# Eureka Client 端向Server 端发送心跳的时间间隔，单位秒，默认30s# 修改心跳时间主要是因为修改了Server 端的超时时间(15000ms = 15s)# 所以对应的修改Client 端的心跳时间lease-renewal-interval-in-seconds:5# Eureka Server 端在收到最后一次心跳后等待时间上限，单位秒，超时将剔除服务，默认90slease-expiration-duration-in-seconds:15</description></item><item><title>[笔记]SpringCloud学习06: Eureka服务发现</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</link><pubDate>Fri, 20 Mar 2020 02:03:59 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A006-eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</guid><description>获取Eureka Server 端注册成功的服务信息 对于注册进Eureka里面的微服务，可以通过服务发现来获取该服务的信息
修改对应工程(Eureka Client 端)的Controller
package com.ilirus.springcloud.controller; import com.ilirus.springcloud.entities.CommonResult; import com.ilirus.springcloud.enums.Status; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; @RestController @RequestMapping(&amp;#34;/payment&amp;#34;) @Slf4j public class PaymentController { @Resource private DiscoveryClient discoveryClient; @GetMapping(&amp;#34;/discovery&amp;#34;) public CommonResult discovery() { List&amp;lt;String&amp;gt; services = discoveryClient.getServices(); return CommonResult.ofData(Status.SUCCESS, services); } @GetMapping(&amp;#34;/discovery/{instances}&amp;#34;) public CommonResult discovery(@PathVariable String instances) { List&amp;lt;ServiceInstance&amp;gt; serviceInstances = discoveryClient.getInstances(instances); return CommonResult.ofData(Status.SUCCESS, serviceInstances); } } 修改启动类
package com.ilirus.springcloud; import org.</description></item><item><title>[笔记]SpringCloud学习05: 服务提供方集群</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/</link><pubDate>Thu, 19 Mar 2020 22:02:13 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A005-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E9%9B%86%E7%BE%A4/</guid><description>服务提供方集群搭建 参考之前搭建好的服务提供方工程，再创建一个新的工程，要注意application.yml中，spring.application.name属性要和之前的一致，完成后启动服务
eureka
服务消费方请求地址修改 在消费方工程中，将请求地址改为微服务名称
package com.ilirus.springcloud.controller; /* import ... */ @RestController @RequestMapping(&amp;#34;/consumer&amp;#34;) @Slf4j public class OrderController { private static final String PAYMENT_URL = &amp;#34;http://irs-provider-payment/payment&amp;#34;; @Resource private RestTemplate restTemplate; @GetMapping(&amp;#34;/payment/create&amp;#34;) public CommonResult create(Payment payment) { return restTemplate.postForObject(PAYMENT_URL+&amp;#34;/create&amp;#34;, payment, CommonResult.class); } /* ... */ } 因为目前irs-provider-payment服务下有两个实例，直接使用服务名并不能让程序知道你想用具体哪一个，所以还需要进一步配置
RestTemplate 配置负载均衡 修改RestTemplate配置类
package com.ilirus.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced // 授予restTemplate负载均衡能力 public RestTemplate getRestTemplate() { return new RestTemplate(); } } 至此，全部配置完成</description></item><item><title>[笔记]SpringCloud学习04: Eureka集群</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/</link><pubDate>Tue, 17 Mar 2020 23:33:16 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A004-eureka%E9%9B%86%E7%BE%A4/</guid><description>Eureka 集群原理 我们假设有三台 Eureka Server 组成的集群，只要三个地方的任意一个Eureka Server不出现问题，都不会影响整个架构的稳定性。
Eureka集群
从图中可以看出Eureka Server集群相互之间通过Replicate来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl 指向其他节点。
如果某台Eureka Server 宕机，Eureka Client 的请求会自动切换到新的Eureka Server 节点。当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它Eureka Server 当前所知的所有节点中。
另外Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个Eureka Server 同时也是Eureka Client，多个Eureka Server 之间通过P2P的方式完成服务注册表的同步。
Eureka Server 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。
Eureka保证AP (CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance))
Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka Client 在向某个Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。
Eureka 集群搭建 新建一个Eureka Server，并修改application.yml文件
server:port:7002eureka:instance:hostname:eureka7002.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7001.com:7001/eureka/修改之前的单机eureka配置文件
server:port:7001eureka:instance:hostname:eureka7001.comclient:register-with-eureka:falsefeth-registry:falseservice-url:# 相互注册defaultZone:http://eureka7002.com:7002/eureka/ 因为是在同一台机器上，所以需要修改host文件将eureka7001.com和eureka7002.com映射为127.0.0.1
微服务注册进集群 回到之前的子工程中，修改application.yml文件中的eureka配置
eureka:# eureka 客户端client:register-with-eureka:truefetch-registry:trueservice-url:# 服务中心链接defaultZone:http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka启动服务，查看是否正确 集群</description></item><item><title>[笔记]SpringCloud学习03: Eureka的搭建</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/</link><pubDate>Mon, 16 Mar 2020 00:36:52 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A003-eureka%E7%9A%84%E6%90%AD%E5%BB%BA/</guid><description>Eureka Server端的搭建 创建一个Maven项目，在pom.xml中写入以下依赖:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 版本从父工程的dependencyManagement中继承, 故此处不用写 --&amp;gt; &amp;lt;/dependency&amp;gt; 创建启动类
package com.ilirus.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaServerMain7001.class, args); } } 配置yml
server:port:7001eureka:# eureka 服务端instance:hostname:localhost# eureka服务端实例名称client:register-with-eureka:false# 是否向服务中心注册自己feth-registry:false# 是否向服务中心检索已有的注册信息service-url:# 设置Eureka Server 的交互地址。查询服务和注册服务都需要依赖这个地址defaultZone:http://${eureka.instance.hostname}:${server.port}/eureka/启动工程并查看是否有误
Eureka Client端的注册 回到之前的子项目中，向pom.xml中添加以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 修改application.yml文件
spring:application:name:irs-provider-payment8001# 名称eureka:# eureka 客户端client:register-with-eureka:true# 向服务中心注册自己fetch-registry:true# 向服务中心获取已有的注册信息, 集群必须设置为true才能配合ribbon使用负载均衡service-url:# 服务中心链接defaultZone:http://localhost:7001/eureka修改启动类并添加@EnbaleEurekaClient注解
package com.ilirus.springcloud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.</description></item><item><title>[笔记]SpringCloud学习02: Eureka基础</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/</link><pubDate>Sat, 14 Mar 2020 03:28:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A002-eureka%E5%9F%BA%E7%A1%80/</guid><description>什么是服务治理 当我们的服务与服务之间通讯调用的时候，如果简单粗暴的用httpclient去请求，不经过第三方的组件管理，然后访问路径写死，那么如果有一个服务更换了路径，所有的服务都需要手动更换该服务的访问路径。维护的成本很高。
就是因为出现了这些问题，所以引入了服务治理(SOA governance)这个概念，同时衍生了这类的实现组件，也就是注册中心。典型的代表：zookeeper，Eureka，Consul。服务治理也引入了 服务调用、负载均衡、容错等功能。
简单的总结：把服务看成一个地方。当我们服务调用的时候，就是从一个地方到另一个地方，这时候我们需要地图导航才能到达，当我们去的路程有一段路可能修路，无法通过的时候，导航就会帮我们规划另一条路线。这里的导航就是注册中心，会一定的时间就会刷新一下路况，就好像我们注册中心 (Erueka为例) 每隔30秒就会刷新一下服务的地址。
Eureka设计 Eureka采用了CS的设计构架，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server中心并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否运行正常。
当服务器(服务提供方)启动的时候，会把当前自己服务器的信息(服务地址、通信地址等)以别名的方式注册到注册中心上。另一方(服务消费方)以该别名的方式去注册中心上获取到实际的服务器通讯地址，然后再实现本地RPC调用远程RPC。调用框架核心在于注册中心，注册中心管理每个服务与服务间的依赖关系(服务治理)，也就是说，在任何RPC远程框架中，都会有一个注册中心。
Eureka
Eureka Server: 提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态一致(最终一致性) Service Provider: 服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到 Service Consumer: 服务消费方，从Eureka获取注册服务列表，从而能够消费服务 Eureka组件 Eureka包含两个组件：Eureka Server和Eureka Client
Eureka Server Eureka Server提供注册服务，各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表会储存所有可用服务节点的信息，服务节点的信息可在管理界面中直观的看到。
Eureka Server 同时也是一个Eureka Client 在不禁止Eureka Server的客户端行为时，它会向它配置文件中的其他Eureka Server 进行拉取注册表、服务注册和发送心跳等操作。
Eureka Client Eureka Client 可向注册中心进行访问来获取服务提供方通讯地址。在启动后，Eureka Client将会向Eureka Server发送心跳(默认间隔为30s)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server则会将该节点从服务器注册表中移除(默认90s)。
服务提供方 启动后，向注册中心发起register请求，注册服务 在运行过程中，定时向注册中心发送renew心跳，证明&amp;quot;我还活着&amp;quot; 停止服务提供者，向注册中心发起cancel请求，清空当前服务注册信息 服务消费方 启动后，从注册中心拉取服务注册信息 在运行过程中，定时更新服务注册信息 发起向服务提供方远程调用时</description></item><item><title>Maven中dependencyManagement元素的使用</title><link>https://chaosalphard.github.io/p/maven%E4%B8%ADdependencymanagement%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 12 Mar 2020 17:16:24 +0000</pubDate><guid>https://chaosalphard.github.io/p/maven%E4%B8%ADdependencymanagement%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>dependencyManagement元素的使用 使用dependencyManagement元素能让所有在子项目中引用一个依赖而不用显式的列出版本号，Maven会沿父子层向上查找，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement中指定的版本号
例如在父项目中:
&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.14&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; 在子项目里:
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 这样做的好处是，如果多个子项目都引用同一个依赖，则可以统一对子项目依赖进行管理版本
如果某个子项目需要另一个版本，那么只需要在那个子项目依赖中声明version即可
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.48&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 父项目中的dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显式声明需要用的依赖。 如果需要所有子项目都继承某个依赖，则需要在父项目中使用dependencies，需要注意的是dependencies要放在dependencyManagement上方 如果不在子项目中声明依赖，则不会从父项目中继承，只有在子项目中声明了依赖，且没有指定具体版本，才会从父项目中继承，并且version和scope都读取自父pom文件 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本</description></item><item><title>[笔记]SpringCloud学习01: 项目的搭建</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A001-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/</link><pubDate>Thu, 12 Mar 2020 00:55:33 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A001-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/</guid><description>建立项目 父工程的创建 IDEA: Create New Project -&amp;gt; Maven -&amp;gt; 输入groupid和artifactId -&amp;gt; 完成
之后在IDEA设置中还有几个地方要设置:
Build选项中的Compiler选项中的Annotation Processing目录中，在Enable annotation processing选项前打勾 Build选项中的Compiler选项中的Java Compiler目录中，将Target bytecode version 选为8 (可选)Editor选项中的File Types目录中，将*.iml;*.idea; 添加到Ignore files and patterns中，这是用于在IDEA资源管理器中隐藏对应后缀的文件 修改pom.xml文件，在version下添加&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
&amp;lt;groupId&amp;gt;com.ilirus.springcloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;irscloud&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; 修改properties
&amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;junit.version&amp;gt;4.12&amp;lt;/junit.version&amp;gt; &amp;lt;log4j.version&amp;gt;1.2.17&amp;lt;/log4j.version&amp;gt; &amp;lt;lombok.version&amp;gt;1.16.18&amp;lt;/lombok.version&amp;gt; &amp;lt;mysql.version&amp;gt;8.0.14&amp;lt;/mysql.version&amp;gt; &amp;lt;druid.version&amp;gt;1.1.16&amp;lt;/druid.version&amp;gt; &amp;lt;mybatis.spring.boot.version&amp;gt;2.1.2&amp;lt;/mybatis.spring.boot.version&amp;gt; &amp;lt;/properties&amp;gt; 修改dependencies
&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- springboot 2.2.2 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring cloud hoxton.SR1 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Hoxton.SR1&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description></item><item><title>[笔记]SpringCloud学习00: 微服务与SpringCloud</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A000-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8Espringcloud/</link><pubDate>Wed, 11 Mar 2020 21:26:57 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springcloud%E5%AD%A6%E4%B9%A000-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8Espringcloud/</guid><description>微服务是什么 　微服务是一种架构模式，它提倡将单一应用程序划分为一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务间采用轻量级的通信机制互相协作(例如基于HTTP协议的RESTful API)。
每个服务都围绕具体业务进行构建，并能够独立的被部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。
微服务架构应满足哪些维度 服务的注册与发现 服务调用 服务熔断 负载均衡 服务降级 服务消息队列 配置中心管理 服务网关 服务监控 全链路追踪 自动化构建部署 服务定时任务调度操作 Spring Cloud 是什么 融合、协调、组装微服务相关技术，使构建分布式系统变更更容易。是分布式微服务架构的一种技术体现，是多种微服务架构落地技术的集合体。(微服务全家桶)
Spring Cloud 版本命名规则 Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为管理Spring Cloud 与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud 版本对应的子项目版本。
为避免Spring Cloud 的版本号与子项目版本号混淆，Spring Cloud 采用了英国伦敦地铁站的名称来命名，以字母A-Z的形式来发布迭代版本，也就是说Spring Cloud 是以字母作为版本号。
当Spring Cloud 的发布内容累积到临界点或一个重大BUG被解决后，会发布一个service releases 版本，简称SR版本(SR1、SR2等)。
Spring Cloud 和Spring Boot 的版本对应 在https://spring.io/projects/spring-cloud网页底部可查看SpringCloud和SpringBoot的版本对应关系
SpringCloud和SpringBoot对应版本
更详细的依赖信息需要在https://start.spring.io/actuator/info中查讯
在https://spring.io/projects/spring-cloud#learn页面中找到Spring Cloud 的Reference Doc在这个页面里可以找到官方推荐的Spring Boot版本</description></item><item><title>VSCode配置Springboot开发环境</title><link>https://chaosalphard.github.io/p/vscode%E9%85%8D%E7%BD%AEspringboot%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 03 Oct 2019 20:36:06 +0000</pubDate><guid>https://chaosalphard.github.io/p/vscode%E9%85%8D%E7%BD%AEspringboot%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid><description>虽说Springboot的首选开发IDE是IntelliJ IDEA，然而对于老爷机来说IDEA太过庞大，对于因为某些原因而无法使用主力开发电脑时，使用VSCode来开发Springboot也不失为一个不错的选择。
VSCode
安装开发扩展 在商店中搜索Java Extension Pack 扩展，并安装。
这是一个扩展包，VSCode 会自动安装关联的扩展：
Cloudfoundry Manifest YML Support Concourse CI Pipeline Editor Debugger for Java Java Dependency Viewer Java Test Runner Language Support for Java(TM) by Red Hat Maven for Java JavaExt
在商店中搜索Spring Boot Extension Pack 扩展，并安装。
这是一个扩展包，VSCode 会自动安装关联的扩展：
Spring Boot Dashboard Spring Boot Tools Spring Initializr Java Support Visual Studio IntelliCode MavenExt
配置Java与Maven路径 打开VSCode的设置文件(setting.</description></item><item><title>[笔记]SpringBoot学习05</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A005/</link><pubDate>Fri, 19 Oct 2018 08:52:40 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A005/</guid><description>使用JUnit进行单元测试 生成测试类 在需要进行测试的类中 点击右键-&amp;gt;Go To-&amp;gt;Test 或者 使用快捷键Ctrl+Shift+T生成测试类
生成的类
public class CustomDaoTest { @Resource private CustomDao dao; @Test public void findCustomByName() { } @Test public void findCustomByID() { } } 添加测试
@SpringBootTest @RunWith(SpringRunner.class) public class CustomDaoTest { @Resource private CustomDao dao; @Test public void findCustomByName() { Custom c = dao.findCustomByName(&amp;#34;Ilirus&amp;#34;); assertEquals(c.getId(),1); } @Test public void findCustomByID() { Custom c = dao.findCustomByID(1); assertEquals(c.getId(),1); } }</description></item><item><title>[笔记]SpringBoot学习04</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A004/</link><pubDate>Tue, 16 Oct 2018 09:10:46 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A004/</guid><description>Spring打包和自定义日志 Spring打包 jar包 View-&amp;gt;Tool Windows-&amp;gt;Maven Project
展开Lifecycle
右键package
Run Maven Build
在target文件夹中找到打包出来的.jar文件
使用java -jar &amp;lt;jarName&amp;gt; 命令启动
war包 修改pom.xml &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 改为 &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
SpringBootApplication类 改为
public class ClassName extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){ return builder.sources(ClassName.class); } public static void main(String[] args) { SpringApplication.run(ClassName.class, args); } } 再按照打包jar的方式打包
日志 定义log变量
import org.apache.commons.logging.Log
private Log log = LogFactory.getLog(className.class);
输出log
log.debug(&amp;#34;输出debug信息&amp;#34;) log.info(&amp;#34;输出信息&amp;#34;); log.warn(&amp;#34;输出警告&amp;#34;); log.error(&amp;#34;输出错误&amp;#34;) log.fatal(&amp;#34;输出致命错误&amp;#34;)</description></item><item><title>[笔记]SpringBoot学习03</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A003/</link><pubDate>Fri, 28 Sep 2018 10:23:40 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A003/</guid><description>Thymeleaf网页模板 使用 控制器方法中添加Model
//import org.springframework.ui.Model; @RequestMapping(value = {&amp;#34;&amp;#34;}) private String DefPage(Model model){ String name = &amp;#34;Ilirus&amp;#34;; model.addAttribute(&amp;#34;name&amp;#34;,name); return &amp;#34;def&amp;#34;; } HTML中引入命名空间之后使用
&amp;lt;html xmlns:th=&amp;#34;http://www.thymeleaf.org&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; th:text=&amp;#34;${name}&amp;#34;&amp;gt;被替换的文本&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 语法 替换文本 &amp;lt;div th:text=&amp;quot;'替换: '+${name}&amp;quot;&amp;gt;被替换的文本&amp;lt;/div&amp;gt; 替换href &amp;lt;a th:href=&amp;quot;@{'localhost:8080/'+${url}}&amp;quot;&amp;gt;&amp;lt;/a&amp;gt; 循环遍历 &amp;lt;div th:each=&amp;#34;li:${list}&amp;#34;&amp;gt; &amp;lt;a th:href=&amp;#34;@{&amp;#39;localhost:8080/&amp;#39;+${li.url}}&amp;#34; th:text=&amp;#34;${li.text}&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; 引入模板 定义模板 &amp;lt;th:block th:fragment=&amp;quot;domblock&amp;quot;&amp;gt;Dom Element here&amp;lt;/th:block&amp;gt; &amp;lt;div th:fragment=&amp;quot;nav&amp;quot;&amp;gt;Dom Element here&amp;lt;/div&amp;gt; 引入模板 &amp;lt;th:block th:insert=&amp;quot;path/file::domblock&amp;quot;&amp;gt;&amp;lt;/th:block&amp;gt; &amp;lt;div th:insert=&amp;quot;path/file::nav&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; th:insert th:replace th:include 使用webjar引入bootsrtap 在http://mvnrepository.</description></item><item><title>[笔记]SpringBoot学习02</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A002/</link><pubDate>Thu, 20 Sep 2018 11:34:24 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A002/</guid><description>使用JPA来链接数据库 环境配置:
JDK: Java 8
IDE: Intellij IDEA
服务器: Tomcat 9
创建JPA项目 Create Project -&amp;gt; Spring Initializr 选择JDK 选择Initializr Service URL (https://start.spring.io) 选择插件 Core -&amp;gt; DevTools Web -&amp;gt; web Template Engines -&amp;gt; Thymeleaf SQL -&amp;gt; JPA, MySQL 完成 配置JPA项目 配置application.properties文件 application.properties 中配置数据库链接
spring.jpa.database=mysql spring.datasource.url=jdbc:mysql://localhost:3306/java1604 spring.datasource.username=java1604 spring.datasource.password=java1604 spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl 添加数据库链接 View -&amp;gt; Tool Windows -&amp;gt; Database -&amp;gt; 添加Data Source
添加Hibernate配置文件 File -&amp;gt; Project Structure -&amp;gt; Modules 添加Hibernate框架 添加hibernate.</description></item><item><title>[笔记]SpringBoot学习01</title><link>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A001/</link><pubDate>Tue, 11 Sep 2018 10:08:00 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E7%AC%94%E8%AE%B0springboot%E5%AD%A6%E4%B9%A001/</guid><description>Spring学习笔记 环境配置:
JDK: Java 8
IDE: Intellij IDEA
服务器: Tomcat 9
在IDEA中创建Spring项目 Create Project -&amp;gt; Spring Initializr 选择JDK 选择Initializr Service URL (https://start.spring.io) 选择插件 Core -&amp;gt; DevTools Web -&amp;gt; web Template Engines -&amp;gt; Thymeleaf 完成 创建Controller来控制地址映射 创建容纳Controller的包和类 添加注解@Controller 添加路径映射@RequestMapping @Controller //此路径将作为此类里面所有方法的根目录 @RequestMapping(value = {&amp;#34;/home&amp;#34;}) public class HomePage {} 添加方法 @Controller @RequestMapping(value = {&amp;#34;/home&amp;#34;}) public class HomePage { //此路径作为此方法的映射路径 @RequestMapping(value = {&amp;#34;/page&amp;#34;}) public String Page1(){ //此处return的字符串即为templates文件夹下的html文件名 return &amp;#34;p1&amp;#34;; } } 创建模板 在resources/templates/文件夹下创建html文件, 文件名与方法中return的值相同 启动服务器 在浏览器地址栏输入localhost:8080/home/page来访问页面 使用ResponseBody来进行内容输出 添加方法 添加@RequestMapping和@ResponseBody @Controller @RequestMapping(value = {&amp;#34;/home&amp;#34;}) public class HomePage { @RequestMapping(value = {&amp;#34;/res&amp;#34;}) @ResponseBody public String ResponseBody(){ String str = &amp;#34;ReturnResponseBodyText&amp;#34;; return str; } } 启动服务器 在浏览器地址栏输入localhost:8080/home/res来访问页面</description></item></channel></rss>