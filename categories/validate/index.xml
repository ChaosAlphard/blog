<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Validate on Ilirus</title><link>https://chaosalphard.github.io/categories/validate/</link><description>Recent content in Validate on Ilirus</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 18 Nov 2020 20:12:21 +0000</lastBuildDate><atom:link href="https://chaosalphard.github.io/categories/validate/index.xml" rel="self" type="application/rss+xml"/><item><title>Validate自定义校验注解</title><link>https://chaosalphard.github.io/p/validate%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</link><pubDate>Wed, 18 Nov 2020 20:12:21 +0000</pubDate><guid>https://chaosalphard.github.io/p/validate%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</guid><description>自定义Validator校验注解 通常来说, Hibernate Validation提供的注解已经够用了, 但有时候还是需要根据业务自定义校验规则.
自定义注解 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE }) @Repeatable(Time.List.class) // 设置自定义注解实现类 @Constraint(validatedBy = {TimeValidate.class}) public @interface Time { boolean allowNull() default false; String regexp() default &amp;#34;^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9]$&amp;#34;; String message() default &amp;#34;时间格式错误&amp;#34;; Class&amp;lt;?&amp;gt;[] groups() default {}; Class&amp;lt;? extends Payload&amp;gt;[] payload() default {}; @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE }) public @interface List { Time[] value(); } } 自定义注解实现 // 需要实现ConstraintValidator, 第一项参数是要校验的注解, 第二项是要校验的值的类型 public class TimeValidate implements ConstraintValidator&amp;lt;Time, String&amp;gt; { private boolean allowNull; private Pattern regexp; // 初始化 @Override public void initialize(Time annotation) { allowNull = annotation.</description></item><item><title>Validate参数分组校验</title><link>https://chaosalphard.github.io/p/validate%E5%8F%82%E6%95%B0%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/</link><pubDate>Tue, 10 Nov 2020 12:30:22 +0000</pubDate><guid>https://chaosalphard.github.io/p/validate%E5%8F%82%E6%95%B0%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C/</guid><description>Validator分组校验 定义接口, 接口里面不需要写任何东西, Validator会把接口视为一个一个的组
public interface IGet {} public interface IList {} public interface IAdd {} public interface IEdit {} public interface IDelete {} // 如果一个组继承了另一个组, // 则在校验属于这个组的参数时, // 也会一并校验被继承组的参数 public interface ISexFilter extends Default {} 修改参数实体类
@Data public class Param { // groups 定义该字段所属的&amp;#34;组&amp;#34; @NotNull(message = &amp;#34;id不能为空&amp;#34;, groups = {IGet.class, IEdit.class, IDelete.class}) @Null(message = &amp;#34;获取列表时不需要ID&amp;#34;, groups = IList.class) private Integer id; @NotBlank(message = &amp;#34;name不能为空&amp;#34;, groups = IAdd.class) @Null(message = &amp;#34;不能修改name&amp;#34;, groups = IEdit.</description></item><item><title>使用Validate实现参数统一校验以及自定义校验规则</title><link>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8validate%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/</link><pubDate>Sun, 08 Nov 2020 22:40:20 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8validate%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99/</guid><description>JSR-303是一项标准, JSR-349是其的升级版本, 添加了一些新特性, 这项标准规定了一些校验规范, 如@Null, @NotNull, @Pattern, 位于javax.validation.constraints包下, 只提供规范不提供实现.
Hibernate Validation是对这个规范的实践, 他提供了相应的实现, 并增加了一些其他校验注解, 如@Email, @Length, @Range等.
引入Validator依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate.validator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;6.1.6.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置Validator Validator默认会对所有数据进行校验, 然后返回结果, 如果想要在校验到数据不符合规则时直接返回结果的话, 则需要进行配置
@Configuration public class ValidatorConfiguration { @Bean public Validator validator() { return Validation.byProvider(HibernateValidator.class) .configure() // 设置校验到任意数据不符合规则时直接返回结果, 不再对剩余数据进行校验 .failFast(true) .buildValidatorFactory() .getValidator(); } } 使用Validator对Controller参数进行校验 参数实体类
@Data public class Param { @NotNull(message = &amp;#34;id不能为空&amp;#34;) private Integer id; @NotBlank(message = &amp;#34;name不能为空&amp;#34;) private String name; @NotNull(message = &amp;#34;age不能为空&amp;#34;) private Integer age; @NotNull(message = &amp;#34;sex不能为空&amp;#34;) private Byte sex; private String time; } Controller</description></item></channel></rss>