<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SpringSecurity on Ilirus</title><link>https://chaosalphard.github.io/categories/springsecurity/</link><description>Recent content in SpringSecurity on Ilirus</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 04 Apr 2020 02:10:29 +0000</lastBuildDate><atom:link href="https://chaosalphard.github.io/categories/springsecurity/index.xml" rel="self" type="application/rss+xml"/><item><title>SpringSecurity使用注解进行授权控制</title><link>https://chaosalphard.github.io/p/springsecurity%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83%E6%8E%A7%E5%88%B6/</link><pubDate>Sat, 04 Apr 2020 02:10:29 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%BF%9B%E8%A1%8C%E6%8E%88%E6%9D%83%E6%8E%A7%E5%88%B6/</guid><description>使用注解进行授权控制 从SpringSecurity2.0版本开始，支持服务层方法的安全性支持，目前有@Secured，@PreAuthorize，@PostAuthorize三类注解
在@Configuration实例上使用@EnableGlobalMethodSecurity注解来启用基于注解的授权控制
@Configuration @EnableWebSecurity // 启用方法授权 @EnableGlobalMethodSecurity( // 启用@Secured注解 securedEnabled = true, // 启用@PreAuthorize和@PostAuthorize注解 prePostEnabled = true ) public class SecurityConfig extends WebSecurityConfigurerAdapter { ... } 之后向方法(类、方法或者接口)添加注解就会限制对该方法的访问
@Secured注解 @RestController public class IndexController { // IS_AUTHENTICATED_ANONYMOUSLY: 表示可以匿名访问 @Secured(&amp;#34;IS_AUTHENTICATED_ANONYMOUSLY&amp;#34;) @RequestMapping(&amp;#34;/r&amp;#34;) public String resource() { return getUserName()+&amp;#34;访问资源&amp;#34;; } // ROLE_USER: 表示需要有USER权限才能访问 @Secured(&amp;#34;ROLE_USER&amp;#34;) @RequestMapping(&amp;#34;/r1&amp;#34;) public String resource1() { return getUserName()+&amp;#34;访问资源1&amp;#34;; } } @PreAuthorize和@PostAuthorize注解 @RestController public class IndexController { // @PreAuthorize 会在方法执行前进行权限验证 // isAnonymous() 允许匿名访问 @PreAuthorize(&amp;#34;isAnonymous()&amp;#34;) @RequestMapping(&amp;#34;/pre/a&amp;#34;) public String preAssets() { return getUserName()+&amp;#34;访问preAssets&amp;#34;; } // 拥有USER 权限才可访问 @PreAuthorize(&amp;#34;hasRole(&amp;#39;USER&amp;#39;)&amp;#34;) @RequestMapping(&amp;#34;/pre/a1&amp;#34;) public String preAssets1() { return getUserName()+&amp;#34;访问preAssets1&amp;#34;; } // @PostAuthorize 会在方法执行后进行权限验证 // 拥有USER 和ADMIN 任一权限即可访问 @PostAuthorize(&amp;#34;hasAnyRole(&amp;#39;USER&amp;#39;, &amp;#39;ADMIN&amp;#39;)&amp;#34;) @RequestMapping(&amp;#34;/post/a1&amp;#34;) public String postAssets1() { System.</description></item><item><title>SpringSecurity会话管理</title><link>https://chaosalphard.github.io/p/springsecurity%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</link><pubDate>Fri, 03 Apr 2020 01:00:28 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</guid><description>在Controller中获取认证信息 @Controller public class IndexController { @RequestMapping(&amp;#34;/user&amp;#34;) public String user(Model model) { String username = getUserName(); model.addAttribute(&amp;#34;username&amp;#34;,username); return &amp;#34;user&amp;#34;; } private String getUserName() { // 获取认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 检查用户是否认证 if(authentication == null || !authentication.isAuthenticated()) { return &amp;#34;游客&amp;#34;; } Object principal = authentication.getPrincipal(); if(principal instanceof UserDetails) { return ((UserDetails) principal).getUsername(); } else { return principal.toString(); } } } 会话控制 在配置类中通过下列选项控制会话何时创建以及Spring Security 如何与之交互
always: 如果没有session, 则创建一个 ifRequired: 如果需要, 则创建一个.</description></item><item><title>SpringSecurity自定义登录与注销</title><link>https://chaosalphard.github.io/p/springsecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E4%B8%8E%E6%B3%A8%E9%94%80/</link><pubDate>Tue, 31 Mar 2020 22:34:17 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E4%B8%8E%E6%B3%A8%E9%94%80/</guid><description>自定义登录页 修改配置
@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&amp;#34;/&amp;#34;,&amp;#34;/index&amp;#34;,&amp;#34;/error&amp;#34;,&amp;#34;/identify&amp;#34;).permitAll() .antMatchers(&amp;#34;/user/**&amp;#34;).hasRole(&amp;#34;USER&amp;#34;) .and().formLogin() // 自定义登录页面地址 .loginPage(&amp;#34;/login&amp;#34;) // 指定处理登录请求的url, 即登录表单的action对应的地址 .loginProcessingUrl(&amp;#34;/identify/login&amp;#34;) // 成功后默认跳转到的url .defaultSuccessUrl(&amp;#34;/user&amp;#34;) .and() // 禁用跨域请求验证 .csrf().disable(); } } 映射路径
// RequestMapping 的路径, 即为配置类中loginPage设置的路径 @RequestMapping(&amp;#34;/login&amp;#34;) public String login() { return &amp;#34;login&amp;#34;; } 页面编写
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34; xmlns:th=&amp;#34;http://www.thymeleaf.org&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Login&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- action中的url即为配置类中, loginProcessingUrl项设置的url --&amp;gt; &amp;lt;!</description></item><item><title>SpringSecurity简单入门</title><link>https://chaosalphard.github.io/p/springsecurity%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 23 Mar 2020 04:35:18 +0000</pubDate><guid>https://chaosalphard.github.io/p/springsecurity%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</guid><description>Spring Security 是什么 Spring Security是一套认证授权框架，支持认证模式如HTTP BASIC 认证头 (基于 IETF RFC-based 标准)，HTTP Digest 认证头 ( IETF RFC-based 标准)，Form-based authentication (用于简单的用户界面)，OpenID 认证等，Spring Security使得当前系统可以快速集成这些验证机制亦或是实现自己的一套验证机制。
Spring Security可以对所以进入系统的请求进行拦截，效验每个请求是否能访问对应的资源。
Spring Security 如何工作 Spring Security对Web 资源的保护是靠Filter来实现的，当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的过滤器，类型为org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求都会经过这个过滤器。
SpringSecurityFilterChain中包含的各个Filter都作为Bean被Spring所管理，他们是Spring Security的核心，各司其职，但这些Filter并不直接处理用户的认证，也不直接处理用户的授权，而出把这些工作交给认证管理器(AuthenticationManager)和决策管理器(AccessDecisionManager)进行处理。
认证流程 SpringSecurity认证流程
引入依赖 在pom.xml中写入以下依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 编写配置 package com.ilirus.oauth.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // 在内存中创建用户 auth.</description></item></channel></rss>