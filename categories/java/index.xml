<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Ilirus</title><link>https://chaosalphard.github.io/categories/java/</link><description>Recent content in Java on Ilirus</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 25 May 2023 20:22:46 +0800</lastBuildDate><atom:link href="https://chaosalphard.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java开发知识点简单总结-数据库</title><link>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Thu, 25 May 2023 20:22:46 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>MySQL 数据库三范式 第一范式 1NF：表中字段的数据，不可以再拆分
这张表因为姓名字段可再拆分所以不符合第一范式
ID 姓名 年龄 1 销售部小张 28 而这张表符合
ID 部门 姓名 年龄 1 销售部 小张 28 第二范式 2NF：在满足第一范式的情况下，遵循唯一性，消除部分依赖。
即：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值
通俗来讲就是一个表只能描述一件事情
学号 姓名 年龄 课程名称 成绩 学分 001 小张 28 语文 90 3 001 小张 28 数学 90 2 学号做主键，可确定姓名，但不能确定课程与成绩。所以不符合第二范式</description></item><item><title>Java开发知识点简单总结-Spring</title><link>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/</link><pubDate>Thu, 25 May 2023 20:21:46 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/</guid><description>Spring Spring IoC IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。
为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）
将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。
Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。
什么是 Spring Bean 简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。
将一个类声明为 Bean 的注解有哪些 @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。 @Component 和 @Bean 的区别是什么 @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。 @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。 @Autowired 和 @Resource 的区别是什么 @Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)</description></item><item><title>Java开发知识点简单总结</title><link>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 May 2023 15:21:46 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</guid><description>Java基础 面向对象的特点 封装，继承，多态
包装类型的缓存机制 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False
接口和抽象类有什么共同点和区别 共同点 ：
都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。 区别 ：
接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。 深拷贝和浅拷贝区别？什么是引用拷贝？ 引用拷贝就是两个不同的引用指向同一个对象。如 Object a = new Object(); Object b = a; 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。 字符串 String s1 = new String(&amp;ldquo;abc&amp;rdquo;);这句话创建了几个字符串对象？
会创建 1 或 2 个字符串对象。
如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象(new String()和&amp;quot;abc&amp;quot;)。否则创建一个字符串对象(new String())</description></item><item><title>Java中HashMap的实现原理</title><link>https://chaosalphard.github.io/p/java%E4%B8%ADhashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 24 May 2023 00:16:32 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E4%B8%ADhashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>实现原理 HashMap的实现原理
HashMap 是由数组与链表组成的，又叫链表散列。
HashMap 初始容量默认为16，如果在创建 HashMap 手动指定容量，则会自动将容量调整到大于指定容量且最接近指定容量2的整数次幂大小。
当调用 put() 方法储存 K/V键值对 时，会首先计算 K 的 hash 值，然后根据数组长度，计算得出对应的数组下标，如果 K 的 hash 值已经存在，且它们两者的 equals 返回 true，则更新键值对的值，如果返回 fasle，则说明发生 hash碰撞，jdk1.7之前会将新的键值对插入到链表头部，jdk1.8之后则是插入到链表尾部。
当数组中的元素个数大于 容量*负载因子(默认为0.75) 时，数组会进行扩容，扩容后大小变为2倍。
如果由于碰撞导致链表大小超过8，并且数组大小大于等于64时，则会将其转换为红黑树以提高查询效率，如果由于删除元素导致红黑树节点数量少于6时，则会转换为链表。
HashMap的容量为什么是2的整数次幂 在 HashMap 中，存储桶（buckets）的数量等于数组的长度。通过哈希函数将键映射到对应的存储桶，然后在存储桶中查找或存储对应的值。使用 2 的幂次方作为数组的长度，可以通过位运算代替取模运算，提高计算效率。
此外，使用 2 的幂次方作为数组长度还能够更好地分散哈希码的分布，减少哈希冲突的概率。如果数组长度不是 2 的幂次方，那么在计算哈希码与数组长度取模时，低位可能不会被充分利用，可能导致一些位的哈希码无法影响到存储桶的选择，从而增加哈希冲突的可能性。
因此，为了提高散列算法的效率和减少哈希冲突，HashMap 选择将长度设置为 2 的幂次方。这样可以通过位运算代替取模运算，提高计算效率，并且更好地分散哈希码的分布，减少哈希冲突的概率。
HashMap的负载因子为什么默认是0.75 负载因子是 HashMap 中用于衡量存储桶利用率的一个参数。在 HashMap 中，负载因子表示存储桶中键值对的平均数量与存储桶数组长度的比值。
较低的负载因子意味着存储桶中的键值对数量相对较少，可以更好地分散键的hash，减少多个键映射到同一个存储桶的情况，从而减少哈希冲突的概率。
较高的负载因子意味着更高存储桶利用率。可以用更少的存储桶储存更多的键值对，节省了更多的空间。
使用0.75作为默认负载因子是为了在减少hash碰撞与提高存储桶利用率之间达到一种平衡。
Hash的计算方法 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.</description></item><item><title>Java中ArrayList与LinkedList的区别</title><link>https://chaosalphard.github.io/p/java%E4%B8%ADarraylist%E4%B8%8Elinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Mon, 22 May 2023 13:58:14 +0800</pubDate><guid>https://chaosalphard.github.io/p/java%E4%B8%ADarraylist%E4%B8%8Elinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>ArrayList的底层实现 ArrayList 底层是基于数组来实现的，而数组是使用一组连续的空间来存储数据类型相同的数据，并且数组的空间大小是固定的。
因为数组的空间大小固定，存储的数据类型也相同，所以我们就可以通过寻址公式类随机访问数组中的任意一个下标的元素。
address[i] = baseAddress + i * dataTypeSize 因为 ArrayList 基于数组实现，而数组的空间大小是固定的，所以当数组的空间用完了，就需要对 ArrayList 底层的数组进行扩容。
当使用 ArrayList 默认的构造函数创建对象时，底层的数组实际是被赋值为一个空数组，但我们第一次调用往其中添加元素时，才会触发具体扩容逻辑，第一次扩容默认的初始化容量为10，使用了延迟加载的实现方式避免空间浪费。
ArrayList的扩容逻辑
在调用 add() 方法时，会判断 ArrayList 中 elementData 这个数组的容量是否等于 ArrayList 的大小，也就是判断 elementData 数组是不是满的，如果等于则说明当前数组空间满了，则调用 grow() 方法进行扩容，之后再添加元素到到数组中。
在看看 grow() 方法中又调用了一个带参方法 grow(int minCapacity) 参数是当前大小+1，那么我们来看下这个带参数的 grow 方法。
private Object[] grow(int minCapacity) { // 记录容量大小 int oldCapacity = elementData.length; // 判断容量大于0，并且数组不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA // DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个数组是使用ArrayList的无参构造函数时赋值给elementData的 // 也就是说这个if语句不会处理使用默认的无参构造函数创建的数组 if (oldCapacity &amp;gt; 0 || elementData !</description></item><item><title>单例模式</title><link>https://chaosalphard.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 21 Sep 2021 22:03:11 +0800</pubDate><guid>https://chaosalphard.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
实现 懒汉式 需要时加载 线程不安全 public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 启动时加载 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 双检锁 即 Double-Checked Locking</description></item><item><title>使用自定义断言处理常见的异常</title><link>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/</link><pubDate>Mon, 19 Oct 2020 23:37:23 +0000</pubDate><guid>https://chaosalphard.github.io/p/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8/</guid><description>Java中空判断随处可见，通常我们都是手动判断是否为空，然后再抛出自定义异常以及记录信息，例如:
var data = dao.findById(id); if(data == null) { log.error(&amp;#34;数据为空, id{}&amp;#34;, id); throw new CustomException(Status.USER_NOT_EXIST); } 这样的代码写多了就觉得麻烦，可不可以简化一下呢
使用Assert替代null判断 　我们都知道sprng中有一个Assert类，其中有一个方法notNull() 可以用来判断是否为空，并且输出自定义提示，何不根据此改造一下，做一个自定义的Assert类
创建枚举类接口 创建默认枚举方法，需要与你自定义枚举中的属性对应
public interface IBaseEnum { int getCode(); String getMessage(); } 创建自定义异常 public class CustomException extends Exception { private int code; private String detail; private Object data; public CustomException(IBaseEnum enums, String detail, Object data) { super(enums.getMessage()); this.code = enums.getCode(); this.detail = detail; this.data = data; } public CustomException(int code, String message, String detail, Object data) { super(message); this.</description></item><item><title>Java是值传递还是引用传递</title><link>https://chaosalphard.github.io/p/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</link><pubDate>Mon, 20 Apr 2020 23:45:38 +0000</pubDate><guid>https://chaosalphard.github.io/p/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</guid><description>进入正题之前先简单说说值传递和引用传递的区别
按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
下面是我用Rust来做的一个简单示范。
Rust
可以看到，虽然call_by_value函数和call_by_reference函数都将接收到的参数的值修改为了12450，但是由于call_by_reference函数接收的是by_ref变量的引用，所以在函数内修改by_ref的值会影响到函数外部的by_ref变量，而call_by_value函数接收的是by_val变量的值，所以在函数内修改by_val的值不会影响到函数外部的by_val变量。
对于基本数据类型, Java是值传递还是引用传递? 看下图
00
可以看到，在函数内的修改并没有影响到函数外部的num，所以对于基本数据类型, Java是值传递
对于基本数据的包装类, 也是值传递
01
对于引用类型, Java是值传递还是引用传递? 看下图
02
可以看到，在函数内的修改已经影响到了函数外部的lis，这似乎证明了对于引用类型, Java是引用传递
但是, 我们都知道, 对于引用类型, 变量保存的是指向其堆内存的地址, 也就是说, 如果将引用类型赋值给另一个变量, 修改当前变量的值, 另一个变量也会被改变, 如何理解呢? 请看下图
03
可以看到, 虽然只是修改了lis而没有去修改copy, 但由于lis和copy指向的是同一内存地址, 所以对lis的修改也会体现在copy上
ref
回到正题，既然知道了lis变量是对于堆内存中ArrayList的引用, 那么之前的结果就不成立了, 修改changeValue方法再看 04
可以看到, 在函数中将一个新的ArrayList的引用赋值给了lis变量, 但是函数外的lis变量依然指向的是原来的ArrayList, 所以得出结论, 对于引用类型, Java也是值传递
结论 无论是对于基本数据类型还是引用类型，Java都是值传递，但要注意的是，对于引用类型，变量保存的是其引用，所以通过函数接收的变量去修改其指向的引用类型，也会影响到函数外的变量，而给函数接收的变量赋予新的引用，则不会影响到函数外的变量。</description></item><item><title>Java8中新增的时间处理API</title><link>https://chaosalphard.github.io/p/java8%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86api/</link><pubDate>Sat, 18 Apr 2020 23:40:28 +0000</pubDate><guid>https://chaosalphard.github.io/p/java8%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86api/</guid><description>Java8新的时间处理API 原有的java.util.Date与新增的java.time有何差异？
java.util.Date设定为可变类型 SimpleDateFormat是非线程安全的 新的API 基于ISO 标准日历系统, 遵循Gregorian 规则 java.time包下的所有类都是不可变类型 java.time包下的所有类都是线程安全的 java.time简单介绍 java.time由以下5个包组成:
java.time: 包含值对象的基础包 java.time.chrono: 提供对不同的日历系统的访问 java.time.format: 格式化和解析时间和日期 java.time.temporal: 包括底层框架和扩展特性 java.time.zone: 包含时区支持的类 关于java.time下, 类的简介:
Instant: 时间戳 LocalDate: 只包含日期，比如: 2020-01-01 LocalTime: 只包含时间，比如: 12:00:00 LocalDateTime: 包含日期和时间，比如: 2020-01-01T12:00:00 Duration: 时间段, 主要用于计算两个时间之间的差值 Peroid: 时间段, 主要用于计算两个日期之间的差值 ZoneOffset: 时区偏移量，比如: +8:00 ZonedDateTime: 带时区的日期时间 Clock: 时钟，可以获取或指定时区, 也可获取当前的时刻 DateTimeFormatter: 时间格式化 关于java.time下大部分类的方法前缀简介:
of: 静态工厂方法(用类名去调用)。 parse: 静态工厂方法，关注于解析(用类名去调用)。 now: 静态工厂方法，用当前时间创建实例(用类名去调用) get: 获取某些东西的值。 is: 检查某些东西的是否是true。 with: 返回一个部分状态改变了的时间日期对象拷贝(单独一个with方法,参数为TemporalAdjusters类型) plus: 返回一个时间增加了的、时间日期对象拷贝(如果参数是负数也能够有minus方法的效果) minus: 返回一个时间减少了的、时间日期对象拷贝 to: 把当前时间日期对象转换成另外一个，可能会损失部分状态.</description></item></channel></rss>