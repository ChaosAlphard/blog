<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="假设要用JavaScript实现一个阶乘函数，很容易想到用递归实现:
function factorial(n) { if(n === 1) { return 1 } return n * factorial(n-1) } console.log(factorial(4)) // 24 在上述代码中，由于最后一步返回了一个表达式(n * factorial(n-1))，所以会保留n这个变量和函数factorial(n-1)的调用位置等信息，从而形成一层层的调用帧。
递归十分消耗内存，因为要同时保存非常多个调用记录，容易出现&amp;quot;栈溢出&amp;quot;错误(Stack Overflow)
尾调用 尾调用是指的一个函数的最后一个动作是返回另一个函数的调用
function foo(n) { return meh(n) } // 并不一定要在函数尾部，只要是最后一步操作即可 // 以下meh 和nco 函数均属于尾调用 function foo(n) { if(n&amp;gt;0) { return meh(n) } return nco(n) } 不属于尾调用的情况
// 函数调用后还有赋值操作，所以不属于尾调用，即使语义一样 function foo(n) { let tmp = meh(n) return tmp } // 函数调用后还有相加操作 function foo(n) { return meh(n) + 1 } // 没有返回函数调用 function foo(n) { meh(n) } 尾调用优化  　函数调用会在内存形成一个&amp;quot;调用记录&amp;quot;，又称&amp;quot;调用帧&amp;quot; (call frame)，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个&amp;quot;调用栈&amp;quot; (call stack)。"><title>ES6中的尾递归</title><link rel=canonical href=https://chaosalphard.github.io/p/es6%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="ES6中的尾递归"><meta property="og:description" content="假设要用JavaScript实现一个阶乘函数，很容易想到用递归实现:
function factorial(n) { if(n === 1) { return 1 } return n * factorial(n-1) } console.log(factorial(4)) // 24 在上述代码中，由于最后一步返回了一个表达式(n * factorial(n-1))，所以会保留n这个变量和函数factorial(n-1)的调用位置等信息，从而形成一层层的调用帧。
递归十分消耗内存，因为要同时保存非常多个调用记录，容易出现&amp;quot;栈溢出&amp;quot;错误(Stack Overflow)
尾调用 尾调用是指的一个函数的最后一个动作是返回另一个函数的调用
function foo(n) { return meh(n) } // 并不一定要在函数尾部，只要是最后一步操作即可 // 以下meh 和nco 函数均属于尾调用 function foo(n) { if(n&amp;gt;0) { return meh(n) } return nco(n) } 不属于尾调用的情况
// 函数调用后还有赋值操作，所以不属于尾调用，即使语义一样 function foo(n) { let tmp = meh(n) return tmp } // 函数调用后还有相加操作 function foo(n) { return meh(n) + 1 } // 没有返回函数调用 function foo(n) { meh(n) } 尾调用优化  　函数调用会在内存形成一个&amp;quot;调用记录&amp;quot;，又称&amp;quot;调用帧&amp;quot; (call frame)，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个&amp;quot;调用栈&amp;quot; (call stack)。"><meta property="og:url" content="https://chaosalphard.github.io/p/es6%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/"><meta property="og:site_name" content="Ilirus"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="JavaScript"><meta property="article:published_time" content="2019-06-01T15:29:46+00:00"><meta property="article:modified_time" content="2019-06-01T15:29:46+00:00"><meta name=twitter:title content="ES6中的尾递归"><meta name=twitter:description content="假设要用JavaScript实现一个阶乘函数，很容易想到用递归实现:
function factorial(n) { if(n === 1) { return 1 } return n * factorial(n-1) } console.log(factorial(4)) // 24 在上述代码中，由于最后一步返回了一个表达式(n * factorial(n-1))，所以会保留n这个变量和函数factorial(n-1)的调用位置等信息，从而形成一层层的调用帧。
递归十分消耗内存，因为要同时保存非常多个调用记录，容易出现&amp;quot;栈溢出&amp;quot;错误(Stack Overflow)
尾调用 尾调用是指的一个函数的最后一个动作是返回另一个函数的调用
function foo(n) { return meh(n) } // 并不一定要在函数尾部，只要是最后一步操作即可 // 以下meh 和nco 函数均属于尾调用 function foo(n) { if(n&amp;gt;0) { return meh(n) } return nco(n) } 不属于尾调用的情况
// 函数调用后还有赋值操作，所以不属于尾调用，即使语义一样 function foo(n) { let tmp = meh(n) return tmp } // 函数调用后还有相加操作 function foo(n) { return meh(n) + 1 } // 没有返回函数调用 function foo(n) { meh(n) } 尾调用优化  　函数调用会在内存形成一个&amp;quot;调用记录&amp;quot;，又称&amp;quot;调用帧&amp;quot; (call frame)，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个&amp;quot;调用栈&amp;quot; (call stack)。"></head><body class=article-page><script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hu3efe4cd0dfb29873d1b0d65561d00585_584028_300x0_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🌌</span></figure><h1 class=site-name><a href=https://chaosalphard.github.io>Ilirus</a></h1><h2 class=site-description>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>暗色模式</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BC%96%E7%A8%8B/>编程</a>
<a href=/categories/%E5%89%8D%E7%AB%AF/>前端</a></header><h2 class=article-title><a href=/p/es6%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92/>ES6中的尾递归</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jun 01, 2019</time></div></footer></div></header><section class=article-content><p>假设要用<code>JavaScript</code>实现一个阶乘函数，很容易想到用递归实现:</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=nx>n</span> <span class=o>===</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>1</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>n</span> <span class=o>*</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
<span class=p>}</span>

<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>factorial</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span>   <span class=c1>// 24
</span></code></pre></div><p>在上述代码中，由于最后一步返回了一个表达式(<code>n * factorial(n-1)</code>)，所以会保留<code>n</code>这个变量和函数<code>factorial(n-1)</code>的调用位置等信息，从而形成一层层的调用帧。</p><p>递归十分消耗内存，因为要同时保存非常多个调用记录，容易出现"栈溢出"错误<code>(Stack Overflow)</code></p><h1 id=尾调用>尾调用</h1><p>尾调用是指的一个函数的最后一个动作是返回另一个函数的调用</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nx>meh</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// 并不一定要在函数尾部，只要是最后一步操作即可
</span><span class=c1>// 以下meh 和nco 函数均属于尾调用
</span><span class=c1></span><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span><span class=p>(</span><span class=nx>n</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>meh</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>nco</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>不属于尾调用的情况</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=c1>// 函数调用后还有赋值操作，所以不属于尾调用，即使语义一样
</span><span class=c1></span><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=kd>let</span> <span class=nx>tmp</span> <span class=o>=</span> <span class=nx>meh</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
  <span class=k>return</span> <span class=nx>tmp</span>
<span class=p>}</span>

<span class=c1>// 函数调用后还有相加操作
</span><span class=c1></span><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nx>meh</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
<span class=p>}</span>

<span class=c1>// 没有返回函数调用
</span><span class=c1></span><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>meh</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h1 id=尾调用优化>尾调用优化</h1><blockquote><p>　　函数调用会在内存形成一个"调用记录"，又称"调用帧" (call frame)，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个"调用栈" (call stack)。<br>　　尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p></blockquote><p>举例:</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>getItem</span><span class=p>(</span><span class=nx>item</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nx>item</span>
<span class=p>}</span>

<span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
  <span class=kd>let</span> <span class=nx>a</span><span class=o>=</span><span class=mi>1</span>
  <span class=kd>let</span> <span class=nx>b</span><span class=o>=</span><span class=mi>2</span>
  <span class=k>return</span> <span class=nx>getItem</span><span class=p>(</span><span class=nx>a</span><span class=o>+</span><span class=nx>b</span><span class=p>)</span>
<span class=p>}</span>
<span class=nx>foo</span><span class=p>()</span>
</code></pre></div><p>上述代码中，如果函数<code>getItem</code>不是尾调用，函数<code>foo</code>就要保存内部变量<code>m</code>和<code>n</code>的值，以及函数<code>getItem</code>的调用位置等信息。<br>但如果调用<code>getItem</code>后，函数<code>foo</code>就结束了，所以执行到最后一步，可以删除<code>foo</code>的调用帧，只保留<code>getItem(3)</code>的调用帧。</p><blockquote><p>&ldquo;尾调用优化&rdquo; (Tail call optimization)，即只保留内层函数的调用帧。<br><strong>PS: 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行"尾调用优化"。</strong></p></blockquote><h1 id=尾递归>尾递归</h1><p>函数调用自身，称为递归；如果尾调用自身，就称为尾递归。</p><blockquote><p>对于尾递归来说，由于只存在一个调用帧，所以能有效的避免"栈溢出"错误的发生。</p></blockquote><p>改写之前的代码:</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span><span class=nx>total</span><span class=p>)</span> <span class=p>{</span>
  <span class=s2>&#34;use strict&#34;</span>
  <span class=nx>total</span> <span class=o>=</span> <span class=nx>total</span> <span class=o>||</span> <span class=mi>1</span>
  <span class=k>if</span><span class=p>(</span><span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=nx>total</span>
  <span class=k>return</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>n</span><span class=o>*</span><span class=nx>total</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p><strong>ES6的尾调用优化只在严格模式下开启，正常模式是无效的</strong></p><p>在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>arguments: 返回调用时函数的参数。</li><li>caller: 返回调用当前函数的那个函数。</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><p>参考:</p><blockquote><p><a href=https://github.com/tc39/proposal-ptc-syntax/blob/master/README.md>https://github.com/tc39/proposal-ptc-syntax/blob/master/README.md</a></p></blockquote><p><strong>补充(2019.06.02): 出于某些因素的考虑，目前V8引擎中的尾递归优化已经被去掉了</strong></p><p>大概原因可以看这篇博客:</p><blockquote><p><a href=https://imweb.io/topic/5a244260a192c3b460fce275>https://imweb.io/topic/5a244260a192c3b460fce275</a></p></blockquote><h1 id=尾递归优化的实现>尾递归优化的实现</h1><p>正常模式下如何实现尾递归优化呢?</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>sum</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span><span class=nx>y</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>sum</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>y</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>x</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
<span class=nx>sum</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>100000</span><span class=p>)</span>
</code></pre></div><p>尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。</p><div class=highlight><pre class=chroma><code class=language-javascript data-lang=javascript><span class=kd>function</span> <span class=nx>tco</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span> <span class=p>{</span>
  <span class=kd>var</span> <span class=nx>value</span><span class=p>;</span>
  <span class=kd>var</span> <span class=nx>active</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
  <span class=kd>var</span> <span class=nx>accumulated</span> <span class=o>=</span> <span class=p>[];</span>

  <span class=k>return</span> <span class=kd>function</span> <span class=nx>accumulator</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>accumulated</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>arguments</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>active</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>active</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
      <span class=k>while</span> <span class=p>(</span><span class=nx>accumulated</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>value</span> <span class=o>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>accumulated</span><span class=p>.</span><span class=nx>shift</span><span class=p>());</span>
      <span class=p>}</span>
      <span class=nx>active</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
      <span class=k>return</span> <span class=nx>value</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>};</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=nx>sum</span> <span class=o>=</span> <span class=nx>tco</span><span class=p>(</span><span class=kd>function</span> <span class=nx>sum</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span><span class=nx>y</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=nx>y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>sum</span><span class=p>(</span><span class=nx>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>y</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>x</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>})</span>

<span class=nx>sum</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>100000</span><span class=p>)</span>
</code></pre></div></section><footer class=article-footer><section class=article-tags><a href=/tags/javascript/>JavaScript</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/webpack%E4%B8%ADcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/><div class=article-details><h2 class=article-title>Webpack中CSS样式的处理</h2></div></a></article><article><a href=/p/webpack%E9%85%8D%E7%BD%AEhtml-template/><div class=article-details><h2 class=article-title>Webpack配置HTML Template</h2></div></a></article><article><a href=/p/webpack%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/><div class=article-details><h2 class=article-title>Webpack的安装与配置</h2></div></a></article><article><a href=/p/vue-router%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/><div class=article-details><h2 class=article-title>Vue Router的安装与使用</h2></div></a></article><article><a href=/p/%E4%BD%BF%E7%94%A8vue-cli%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/><div class=article-details><h2 class=article-title>使用Vue-cli搭建Vue项目</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Ilirus</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script></body></html>