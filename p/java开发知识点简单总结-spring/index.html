<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Spring Spring IoC IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。
为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）
将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。
Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。
什么是 Spring Bean 简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。
将一个类声明为 Bean 的注解有哪些  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。  @Component 和 @Bean 的区别是什么  @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。 @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。  @Autowired 和 @Resource 的区别是什么 @Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)"><title>Java开发知识点简单总结-Spring</title><link rel=canonical href=https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Java开发知识点简单总结-Spring"><meta property="og:description" content="Spring Spring IoC IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。
为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）
将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。
Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。
什么是 Spring Bean 简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。
将一个类声明为 Bean 的注解有哪些  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。  @Component 和 @Bean 的区别是什么  @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。 @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。  @Autowired 和 @Resource 的区别是什么 @Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)"><meta property="og:url" content="https://chaosalphard.github.io/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/"><meta property="og:site_name" content="Ilirus"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Java"><meta property="article:published_time" content="2023-05-25T20:21:46+08:00"><meta property="article:modified_time" content="2023-05-25T20:21:46+08:00"><meta name=twitter:title content="Java开发知识点简单总结-Spring"><meta name=twitter:description content="Spring Spring IoC IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。
为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）
将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。
在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。
Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。
什么是 Spring Bean 简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。
将一个类声明为 Bean 的注解有哪些  @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。  @Component 和 @Bean 的区别是什么  @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。 @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。  @Autowired 和 @Resource 的区别是什么 @Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)"></head><body class="article-page has-toc"><script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://chaosalphard.github.io class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>返回</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%BC%96%E7%A8%8B/>编程</a>
<a href=/categories/java/>Java</a></header><h2 class=article-title><a href=/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-spring/>Java开发知识点简单总结-Spring</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>May 25, 2023</time></div></footer></div></header><section class=article-content><h2 id=spring>Spring</h2><h3 id=spring-ioc>Spring IoC</h3><p>IoC (Inverse of Control:控制反转) 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p><p>为什么叫控制反转？控制 ：指的是对象创建（实例化、管理）的权力。反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><h4 id=什么是-spring-bean>什么是 Spring Bean</h4><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><h4 id=将一个类声明为-bean-的注解有哪些>将一个类声明为 Bean 的注解有哪些</h4><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h4 id=component-和-bean-的区别是什么>@Component 和 @Bean 的区别是什么</h4><ul><li>@Component 注解作用于类，而@Bean注解作用于方法。</li><li>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li></ul><h4 id=autowired-和-resource-的区别是什么>@Autowired 和 @Resource 的区别是什么</h4><p>@Autowired 属于 Spring 内置的注解，默认的注入方式为byType (根据类型进行匹配)<br>@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。</p><h4 id=bean-的作用域有哪些>Bean 的作用域有哪些</h4><p>使用<code>@Scope()</code>可配置bean的作用域</p><ul><li>singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li>prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。</li><li>request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li>session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li>application/global-session （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。</li><li>websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><h3 id=spring-aop>Spring AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><h4 id=spring-aop-和-aspectj-aop-有什么区别>Spring AOP 和 AspectJ AOP 有什么区别</h4><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><h4 id=aspectj-定义的通知类型有哪些>AspectJ 定义的通知类型有哪些</h4><ul><li>Before（前置通知）：目标对象的方法调用之前触发</li><li>After （后置通知）：目标对象的方法调用之后触发</li><li>AfterReturning（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li>AfterThrowing（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li>Around： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h4 id=多个切面的执行顺序如何控制>多个切面的执行顺序如何控制</h4><p>使用 @Order 注解，或者使用 Ordered 接口重写 getOrder() 方法</p><h3 id=spring-mvc>Spring MVC</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><h4 id=spring-mvc-的核心组件有哪些>Spring MVC 的核心组件有哪些</h4><ul><li>DispatcherServlet ：核心的中央处理器，负责接收请求、分发，并给予客户端响应。</li><li>HandlerMapping ：处理器映射器，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>HandlerAdapter ：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li>Handler ：请求处理器，处理实际请求的处理器。</li><li>ViewResolver ：视图解析器，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端</li></ul><h4 id=springspringmvc与springboot的区别>Spring、SpringMVC与Springboot的区别</h4><p><code>Spring</code> 是一个综合性的开发框架，提供了大量的功能和模块，用于开发各种类型的应用程序，包括Web应用、企业级应用、批处理应用等。Spring框架采用模块化的设计，包含了核心容器、数据访问、Web开发、AOP、消息队列等模块。使用Spring框架，开发人员需要手动进行配置和设置，定义各个模块的组件和关系。</p><p><code>Spring Boot</code> 是一个用于快速构建独立的、可扩展的、基于Spring的应用程序的框架。它旨在简化Spring应用程序的配置和部署过程。Spring Boot提供了自动配置的特性，通过约定大于配置的方式，大大减少了开发人员需要编写的配置代码量。它内置了一个嵌入式Servlet容器（如Tomcat、Jetty等），可以独立运行应用程序，而无需外部的Java EE容器。</p><p><code>Spring MVC</code> 是基于Spring框架的一个Web应用程序开发框架，它提供了一套用于构建Web应用程序的组件和模型。Spring MVC需要进行配置和设置，包括定义控制器、处理请求映射、配置视图解析器等。它是基于Servlet技术的，需要依赖于Java EE容器（如Tomcat）来运行。</p><p>综上所述，<code>Spring</code>是一个综合性的开发框架，提供了各种模块和功能，需要手动配置和设置。<br><code>Spring MVC</code>是一个传统的基于Spring的Web应用程序开发框架，需要进行详细的配置和设置。<br><code>Spring Boot</code>是Spring的子项目，旨在简化配置和部署过程，提供了自动配置和开箱即用的特性，使得开发人员能够更加快速地搭建和开发应用程序。可以说，Spring Boot是在Spring框架的基础上提供了更高层次的抽象和简化。</p><h4 id=springboot的自动配置>Springboot的自动配置</h4><p>重点在<code>@EnableAutoConfiguration</code> 注解，约定大于配置，@EnableAutoConfiguration注解可以自动载入应用程序所需要的所有默认配置</p><h4 id=springboot-中的-starter>SpringBoot 中的 starter</h4><p>starter提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。</p><h4 id=spring-boot-的核心注解是哪个>Spring Boot 的核心注解是哪个</h4><p>启动类上面的注解<code>@SpringBootApplication</code>，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><ul><li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li><li>@ComponentScan：Spring组件扫描。</li></ul><h3 id=spring事务>Spring事务</h3><h4 id=spring管理事务的方式有几种>Spring管理事务的方式有几种</h4><ul><li>编程式事务 ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>声明式事务 ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）
PS: @Transactional默认只在RuntimeException回滚，通常需要手动指定<code>@Transactional(rollbackFor = Exception.class)</code></li></ul><h4 id=spring事务有哪几种传播行为>Spring事务有哪几种传播行为</h4><p>当事务方法被另一个事务方法调用时，需要指定事务应该如何传播</p><p>1.TransactionDefinition.PROPAGATION_REQUIRED<br>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。</p><p>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW<br>创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p>3.TransactionDefinition.PROPAGATION_NESTED<br>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p><p>4.TransactionDefinition.PROPAGATION_MANDATORY<br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p><strong>以下3种传播方式会导致事务失效</strong></p><p>5.TransactionDefinition.PROPAGATION_SUPPORTS<br>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p>6.TransactionDefinition.PROPAGATION_NOT_SUPPORTED<br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>7.TransactionDefinition.PROPAGATION_NEVER<br>以非事务方式运行，如果当前存在事务，则抛出异常。</p><h4 id=spring事务的隔离级别有哪几种>Spring事务的隔离级别有哪几种</h4><p>TransactionDefinition.ISOLATION_DEFAULT<br>使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.</p><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED<br>最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p><p>TransactionDefinition.ISOLATION_READ_COMMITTED<br>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p><p>TransactionDefinition.ISOLATION_REPEATABLE_READ<br>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p>TransactionDefinition.ISOLATION_SERIALIZABLE<br>最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p><h4 id=spring事务失效的几种情况>Spring事务失效的几种情况</h4><ul><li><strong>方法不是<code>public</code>修饰的</strong>。Spring要求被代理的方法必须是public的</li><li><strong>方法被<code>final</code>修饰</strong>。Spring事务底层使用了aop，也就是通过<code>jdk动态代理</code>或者<code>cglib</code>生成代理类，如果方法被final修饰了，在代理类里就无法重写该方法，也无法添加事务功能。被<code>static</code>修饰的方法也一样会失效。</li><li><strong>在类的内部被调用</strong>。例如在add方法中调用this.update，这样不会经过Spring的代理，也就无法被Spring添加事务。解决方法是使用 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动添加事务</li><li><strong>业务与事务不在同一线程中</strong>。Spring事务实现中使用了ThreadLocal，ThreadLocal只能在同一个线程中生效，例如在方法中使用了另一个线程操作数据库则事务不会生效</li><li><strong>异常类型不匹配</strong>。<code>@Transactional</code>默认只在遇到RuntimeException时回滚，如果要所有都回滚则需要配置<code>@Transactional(rollbackFor=Exception.class)</code></li><li><strong>异常被方法内部处理</strong>。异常被方法内部处理而没有抛出异常，则不会进行回滚</li><li><strong>数据源未配置事务管理器</strong>。</li><li><strong>数据库引擎不支持事务</strong>。MySQL5.5之前的默认存储引擎是<strong>MyISAM</strong>，这个引擎不支持事务，<strong>Innodb</strong>才支持</li><li><strong>事务传播行为设置错误</strong>。PROPAGATION_SUPPORTS，PROPAGATION_NOT_SUPPORTED，PROPAGATION_NEVER 会导致方法运行在非事务状态下，从而导致事务失效</li><li>类未被Spring管理，例如未注册为Bean(没添加相应注解 @Controller,@Service,@Component,@Bean)</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>相关文章</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93/><div class=article-details><h2 class=article-title>Java开发知识点简单总结-数据库</h2></div></a></article><article><a href=/p/java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/><div class=article-details><h2 class=article-title>Java开发知识点简单总结</h2></div></a></article><article><a href=/p/java%E4%B8%ADhashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><div class=article-details><h2 class=article-title>Java中HashMap的实现原理</h2></div></a></article><article><a href=/p/java%E4%B8%ADarraylist%E4%B8%8Elinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB/><div class=article-details><h2 class=article-title>Java中ArrayList与LinkedList的区别</h2></div></a></article><article><a href=/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/><div class=article-details><h2 class=article-title>单例模式</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Ilirus</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#spring>Spring</a><ol><li><a href=#spring-ioc>Spring IoC</a><ol><li><a href=#什么是-spring-bean>什么是 Spring Bean</a></li><li><a href=#将一个类声明为-bean-的注解有哪些>将一个类声明为 Bean 的注解有哪些</a></li><li><a href=#component-和-bean-的区别是什么>@Component 和 @Bean 的区别是什么</a></li><li><a href=#autowired-和-resource-的区别是什么>@Autowired 和 @Resource 的区别是什么</a></li><li><a href=#bean-的作用域有哪些>Bean 的作用域有哪些</a></li></ol></li><li><a href=#spring-aop>Spring AOP</a><ol><li><a href=#spring-aop-和-aspectj-aop-有什么区别>Spring AOP 和 AspectJ AOP 有什么区别</a></li><li><a href=#aspectj-定义的通知类型有哪些>AspectJ 定义的通知类型有哪些</a></li><li><a href=#多个切面的执行顺序如何控制>多个切面的执行顺序如何控制</a></li></ol></li><li><a href=#spring-mvc>Spring MVC</a><ol><li><a href=#spring-mvc-的核心组件有哪些>Spring MVC 的核心组件有哪些</a></li><li><a href=#springspringmvc与springboot的区别>Spring、SpringMVC与Springboot的区别</a></li><li><a href=#springboot的自动配置>Springboot的自动配置</a></li><li><a href=#springboot-中的-starter>SpringBoot 中的 starter</a></li><li><a href=#spring-boot-的核心注解是哪个>Spring Boot 的核心注解是哪个</a></li></ol></li><li><a href=#spring事务>Spring事务</a><ol><li><a href=#spring管理事务的方式有几种>Spring管理事务的方式有几种</a></li><li><a href=#spring事务有哪几种传播行为>Spring事务有哪几种传播行为</a></li><li><a href=#spring事务的隔离级别有哪几种>Spring事务的隔离级别有哪几种</a></li><li><a href=#spring事务失效的几种情况>Spring事务失效的几种情况</a></li></ol></li></ol></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script></body></html>